use windows_sys::{
    core::*,
    Win32::{Foundation::*, Graphics::Gdi::*, System::Com::IStream, UI::WindowsAndMessaging::*},
};
type CLSID = GUID;
type LPWSTR = PWSTR;

/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type size_t = ::core::ffi::c_ulonglong;
pub type ULONG = ::core::ffi::c_ulong;
pub type DWORD = ::core::ffi::c_ulong;
pub type BOOL = ::core::ffi::c_int;
pub type BYTE = ::core::ffi::c_uchar;
pub type WORD = ::core::ffi::c_ushort;
pub type LPBYTE = *mut BYTE;
pub type INT = ::core::ffi::c_int;
pub type UINT = ::core::ffi::c_uint;
pub type INT16 = ::core::ffi::c_short;
pub type UINT16 = ::core::ffi::c_ushort;
pub type UINT32 = ::core::ffi::c_uint;
pub type UINT_PTR = *mut ::core::ffi::c_ulonglong;
pub type ULONG_PTR = *mut ::core::ffi::c_ulonglong;
pub type CHAR = ::core::ffi::c_char;
pub type LONG = ::core::ffi::c_long;
pub type WCHAR = u16;
pub type HRESULT = ::core::ffi::c_long;
pub type LANGID = WORD;
pub type LONGLONG = ::core::ffi::c_longlong;
pub type ULONGLONG = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_QuadPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER),
                "::",
                stringify!(QuadPart)
            )
        );
    }
    test_field_QuadPart();
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_QuadPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER),
                "::",
                stringify!(QuadPart)
            )
        );
    }
    test_field_QuadPart();
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type IID = GUID;
pub type SIZEL = SIZE;
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type PROPID = ULONG;
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
    pub vtable_: *const IUnknown__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_IUnknown() {
    assert_eq!(
        ::core::mem::size_of::<IUnknown>(),
        8usize,
        concat!("Size of: ", stringify!(IUnknown))
    );
    assert_eq!(
        ::core::mem::align_of::<IUnknown>(),
        8usize,
        concat!("Alignment of ", stringify!(IUnknown))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
    pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ISequentialStream() {
    assert_eq!(
        ::core::mem::size_of::<ISequentialStream>(),
        8usize,
        concat!("Size of: ", stringify!(ISequentialStream))
    );
    assert_eq!(
        ::core::mem::align_of::<ISequentialStream>(),
        8usize,
        concat!("Alignment of ", stringify!(ISequentialStream))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDirectDrawSurface7 {
    _unused: [u8; 0],
}
extern "C" {
    pub fn GdipAlloc(size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn GdipFree(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn GdipCreatePath(brushMode: GpFillMode, path: *mut *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePath2(
        arg1: *const GpPointF,
        arg2: *const BYTE,
        arg3: INT,
        arg4: GpFillMode,
        path: *mut *mut GpPath,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePath2I(
        arg1: *const GpPoint,
        arg2: *const BYTE,
        arg3: INT,
        arg4: GpFillMode,
        path: *mut *mut GpPath,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipClonePath(path: *mut GpPath, clonePath: *mut *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipDeletePath(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipResetPath(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPointCount(path: *mut GpPath, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathTypes(path: *mut GpPath, types: *mut BYTE, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathPoints(arg1: *mut GpPath, points: *mut GpPointF, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathPointsI(arg1: *mut GpPath, points: *mut GpPoint, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathFillMode(path: *mut GpPath, fillmode: *mut GpFillMode) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathFillMode(path: *mut GpPath, fillmode: GpFillMode) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathData(path: *mut GpPath, pathData: *mut GpPathData) -> GpStatus;
}
extern "C" {
    pub fn GdipStartPathFigure(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipClosePathFigure(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipClosePathFigures(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathMarker(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipClearPathMarkers(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipReversePath(path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathLastPoint(path: *mut GpPath, lastPoint: *mut GpPointF) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathLine(path: *mut GpPath, x1: REAL, y1: REAL, x2: REAL, y2: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathLine2(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathArc(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathBezier(
        path: *mut GpPath,
        x1: REAL,
        y1: REAL,
        x2: REAL,
        y2: REAL,
        x3: REAL,
        y3: REAL,
        x4: REAL,
        y4: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathBeziers(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathCurve(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathCurve2(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathCurve3(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathClosedCurve(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathClosedCurve2(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathRectangle(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathRectangles(path: *mut GpPath, rects: *const GpRectF, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathEllipse(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathPie(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathPolygon(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathPath(path: *mut GpPath, addingPath: *const GpPath, connect: BOOL)
        -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathString(
        path: *mut GpPath,
        string: *const WCHAR,
        length: INT,
        family: *const GpFontFamily,
        style: INT,
        emSize: REAL,
        layoutRect: *const RectF,
        format: *const GpStringFormat,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathStringI(
        path: *mut GpPath,
        string: *const WCHAR,
        length: INT,
        family: *const GpFontFamily,
        style: INT,
        emSize: REAL,
        layoutRect: *const Rect,
        format: *const GpStringFormat,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathLineI(path: *mut GpPath, x1: INT, y1: INT, x2: INT, y2: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathLine2I(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathArcI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathBezierI(
        path: *mut GpPath,
        x1: INT,
        y1: INT,
        x2: INT,
        y2: INT,
        x3: INT,
        y3: INT,
        x4: INT,
        y4: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathBeziersI(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathCurveI(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathCurve2I(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathCurve3I(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathClosedCurveI(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathClosedCurve2I(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathRectangleI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathRectanglesI(path: *mut GpPath, rects: *const GpRect, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathEllipseI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathPieI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipAddPathPolygonI(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipFlattenPath(path: *mut GpPath, matrix: *mut GpMatrix, flatness: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipWindingModeOutline(
        path: *mut GpPath,
        matrix: *mut GpMatrix,
        flatness: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipWidenPath(
        nativePath: *mut GpPath,
        pen: *mut GpPen,
        matrix: *mut GpMatrix,
        flatness: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipWarpPath(
        path: *mut GpPath,
        matrix: *mut GpMatrix,
        points: *const GpPointF,
        count: INT,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        warpMode: WarpMode,
        flatness: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTransformPath(path: *mut GpPath, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathWorldBounds(
        path: *mut GpPath,
        bounds: *mut GpRectF,
        matrix: *const GpMatrix,
        pen: *const GpPen,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathWorldBoundsI(
        path: *mut GpPath,
        bounds: *mut GpRect,
        matrix: *const GpMatrix,
        pen: *const GpPen,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisiblePathPoint(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisiblePathPointI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsOutlineVisiblePathPoint(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        pen: *mut GpPen,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsOutlineVisiblePathPointI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        pen: *mut GpPen,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePathIter(iterator: *mut *mut GpPathIterator, path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipDeletePathIter(iterator: *mut GpPathIterator) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterNextSubpath(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        startIndex: *mut INT,
        endIndex: *mut INT,
        isClosed: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterNextSubpathPath(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        path: *mut GpPath,
        isClosed: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterNextPathType(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        pathType: *mut BYTE,
        startIndex: *mut INT,
        endIndex: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterNextMarker(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        startIndex: *mut INT,
        endIndex: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterNextMarkerPath(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        path: *mut GpPath,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterGetCount(iterator: *mut GpPathIterator, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterGetSubpathCount(iterator: *mut GpPathIterator, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterIsValid(iterator: *mut GpPathIterator, valid: *mut BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterHasCurve(iterator: *mut GpPathIterator, hasCurve: *mut BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterRewind(iterator: *mut GpPathIterator) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterEnumerate(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        points: *mut GpPointF,
        types: *mut BYTE,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPathIterCopyData(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        points: *mut GpPointF,
        types: *mut BYTE,
        startIndex: INT,
        endIndex: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMatrix(matrix: *mut *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMatrix2(
        m11: REAL,
        m12: REAL,
        m21: REAL,
        m22: REAL,
        dx: REAL,
        dy: REAL,
        matrix: *mut *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMatrix3(
        rect: *const GpRectF,
        dstplg: *const GpPointF,
        matrix: *mut *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMatrix3I(
        rect: *const GpRect,
        dstplg: *const GpPoint,
        matrix: *mut *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneMatrix(matrix: *mut GpMatrix, cloneMatrix: *mut *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteMatrix(matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipSetMatrixElements(
        matrix: *mut GpMatrix,
        m11: REAL,
        m12: REAL,
        m21: REAL,
        m22: REAL,
        dx: REAL,
        dy: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipMultiplyMatrix(
        matrix: *mut GpMatrix,
        matrix2: *mut GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateMatrix(
        matrix: *mut GpMatrix,
        offsetX: REAL,
        offsetY: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipScaleMatrix(
        matrix: *mut GpMatrix,
        scaleX: REAL,
        scaleY: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRotateMatrix(matrix: *mut GpMatrix, angle: REAL, order: GpMatrixOrder) -> GpStatus;
}
extern "C" {
    pub fn GdipShearMatrix(
        matrix: *mut GpMatrix,
        shearX: REAL,
        shearY: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipInvertMatrix(matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipTransformMatrixPoints(
        matrix: *mut GpMatrix,
        pts: *mut GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTransformMatrixPointsI(
        matrix: *mut GpMatrix,
        pts: *mut GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipVectorTransformMatrixPoints(
        matrix: *mut GpMatrix,
        pts: *mut GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipVectorTransformMatrixPointsI(
        matrix: *mut GpMatrix,
        pts: *mut GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMatrixElements(matrix: *const GpMatrix, matrixOut: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipIsMatrixInvertible(matrix: *const GpMatrix, result: *mut BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipIsMatrixIdentity(matrix: *const GpMatrix, result: *mut BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipIsMatrixEqual(
        matrix: *const GpMatrix,
        matrix2: *const GpMatrix,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateRegion(region: *mut *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateRegionRect(rect: *const GpRectF, region: *mut *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateRegionRectI(rect: *const GpRect, region: *mut *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateRegionPath(path: *mut GpPath, region: *mut *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateRegionRgnData(
        regionData: *const BYTE,
        size: INT,
        region: *mut *mut GpRegion,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateRegionHrgn(hRgn: HRGN, region: *mut *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneRegion(region: *mut GpRegion, cloneRegion: *mut *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteRegion(region: *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipSetInfinite(region: *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipSetEmpty(region: *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipCombineRegionRect(
        region: *mut GpRegion,
        rect: *const GpRectF,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCombineRegionRectI(
        region: *mut GpRegion,
        rect: *const GpRect,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCombineRegionPath(
        region: *mut GpRegion,
        path: *mut GpPath,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCombineRegionRegion(
        region: *mut GpRegion,
        region2: *mut GpRegion,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateRegion(region: *mut GpRegion, dx: REAL, dy: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateRegionI(region: *mut GpRegion, dx: INT, dy: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipTransformRegion(region: *mut GpRegion, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionBounds(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        rect: *mut GpRectF,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionBoundsI(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        rect: *mut GpRect,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionHRgn(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        hRgn: *mut HRGN,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsEmptyRegion(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsInfiniteRegion(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsEqualRegion(
        region: *mut GpRegion,
        region2: *mut GpRegion,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionDataSize(region: *mut GpRegion, bufferSize: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionData(
        region: *mut GpRegion,
        buffer: *mut BYTE,
        bufferSize: UINT,
        sizeFilled: *mut UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleRegionPoint(
        region: *mut GpRegion,
        x: REAL,
        y: REAL,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleRegionPointI(
        region: *mut GpRegion,
        x: INT,
        y: INT,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleRegionRect(
        region: *mut GpRegion,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleRegionRectI(
        region: *mut GpRegion,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionScansCount(
        region: *mut GpRegion,
        count: *mut UINT,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionScans(
        region: *mut GpRegion,
        rects: *mut GpRectF,
        count: *mut INT,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRegionScansI(
        region: *mut GpRegion,
        rects: *mut GpRect,
        count: *mut INT,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneBrush(brush: *mut GpBrush, cloneBrush: *mut *mut GpBrush) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteBrush(brush: *mut GpBrush) -> GpStatus;
}
extern "C" {
    pub fn GdipGetBrushType(brush: *mut GpBrush, type_: *mut GpBrushType) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateHatchBrush(
        hatchstyle: GpHatchStyle,
        forecol: ARGB,
        backcol: ARGB,
        brush: *mut *mut GpHatch,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetHatchStyle(brush: *mut GpHatch, hatchstyle: *mut GpHatchStyle) -> GpStatus;
}
extern "C" {
    pub fn GdipGetHatchForegroundColor(brush: *mut GpHatch, forecol: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipGetHatchBackgroundColor(brush: *mut GpHatch, backcol: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateTexture(
        image: *mut GpImage,
        wrapmode: GpWrapMode,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateTexture2(
        image: *mut GpImage,
        wrapmode: GpWrapMode,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateTextureIA(
        image: *mut GpImage,
        imageAttributes: *const GpImageAttributes,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateTexture2I(
        image: *mut GpImage,
        wrapmode: GpWrapMode,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateTextureIAI(
        image: *mut GpImage,
        imageAttributes: *const GpImageAttributes,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetTextureTransform(brush: *mut GpTexture, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipSetTextureTransform(brush: *mut GpTexture, matrix: *const GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipResetTextureTransform(brush: *mut GpTexture) -> GpStatus;
}
extern "C" {
    pub fn GdipMultiplyTextureTransform(
        brush: *mut GpTexture,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateTextureTransform(
        brush: *mut GpTexture,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipScaleTextureTransform(
        brush: *mut GpTexture,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRotateTextureTransform(
        brush: *mut GpTexture,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetTextureWrapMode(brush: *mut GpTexture, wrapmode: GpWrapMode) -> GpStatus;
}
extern "C" {
    pub fn GdipGetTextureWrapMode(brush: *mut GpTexture, wrapmode: *mut GpWrapMode) -> GpStatus;
}
extern "C" {
    pub fn GdipGetTextureImage(brush: *mut GpTexture, image: *mut *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateSolidFill(color: ARGB, brush: *mut *mut GpSolidFill) -> GpStatus;
}
extern "C" {
    pub fn GdipSetSolidFillColor(brush: *mut GpSolidFill, color: ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipGetSolidFillColor(brush: *mut GpSolidFill, color: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateLineBrush(
        point1: *const GpPointF,
        point2: *const GpPointF,
        color1: ARGB,
        color2: ARGB,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateLineBrushI(
        point1: *const GpPoint,
        point2: *const GpPoint,
        color1: ARGB,
        color2: ARGB,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateLineBrushFromRect(
        rect: *const GpRectF,
        color1: ARGB,
        color2: ARGB,
        mode: LinearGradientMode,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateLineBrushFromRectI(
        rect: *const GpRect,
        color1: ARGB,
        color2: ARGB,
        mode: LinearGradientMode,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateLineBrushFromRectWithAngle(
        rect: *const GpRectF,
        color1: ARGB,
        color2: ARGB,
        angle: REAL,
        isAngleScalable: BOOL,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateLineBrushFromRectWithAngleI(
        rect: *const GpRect,
        color1: ARGB,
        color2: ARGB,
        angle: REAL,
        isAngleScalable: BOOL,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineColors(brush: *mut GpLineGradient, color1: ARGB, color2: ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineColors(brush: *mut GpLineGradient, colors: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineRect(brush: *mut GpLineGradient, rect: *mut GpRectF) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineRectI(brush: *mut GpLineGradient, rect: *mut GpRect) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineGammaCorrection(
        brush: *mut GpLineGradient,
        useGammaCorrection: BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineGammaCorrection(
        brush: *mut GpLineGradient,
        useGammaCorrection: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineBlendCount(brush: *mut GpLineGradient, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineBlend(
        brush: *mut GpLineGradient,
        blend: *mut REAL,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineBlend(
        brush: *mut GpLineGradient,
        blend: *const REAL,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLinePresetBlendCount(brush: *mut GpLineGradient, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLinePresetBlend(
        brush: *mut GpLineGradient,
        blend: *mut ARGB,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLinePresetBlend(
        brush: *mut GpLineGradient,
        blend: *const ARGB,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineSigmaBlend(brush: *mut GpLineGradient, focus: REAL, scale: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineLinearBlend(brush: *mut GpLineGradient, focus: REAL, scale: REAL)
        -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineWrapMode(brush: *mut GpLineGradient, wrapmode: GpWrapMode) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineWrapMode(brush: *mut GpLineGradient, wrapmode: *mut GpWrapMode) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineTransform(brush: *mut GpLineGradient, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipSetLineTransform(brush: *mut GpLineGradient, matrix: *const GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipResetLineTransform(brush: *mut GpLineGradient) -> GpStatus;
}
extern "C" {
    pub fn GdipMultiplyLineTransform(
        brush: *mut GpLineGradient,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateLineTransform(
        brush: *mut GpLineGradient,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipScaleLineTransform(
        brush: *mut GpLineGradient,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRotateLineTransform(
        brush: *mut GpLineGradient,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePathGradient(
        points: *const GpPointF,
        count: INT,
        wrapMode: GpWrapMode,
        polyGradient: *mut *mut GpPathGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePathGradientI(
        points: *const GpPoint,
        count: INT,
        wrapMode: GpWrapMode,
        polyGradient: *mut *mut GpPathGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePathGradientFromPath(
        path: *const GpPath,
        polyGradient: *mut *mut GpPathGradient,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientCenterColor(
        brush: *mut GpPathGradient,
        colors: *mut ARGB,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientCenterColor(brush: *mut GpPathGradient, colors: ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientSurroundColorsWithCount(
        brush: *mut GpPathGradient,
        color: *mut ARGB,
        count: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientSurroundColorsWithCount(
        brush: *mut GpPathGradient,
        color: *const ARGB,
        count: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientPath(brush: *mut GpPathGradient, path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientPath(brush: *mut GpPathGradient, path: *const GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientCenterPoint(
        brush: *mut GpPathGradient,
        points: *mut GpPointF,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientCenterPointI(
        brush: *mut GpPathGradient,
        points: *mut GpPoint,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientCenterPoint(
        brush: *mut GpPathGradient,
        points: *const GpPointF,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientCenterPointI(
        brush: *mut GpPathGradient,
        points: *const GpPoint,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientRect(brush: *mut GpPathGradient, rect: *mut GpRectF) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientRectI(brush: *mut GpPathGradient, rect: *mut GpRect) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientPointCount(brush: *mut GpPathGradient, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientSurroundColorCount(
        brush: *mut GpPathGradient,
        count: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientGammaCorrection(
        brush: *mut GpPathGradient,
        useGammaCorrection: BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientGammaCorrection(
        brush: *mut GpPathGradient,
        useGammaCorrection: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientBlendCount(brush: *mut GpPathGradient, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientBlend(
        brush: *mut GpPathGradient,
        blend: *mut REAL,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientBlend(
        brush: *mut GpPathGradient,
        blend: *const REAL,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientPresetBlendCount(
        brush: *mut GpPathGradient,
        count: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientPresetBlend(
        brush: *mut GpPathGradient,
        blend: *mut ARGB,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientPresetBlend(
        brush: *mut GpPathGradient,
        blend: *const ARGB,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientSigmaBlend(
        brush: *mut GpPathGradient,
        focus: REAL,
        scale: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientLinearBlend(
        brush: *mut GpPathGradient,
        focus: REAL,
        scale: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientWrapMode(
        brush: *mut GpPathGradient,
        wrapmode: *mut GpWrapMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientWrapMode(
        brush: *mut GpPathGradient,
        wrapmode: GpWrapMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientTransform(
        brush: *mut GpPathGradient,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientTransform(
        brush: *mut GpPathGradient,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipResetPathGradientTransform(brush: *mut GpPathGradient) -> GpStatus;
}
extern "C" {
    pub fn GdipMultiplyPathGradientTransform(
        brush: *mut GpPathGradient,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslatePathGradientTransform(
        brush: *mut GpPathGradient,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipScalePathGradientTransform(
        brush: *mut GpPathGradient,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRotatePathGradientTransform(
        brush: *mut GpPathGradient,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPathGradientFocusScales(
        brush: *mut GpPathGradient,
        xScale: *mut REAL,
        yScale: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPathGradientFocusScales(
        brush: *mut GpPathGradient,
        xScale: REAL,
        yScale: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePen1(color: ARGB, width: REAL, unit: GpUnit, pen: *mut *mut GpPen)
        -> GpStatus;
}
extern "C" {
    pub fn GdipCreatePen2(
        brush: *mut GpBrush,
        width: REAL,
        unit: GpUnit,
        pen: *mut *mut GpPen,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipClonePen(pen: *mut GpPen, clonepen: *mut *mut GpPen) -> GpStatus;
}
extern "C" {
    pub fn GdipDeletePen(pen: *mut GpPen) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenWidth(pen: *mut GpPen, width: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenWidth(pen: *mut GpPen, width: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenUnit(pen: *mut GpPen, unit: GpUnit) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenUnit(pen: *mut GpPen, unit: *mut GpUnit) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenLineCap197819(
        pen: *mut GpPen,
        startCap: GpLineCap,
        endCap: GpLineCap,
        dashCap: GpDashCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenStartCap(pen: *mut GpPen, startCap: GpLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenEndCap(pen: *mut GpPen, endCap: GpLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenDashCap197819(pen: *mut GpPen, dashCap: GpDashCap) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenStartCap(pen: *mut GpPen, startCap: *mut GpLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenEndCap(pen: *mut GpPen, endCap: *mut GpLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenDashCap197819(pen: *mut GpPen, dashCap: *mut GpDashCap) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenLineJoin(pen: *mut GpPen, lineJoin: GpLineJoin) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenLineJoin(pen: *mut GpPen, lineJoin: *mut GpLineJoin) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenCustomStartCap(pen: *mut GpPen, customCap: *mut GpCustomLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenCustomStartCap(
        pen: *mut GpPen,
        customCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenCustomEndCap(pen: *mut GpPen, customCap: *mut GpCustomLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenCustomEndCap(
        pen: *mut GpPen,
        customCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenMiterLimit(pen: *mut GpPen, miterLimit: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenMiterLimit(pen: *mut GpPen, miterLimit: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenMode(pen: *mut GpPen, penMode: GpPenAlignment) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenMode(pen: *mut GpPen, penMode: *mut GpPenAlignment) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenTransform(pen: *mut GpPen, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenTransform(pen: *mut GpPen, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipResetPenTransform(pen: *mut GpPen) -> GpStatus;
}
extern "C" {
    pub fn GdipMultiplyPenTransform(
        pen: *mut GpPen,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslatePenTransform(
        pen: *mut GpPen,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipScalePenTransform(
        pen: *mut GpPen,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRotatePenTransform(pen: *mut GpPen, angle: REAL, order: GpMatrixOrder) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenColor(pen: *mut GpPen, argb: ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenColor(pen: *mut GpPen, argb: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenBrushFill(pen: *mut GpPen, brush: *mut GpBrush) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenBrushFill(pen: *mut GpPen, brush: *mut *mut GpBrush) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenFillType(pen: *mut GpPen, type_: *mut GpPenType) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenDashStyle(pen: *mut GpPen, dashstyle: *mut GpDashStyle) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenDashStyle(pen: *mut GpPen, dashstyle: GpDashStyle) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenDashOffset(pen: *mut GpPen, offset: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenDashOffset(pen: *mut GpPen, offset: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenDashCount(pen: *mut GpPen, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenDashArray(pen: *mut GpPen, dash: *const REAL, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenDashArray(pen: *mut GpPen, dash: *mut REAL, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenCompoundCount(pen: *mut GpPen, count: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPenCompoundArray(pen: *mut GpPen, dash: *const REAL, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPenCompoundArray(pen: *mut GpPen, dash: *mut REAL, count: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateCustomLineCap(
        fillPath: *mut GpPath,
        strokePath: *mut GpPath,
        baseCap: GpLineCap,
        baseInset: REAL,
        customCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteCustomLineCap(customCap: *mut GpCustomLineCap) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneCustomLineCap(
        customCap: *mut GpCustomLineCap,
        clonedCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCustomLineCapType(
        customCap: *mut GpCustomLineCap,
        capType: *mut CustomLineCapType,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCustomLineCapStrokeCaps(
        customCap: *mut GpCustomLineCap,
        startCap: GpLineCap,
        endCap: GpLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCustomLineCapStrokeCaps(
        customCap: *mut GpCustomLineCap,
        startCap: *mut GpLineCap,
        endCap: *mut GpLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCustomLineCapStrokeJoin(
        customCap: *mut GpCustomLineCap,
        lineJoin: GpLineJoin,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCustomLineCapStrokeJoin(
        customCap: *mut GpCustomLineCap,
        lineJoin: *mut GpLineJoin,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCustomLineCapBaseCap(
        customCap: *mut GpCustomLineCap,
        baseCap: GpLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCustomLineCapBaseCap(
        customCap: *mut GpCustomLineCap,
        baseCap: *mut GpLineCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCustomLineCapBaseInset(customCap: *mut GpCustomLineCap, inset: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCustomLineCapBaseInset(
        customCap: *mut GpCustomLineCap,
        inset: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCustomLineCapWidthScale(
        customCap: *mut GpCustomLineCap,
        widthScale: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCustomLineCapWidthScale(
        customCap: *mut GpCustomLineCap,
        widthScale: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateAdjustableArrowCap(
        height: REAL,
        width: REAL,
        isFilled: BOOL,
        cap: *mut *mut GpAdjustableArrowCap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetAdjustableArrowCapHeight(
        cap: *mut GpAdjustableArrowCap,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetAdjustableArrowCapHeight(
        cap: *mut GpAdjustableArrowCap,
        height: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetAdjustableArrowCapWidth(cap: *mut GpAdjustableArrowCap, width: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetAdjustableArrowCapWidth(
        cap: *mut GpAdjustableArrowCap,
        width: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetAdjustableArrowCapMiddleInset(
        cap: *mut GpAdjustableArrowCap,
        middleInset: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetAdjustableArrowCapMiddleInset(
        cap: *mut GpAdjustableArrowCap,
        middleInset: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetAdjustableArrowCapFillState(
        cap: *mut GpAdjustableArrowCap,
        fillState: BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetAdjustableArrowCapFillState(
        cap: *mut GpAdjustableArrowCap,
        fillState: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipLoadImageFromStream(stream: *mut IStream, image: *mut *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipLoadImageFromFile(filename: *const WCHAR, image: *mut *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipLoadImageFromStreamICM(stream: *mut IStream, image: *mut *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipLoadImageFromFileICM(filename: *const WCHAR, image: *mut *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneImage(image: *mut GpImage, cloneImage: *mut *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipDisposeImage(image: *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipSaveImageToFile(
        image: *mut GpImage,
        filename: *const WCHAR,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSaveImageToStream(
        image: *mut GpImage,
        stream: *mut IStream,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSaveAdd(image: *mut GpImage, encoderParams: *const EncoderParameters) -> GpStatus;
}
extern "C" {
    pub fn GdipSaveAddImage(
        image: *mut GpImage,
        newImage: *mut GpImage,
        encoderParams: *const EncoderParameters,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageGraphicsContext(
        image: *mut GpImage,
        graphics: *mut *mut GpGraphics,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageBounds(
        image: *mut GpImage,
        srcRect: *mut GpRectF,
        srcUnit: *mut GpUnit,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageDimension(
        image: *mut GpImage,
        width: *mut REAL,
        height: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageType(image: *mut GpImage, type_: *mut ImageType) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageWidth(image: *mut GpImage, width: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageHeight(image: *mut GpImage, height: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageHorizontalResolution(image: *mut GpImage, resolution: *mut REAL)
        -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageVerticalResolution(image: *mut GpImage, resolution: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageFlags(image: *mut GpImage, flags: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageRawFormat(image: *mut GpImage, format: *mut GUID) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImagePixelFormat(image: *mut GpImage, format: *mut PixelFormat) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageThumbnail(
        image: *mut GpImage,
        thumbWidth: UINT,
        thumbHeight: UINT,
        thumbImage: *mut *mut GpImage,
        callback: GetThumbnailImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetEncoderParameterListSize(
        image: *mut GpImage,
        clsidEncoder: *const CLSID,
        size: *mut UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetEncoderParameterList(
        image: *mut GpImage,
        clsidEncoder: *const CLSID,
        size: UINT,
        buffer: *mut EncoderParameters,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipImageGetFrameDimensionsCount(image: *mut GpImage, count: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipImageGetFrameDimensionsList(
        image: *mut GpImage,
        dimensionIDs: *mut GUID,
        count: UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipImageGetFrameCount(
        image: *mut GpImage,
        dimensionID: *const GUID,
        count: *mut UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipImageSelectActiveFrame(
        image: *mut GpImage,
        dimensionID: *const GUID,
        frameIndex: UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipImageRotateFlip(image: *mut GpImage, rfType: RotateFlipType) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImagePalette(
        image: *mut GpImage,
        palette: *mut ColorPalette,
        size: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImagePalette(image: *mut GpImage, palette: *const ColorPalette) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImagePaletteSize(image: *mut GpImage, size: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPropertyCount(image: *mut GpImage, numOfProperty: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPropertyIdList(
        image: *mut GpImage,
        numOfProperty: UINT,
        list: *mut PROPID,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPropertyItemSize(
        image: *mut GpImage,
        propId: PROPID,
        size: *mut UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPropertyItem(
        image: *mut GpImage,
        propId: PROPID,
        propSize: UINT,
        buffer: *mut PropertyItem,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPropertySize(
        image: *mut GpImage,
        totalBufferSize: *mut UINT,
        numProperties: *mut UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetAllPropertyItems(
        image: *mut GpImage,
        totalBufferSize: UINT,
        numProperties: UINT,
        allItems: *mut PropertyItem,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRemovePropertyItem(image: *mut GpImage, propId: PROPID) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPropertyItem(image: *mut GpImage, item: *const PropertyItem) -> GpStatus;
}
extern "C" {
    pub fn GdipImageForceValidation(image: *mut GpImage) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromStream(stream: *mut IStream, bitmap: *mut *mut GpBitmap)
        -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromFile(filename: *const WCHAR, bitmap: *mut *mut GpBitmap)
        -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromStreamICM(
        stream: *mut IStream,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromFileICM(
        filename: *const WCHAR,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromScan0(
        width: INT,
        height: INT,
        stride: INT,
        format: PixelFormat,
        scan0: *mut BYTE,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromGraphics(
        width: INT,
        height: INT,
        target: *mut GpGraphics,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromDirectDrawSurface(
        surface: *mut IDirectDrawSurface7,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromGdiDib(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromHBITMAP(
        hbm: HBITMAP,
        hpal: HPALETTE,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateHBITMAPFromBitmap(
        bitmap: *mut GpBitmap,
        hbmReturn: *mut HBITMAP,
        background: ARGB,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromHICON(hicon: HICON, bitmap: *mut *mut GpBitmap) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateHICONFromBitmap(bitmap: *mut GpBitmap, hbmReturn: *mut HICON) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateBitmapFromResource(
        hInstance: HINSTANCE,
        lpBitmapName: *const WCHAR,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneBitmapArea(
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        format: PixelFormat,
        srcBitmap: *mut GpBitmap,
        dstBitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneBitmapAreaI(
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        format: PixelFormat,
        srcBitmap: *mut GpBitmap,
        dstBitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipBitmapLockBits(
        bitmap: *mut GpBitmap,
        rect: *const GpRect,
        flags: UINT,
        format: PixelFormat,
        lockedBitmapData: *mut BitmapData,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipBitmapUnlockBits(
        bitmap: *mut GpBitmap,
        lockedBitmapData: *mut BitmapData,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipBitmapGetPixel(bitmap: *mut GpBitmap, x: INT, y: INT, color: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipBitmapSetPixel(bitmap: *mut GpBitmap, x: INT, y: INT, color: ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipBitmapSetResolution(bitmap: *mut GpBitmap, xdpi: REAL, ydpi: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateImageAttributes(imageattr: *mut *mut GpImageAttributes) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneImageAttributes(
        imageattr: *const GpImageAttributes,
        cloneImageattr: *mut *mut GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDisposeImageAttributes(imageattr: *mut GpImageAttributes) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesToIdentity(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipResetImageAttributes(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesColorMatrix(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        colorMatrix: *const ColorMatrix,
        grayMatrix: *const ColorMatrix,
        flags: ColorMatrixFlags,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesThreshold(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        threshold: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesGamma(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        gamma: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesNoOp(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesColorKeys(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        colorLow: ARGB,
        colorHigh: ARGB,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesOutputChannel(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        channelFlags: ColorChannelFlags,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesOutputChannelColorProfile(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        colorProfileFilename: *const WCHAR,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesRemapTable(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        mapSize: UINT,
        map: *const ColorMap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesWrapMode(
        imageAttr: *mut GpImageAttributes,
        wrap: WrapMode,
        argb: ARGB,
        clamp: BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetImageAttributesICMMode(imageAttr: *mut GpImageAttributes, on: BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageAttributesAdjustedPalette(
        imageAttr: *mut GpImageAttributes,
        colorPalette: *mut ColorPalette,
        colorAdjustType: ColorAdjustType,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFlush(graphics: *mut GpGraphics, intention: GpFlushIntention) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFromHDC(hdc: HDC, graphics: *mut *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFromHDC2(
        hdc: HDC,
        hDevice: HANDLE,
        graphics: *mut *mut GpGraphics,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFromHWND(hwnd: HWND, graphics: *mut *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFromHWNDICM(hwnd: HWND, graphics: *mut *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteGraphics(graphics: *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipGetDC(graphics: *mut GpGraphics, hdc: *mut HDC) -> GpStatus;
}
extern "C" {
    pub fn GdipReleaseDC(graphics: *mut GpGraphics, hdc: HDC) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCompositingMode(
        graphics: *mut GpGraphics,
        compositingMode: CompositingMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCompositingMode(
        graphics: *mut GpGraphics,
        compositingMode: *mut CompositingMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetRenderingOrigin(graphics: *mut GpGraphics, x: INT, y: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetRenderingOrigin(graphics: *mut GpGraphics, x: *mut INT, y: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipSetCompositingQuality(
        graphics: *mut GpGraphics,
        compositingQuality: CompositingQuality,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCompositingQuality(
        graphics: *mut GpGraphics,
        compositingQuality: *mut CompositingQuality,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetSmoothingMode(
        graphics: *mut GpGraphics,
        smoothingMode: SmoothingMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetSmoothingMode(
        graphics: *mut GpGraphics,
        smoothingMode: *mut SmoothingMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPixelOffsetMode(
        graphics: *mut GpGraphics,
        pixelOffsetMode: PixelOffsetMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPixelOffsetMode(
        graphics: *mut GpGraphics,
        pixelOffsetMode: *mut PixelOffsetMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetTextRenderingHint(graphics: *mut GpGraphics, mode: TextRenderingHint)
        -> GpStatus;
}
extern "C" {
    pub fn GdipGetTextRenderingHint(
        graphics: *mut GpGraphics,
        mode: *mut TextRenderingHint,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetTextContrast(graphics: *mut GpGraphics, contrast: UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetTextContrast(graphics: *mut GpGraphics, contrast: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipSetInterpolationMode(
        graphics: *mut GpGraphics,
        interpolationMode: InterpolationMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetInterpolationMode(
        graphics: *mut GpGraphics,
        interpolationMode: *mut InterpolationMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetWorldTransform(graphics: *mut GpGraphics, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipResetWorldTransform(graphics: *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipMultiplyWorldTransform(
        graphics: *mut GpGraphics,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateWorldTransform(
        graphics: *mut GpGraphics,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipScaleWorldTransform(
        graphics: *mut GpGraphics,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRotateWorldTransform(
        graphics: *mut GpGraphics,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetWorldTransform(graphics: *mut GpGraphics, matrix: *mut GpMatrix) -> GpStatus;
}
extern "C" {
    pub fn GdipResetPageTransform(graphics: *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPageUnit(graphics: *mut GpGraphics, unit: *mut GpUnit) -> GpStatus;
}
extern "C" {
    pub fn GdipGetPageScale(graphics: *mut GpGraphics, scale: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPageUnit(graphics: *mut GpGraphics, unit: GpUnit) -> GpStatus;
}
extern "C" {
    pub fn GdipSetPageScale(graphics: *mut GpGraphics, scale: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetDpiX(graphics: *mut GpGraphics, dpi: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetDpiY(graphics: *mut GpGraphics, dpi: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipTransformPoints(
        graphics: *mut GpGraphics,
        destSpace: GpCoordinateSpace,
        srcSpace: GpCoordinateSpace,
        points: *mut GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTransformPointsI(
        graphics: *mut GpGraphics,
        destSpace: GpCoordinateSpace,
        srcSpace: GpCoordinateSpace,
        points: *mut GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetNearestColor(graphics: *mut GpGraphics, argb: *mut ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateHalftonePalette() -> HPALETTE;
}
extern "C" {
    pub fn GdipDrawLine(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: REAL,
        y1: REAL,
        x2: REAL,
        y2: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawLineI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: INT,
        y1: INT,
        x2: INT,
        y2: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawLines(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawLinesI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawArc(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawArcI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawBezier(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: REAL,
        y1: REAL,
        x2: REAL,
        y2: REAL,
        x3: REAL,
        y3: REAL,
        x4: REAL,
        y4: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawBezierI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: INT,
        y1: INT,
        x2: INT,
        y2: INT,
        x3: INT,
        y3: INT,
        x4: INT,
        y4: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawBeziers(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawBeziersI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawRectangle(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawRectangleI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawRectangles(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        rects: *const GpRectF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawRectanglesI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        rects: *const GpRect,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawEllipse(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawEllipseI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawPie(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawPieI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawPolygon(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawPolygonI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawPath(graphics: *mut GpGraphics, pen: *mut GpPen, path: *mut GpPath) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCurve(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCurveI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCurve2(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCurve2I(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCurve3(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCurve3I(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawClosedCurve(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawClosedCurveI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawClosedCurve2(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawClosedCurve2I(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGraphicsClear(graphics: *mut GpGraphics, color: ARGB) -> GpStatus;
}
extern "C" {
    pub fn GdipFillRectangle(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillRectangleI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillRectangles(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        rects: *const GpRectF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillRectanglesI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        rects: *const GpRect,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPolygon(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPolygonI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPolygon2(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPolygon2I(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillEllipse(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillEllipseI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPie(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPieI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillPath(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        path: *mut GpPath,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillClosedCurve(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillClosedCurveI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillClosedCurve2(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillClosedCurve2I(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFillRegion(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        region: *mut GpRegion,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImage(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: REAL,
        y: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImageI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: INT,
        y: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImageRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImageRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImagePoints(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstpoints: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImagePointsI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstpoints: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImagePointRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: REAL,
        y: REAL,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        srcUnit: GpUnit,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImagePointRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: INT,
        y: INT,
        srcx: INT,
        srcy: INT,
        srcwidth: INT,
        srcheight: INT,
        srcUnit: GpUnit,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImageRectRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstx: REAL,
        dsty: REAL,
        dstwidth: REAL,
        dstheight: REAL,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImageRectRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstx: INT,
        dsty: INT,
        dstwidth: INT,
        dstheight: INT,
        srcx: INT,
        srcy: INT,
        srcwidth: INT,
        srcheight: INT,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImagePointsRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        points: *const GpPointF,
        count: INT,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawImagePointsRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        points: *const GpPoint,
        count: INT,
        srcx: INT,
        srcy: INT,
        srcwidth: INT,
        srcheight: INT,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileDestPoint(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const PointF,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileDestPointI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const Point,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileDestRect(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const RectF,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileDestRectI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const Rect,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileDestPoints(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const PointF,
        count: INT,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileDestPointsI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const Point,
        count: INT,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileSrcRectDestPoint(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const PointF,
        srcRect: *const RectF,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileSrcRectDestPointI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const Point,
        srcRect: *const Rect,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileSrcRectDestRect(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const RectF,
        srcRect: *const RectF,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileSrcRectDestRectI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const Rect,
        srcRect: *const Rect,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileSrcRectDestPoints(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const PointF,
        count: INT,
        srcRect: *const RectF,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEnumerateMetafileSrcRectDestPointsI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const Point,
        count: INT,
        srcRect: *const Rect,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPlayMetafileRecord(
        metafile: *const GpMetafile,
        recordType: EmfPlusRecordType,
        flags: UINT,
        dataSize: UINT,
        data: *const BYTE,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetClipGraphics(
        graphics: *mut GpGraphics,
        srcgraphics: *mut GpGraphics,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetClipRect(
        graphics: *mut GpGraphics,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetClipRectI(
        graphics: *mut GpGraphics,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetClipPath(
        graphics: *mut GpGraphics,
        path: *mut GpPath,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetClipRegion(
        graphics: *mut GpGraphics,
        region: *mut GpRegion,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetClipHrgn(
        graphics: *mut GpGraphics,
        hRgn: HRGN,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipResetClip(graphics: *mut GpGraphics) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateClip(graphics: *mut GpGraphics, dx: REAL, dy: REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipTranslateClipI(graphics: *mut GpGraphics, dx: INT, dy: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetClip(graphics: *mut GpGraphics, region: *mut GpRegion) -> GpStatus;
}
extern "C" {
    pub fn GdipGetClipBounds(graphics: *mut GpGraphics, rect: *mut GpRectF) -> GpStatus;
}
extern "C" {
    pub fn GdipGetClipBoundsI(graphics: *mut GpGraphics, rect: *mut GpRect) -> GpStatus;
}
extern "C" {
    pub fn GdipIsClipEmpty(graphics: *mut GpGraphics, result: *mut BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetVisibleClipBounds(graphics: *mut GpGraphics, rect: *mut GpRectF) -> GpStatus;
}
extern "C" {
    pub fn GdipGetVisibleClipBoundsI(graphics: *mut GpGraphics, rect: *mut GpRect) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleClipEmpty(graphics: *mut GpGraphics, result: *mut BOOL) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisiblePoint(
        graphics: *mut GpGraphics,
        x: REAL,
        y: REAL,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisiblePointI(
        graphics: *mut GpGraphics,
        x: INT,
        y: INT,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleRect(
        graphics: *mut GpGraphics,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsVisibleRectI(
        graphics: *mut GpGraphics,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSaveGraphics(graphics: *mut GpGraphics, state: *mut GraphicsState) -> GpStatus;
}
extern "C" {
    pub fn GdipRestoreGraphics(graphics: *mut GpGraphics, state: GraphicsState) -> GpStatus;
}
extern "C" {
    pub fn GdipBeginContainer(
        graphics: *mut GpGraphics,
        dstrect: *const GpRectF,
        srcrect: *const GpRectF,
        unit: GpUnit,
        state: *mut GraphicsContainer,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipBeginContainerI(
        graphics: *mut GpGraphics,
        dstrect: *const GpRect,
        srcrect: *const GpRect,
        unit: GpUnit,
        state: *mut GraphicsContainer,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipBeginContainer2(
        graphics: *mut GpGraphics,
        state: *mut GraphicsContainer,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEndContainer(graphics: *mut GpGraphics, state: GraphicsContainer) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileHeaderFromWmf(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileHeaderFromEmf(
        hEmf: HENHMETAFILE,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileHeaderFromFile(
        filename: *const WCHAR,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileHeaderFromStream(
        stream: *mut IStream,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileHeaderFromMetafile(
        metafile: *mut GpMetafile,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetHemfFromMetafile(metafile: *mut GpMetafile, hEmf: *mut HENHMETAFILE) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateStreamOnFile(
        filename: *const WCHAR,
        access: UINT,
        stream: *mut *mut IStream,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMetafileFromWmf(
        hWmf: HMETAFILE,
        deleteWmf: BOOL,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMetafileFromEmf(
        hEmf: HENHMETAFILE,
        deleteEmf: BOOL,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMetafileFromFile(
        file: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMetafileFromWmfFile(
        file: *const WCHAR,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateMetafileFromStream(
        stream: *mut IStream,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRecordMetafile(
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRectF,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRecordMetafileI(
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRect,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRecordMetafileFileName(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRectF,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRecordMetafileFileNameI(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRect,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRecordMetafileStream(
        stream: *mut IStream,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRectF,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipRecordMetafileStreamI(
        stream: *mut IStream,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRect,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetMetafileDownLevelRasterizationLimit(
        metafile: *mut GpMetafile,
        metafileRasterizationLimitDpi: UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileDownLevelRasterizationLimit(
        metafile: *const GpMetafile,
        metafileRasterizationLimitDpi: *mut UINT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageDecodersSize(numDecoders: *mut UINT, size: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageDecoders(
        numDecoders: UINT,
        size: UINT,
        decoders: *mut ImageCodecInfo,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageEncodersSize(numEncoders: *mut UINT, size: *mut UINT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetImageEncoders(
        numEncoders: UINT,
        size: UINT,
        encoders: *mut ImageCodecInfo,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipComment(graphics: *mut GpGraphics, sizeData: UINT, data: *const BYTE) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFontFamilyFromName(
        name: *const WCHAR,
        fontCollection: *mut GpFontCollection,
        fontFamily: *mut *mut GpFontFamily,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteFontFamily(fontFamily: *mut GpFontFamily) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneFontFamily(
        fontFamily: *mut GpFontFamily,
        clonedFontFamily: *mut *mut GpFontFamily,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetGenericFontFamilySansSerif(nativeFamily: *mut *mut GpFontFamily) -> GpStatus;
}
extern "C" {
    pub fn GdipGetGenericFontFamilySerif(nativeFamily: *mut *mut GpFontFamily) -> GpStatus;
}
extern "C" {
    pub fn GdipGetGenericFontFamilyMonospace(nativeFamily: *mut *mut GpFontFamily) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFamilyName(
        family: *const GpFontFamily,
        name: LPWSTR,
        language: LANGID,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipIsStyleAvailable(
        family: *const GpFontFamily,
        style: INT,
        IsStyleAvailable: *mut BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFontCollectionEnumerable(
        fontCollection: *mut GpFontCollection,
        graphics: *mut GpGraphics,
        numFound: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipFontCollectionEnumerate(
        fontCollection: *mut GpFontCollection,
        numSought: INT,
        gpfamilies: *mut *mut GpFontFamily,
        numFound: *mut INT,
        graphics: *mut GpGraphics,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetEmHeight(
        family: *const GpFontFamily,
        style: INT,
        EmHeight: *mut UINT16,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCellAscent(
        family: *const GpFontFamily,
        style: INT,
        CellAscent: *mut UINT16,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetCellDescent(
        family: *const GpFontFamily,
        style: INT,
        CellDescent: *mut UINT16,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLineSpacing(
        family: *const GpFontFamily,
        style: INT,
        LineSpacing: *mut UINT16,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFontFromDC(hdc: HDC, font: *mut *mut GpFont) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFontFromLogfontA(
        hdc: HDC,
        logfont: *const LOGFONTA,
        font: *mut *mut GpFont,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFontFromLogfontW(
        hdc: HDC,
        logfont: *const LOGFONTW,
        font: *mut *mut GpFont,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateFont(
        fontFamily: *const GpFontFamily,
        emSize: REAL,
        style: INT,
        unit: Unit,
        font: *mut *mut GpFont,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneFont(font: *mut GpFont, cloneFont: *mut *mut GpFont) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteFont(font: *mut GpFont) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFamily(font: *mut GpFont, family: *mut *mut GpFontFamily) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontStyle(font: *mut GpFont, style: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontSize(font: *mut GpFont, size: *mut REAL) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontUnit(font: *mut GpFont, unit: *mut Unit) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontHeight(
        font: *const GpFont,
        graphics: *const GpGraphics,
        height: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontHeightGivenDPI(font: *const GpFont, dpi: REAL, height: *mut REAL)
        -> GpStatus;
}
extern "C" {
    pub fn GdipGetLogFontA(
        font: *mut GpFont,
        graphics: *mut GpGraphics,
        logfontA: *mut LOGFONTA,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetLogFontW(
        font: *mut GpFont,
        graphics: *mut GpGraphics,
        logfontW: *mut LOGFONTW,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipNewInstalledFontCollection(fontCollection: *mut *mut GpFontCollection) -> GpStatus;
}
extern "C" {
    pub fn GdipNewPrivateFontCollection(fontCollection: *mut *mut GpFontCollection) -> GpStatus;
}
extern "C" {
    pub fn GdipDeletePrivateFontCollection(fontCollection: *mut *mut GpFontCollection) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontCollectionFamilyCount(
        fontCollection: *mut GpFontCollection,
        numFound: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetFontCollectionFamilyList(
        fontCollection: *mut GpFontCollection,
        numSought: INT,
        gpfamilies: *mut *mut GpFontFamily,
        numFound: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPrivateAddFontFile(
        fontCollection: *mut GpFontCollection,
        filename: *const WCHAR,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipPrivateAddMemoryFont(
        fontCollection: *mut GpFontCollection,
        memory: *const ::core::ffi::c_void,
        length: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawString(
        graphics: *mut GpGraphics,
        string: *const WCHAR,
        length: INT,
        font: *const GpFont,
        layoutRect: *const RectF,
        stringFormat: *const GpStringFormat,
        brush: *const GpBrush,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipMeasureString(
        graphics: *mut GpGraphics,
        string: *const WCHAR,
        length: INT,
        font: *const GpFont,
        layoutRect: *const RectF,
        stringFormat: *const GpStringFormat,
        boundingBox: *mut RectF,
        codepointsFitted: *mut INT,
        linesFilled: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipMeasureCharacterRanges(
        graphics: *mut GpGraphics,
        string: *const WCHAR,
        length: INT,
        font: *const GpFont,
        layoutRect: *const RectF,
        stringFormat: *const GpStringFormat,
        regionCount: INT,
        regions: *mut *mut GpRegion,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawDriverString(
        graphics: *mut GpGraphics,
        text: *const UINT16,
        length: INT,
        font: *const GpFont,
        brush: *const GpBrush,
        positions: *const PointF,
        flags: INT,
        matrix: *const GpMatrix,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipMeasureDriverString(
        graphics: *mut GpGraphics,
        text: *const UINT16,
        length: INT,
        font: *const GpFont,
        positions: *const PointF,
        flags: INT,
        matrix: *const GpMatrix,
        boundingBox: *mut RectF,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateStringFormat(
        formatAttributes: INT,
        language: LANGID,
        format: *mut *mut GpStringFormat,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipStringFormatGetGenericDefault(format: *mut *mut GpStringFormat) -> GpStatus;
}
extern "C" {
    pub fn GdipStringFormatGetGenericTypographic(format: *mut *mut GpStringFormat) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteStringFormat(format: *mut GpStringFormat) -> GpStatus;
}
extern "C" {
    pub fn GdipCloneStringFormat(
        format: *const GpStringFormat,
        newFormat: *mut *mut GpStringFormat,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatFlags(format: *mut GpStringFormat, flags: INT) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatFlags(format: *const GpStringFormat, flags: *mut INT) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatAlign(
        format: *mut GpStringFormat,
        align: StringAlignment,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatAlign(
        format: *const GpStringFormat,
        align: *mut StringAlignment,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatLineAlign(
        format: *mut GpStringFormat,
        align: StringAlignment,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatLineAlign(
        format: *const GpStringFormat,
        align: *mut StringAlignment,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatTrimming(
        format: *mut GpStringFormat,
        trimming: StringTrimming,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatTrimming(
        format: *const GpStringFormat,
        trimming: *mut StringTrimming,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatHotkeyPrefix(
        format: *mut GpStringFormat,
        hotkeyPrefix: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatHotkeyPrefix(
        format: *const GpStringFormat,
        hotkeyPrefix: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatTabStops(
        format: *mut GpStringFormat,
        firstTabOffset: REAL,
        count: INT,
        tabStops: *const REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatTabStops(
        format: *const GpStringFormat,
        count: INT,
        firstTabOffset: *mut REAL,
        tabStops: *mut REAL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatTabStopCount(
        format: *const GpStringFormat,
        count: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatDigitSubstitution(
        format: *mut GpStringFormat,
        language: LANGID,
        substitute: StringDigitSubstitute,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatDigitSubstitution(
        format: *const GpStringFormat,
        language: *mut LANGID,
        substitute: *mut StringDigitSubstitute,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipGetStringFormatMeasurableCharacterRangeCount(
        format: *const GpStringFormat,
        count: *mut INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipSetStringFormatMeasurableCharacterRanges(
        format: *mut GpStringFormat,
        rangeCount: INT,
        ranges: *const CharacterRange,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipCreateCachedBitmap(
        bitmap: *mut GpBitmap,
        graphics: *mut GpGraphics,
        cachedBitmap: *mut *mut GpCachedBitmap,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipDeleteCachedBitmap(cachedBitmap: *mut GpCachedBitmap) -> GpStatus;
}
extern "C" {
    pub fn GdipDrawCachedBitmap(
        graphics: *mut GpGraphics,
        cachedBitmap: *mut GpCachedBitmap,
        x: INT,
        y: INT,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipEmfToWmfBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        eFlags: INT,
    ) -> UINT;
}
extern "C" {
    pub fn GdipSetImageAttributesCachedBackground(
        imageattr: *mut GpImageAttributes,
        enableFlag: BOOL,
    ) -> GpStatus;
}
extern "C" {
    pub fn GdipTestControl(control: GpTestControlEnum, param: *mut ::core::ffi::c_void)
        -> GpStatus;
}
extern "C" {
    pub fn GdiplusNotificationHook(token: *mut ULONG_PTR) -> GpStatus;
}
extern "C" {
    pub fn GdiplusNotificationUnhook(token: ULONG_PTR);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GdiplusBase {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GdiplusBase() {
    assert_eq!(
        ::core::mem::size_of::<GdiplusBase>(),
        1usize,
        concat!("Size of: ", stringify!(GdiplusBase))
    );
    assert_eq!(
        ::core::mem::align_of::<GdiplusBase>(),
        1usize,
        concat!("Alignment of ", stringify!(GdiplusBase))
    );
}
pub type GraphicsState = UINT;
pub type GraphicsContainer = UINT;
pub const FillMode_FillModeAlternate: FillMode = 0;
pub const FillMode_FillModeWinding: FillMode = 1;
pub type FillMode = ::core::ffi::c_int;
pub const CompositingMode_CompositingModeSourceOver: CompositingMode = 0;
pub const CompositingMode_CompositingModeSourceCopy: CompositingMode = 1;
pub type CompositingMode = ::core::ffi::c_int;
pub const CompositingQuality_CompositingQualityInvalid: CompositingQuality = -1;
pub const CompositingQuality_CompositingQualityDefault: CompositingQuality = 0;
pub const CompositingQuality_CompositingQualityHighSpeed: CompositingQuality = 1;
pub const CompositingQuality_CompositingQualityHighQuality: CompositingQuality = 2;
pub const CompositingQuality_CompositingQualityGammaCorrected: CompositingQuality = 3;
pub const CompositingQuality_CompositingQualityAssumeLinear: CompositingQuality = 4;
pub type CompositingQuality = ::core::ffi::c_int;
pub const Unit_UnitWorld: Unit = 0;
pub const Unit_UnitDisplay: Unit = 1;
pub const Unit_UnitPixel: Unit = 2;
pub const Unit_UnitPoint: Unit = 3;
pub const Unit_UnitInch: Unit = 4;
pub const Unit_UnitDocument: Unit = 5;
pub const Unit_UnitMillimeter: Unit = 6;
pub type Unit = ::core::ffi::c_int;
pub const MetafileFrameUnit_MetafileFrameUnitPixel: MetafileFrameUnit = 2;
pub const MetafileFrameUnit_MetafileFrameUnitPoint: MetafileFrameUnit = 3;
pub const MetafileFrameUnit_MetafileFrameUnitInch: MetafileFrameUnit = 4;
pub const MetafileFrameUnit_MetafileFrameUnitDocument: MetafileFrameUnit = 5;
pub const MetafileFrameUnit_MetafileFrameUnitMillimeter: MetafileFrameUnit = 6;
pub const MetafileFrameUnit_MetafileFrameUnitGdi: MetafileFrameUnit = 7;
pub type MetafileFrameUnit = ::core::ffi::c_int;
pub const CoordinateSpace_CoordinateSpaceWorld: CoordinateSpace = 0;
pub const CoordinateSpace_CoordinateSpacePage: CoordinateSpace = 1;
pub const CoordinateSpace_CoordinateSpaceDevice: CoordinateSpace = 2;
pub type CoordinateSpace = ::core::ffi::c_int;
pub const WrapMode_WrapModeTile: WrapMode = 0;
pub const WrapMode_WrapModeTileFlipX: WrapMode = 1;
pub const WrapMode_WrapModeTileFlipY: WrapMode = 2;
pub const WrapMode_WrapModeTileFlipXY: WrapMode = 3;
pub const WrapMode_WrapModeClamp: WrapMode = 4;
pub type WrapMode = ::core::ffi::c_int;
pub const HatchStyle_HatchStyleHorizontal: HatchStyle = 0;
pub const HatchStyle_HatchStyleVertical: HatchStyle = 1;
pub const HatchStyle_HatchStyleForwardDiagonal: HatchStyle = 2;
pub const HatchStyle_HatchStyleBackwardDiagonal: HatchStyle = 3;
pub const HatchStyle_HatchStyleCross: HatchStyle = 4;
pub const HatchStyle_HatchStyleDiagonalCross: HatchStyle = 5;
pub const HatchStyle_HatchStyle05Percent: HatchStyle = 6;
pub const HatchStyle_HatchStyle10Percent: HatchStyle = 7;
pub const HatchStyle_HatchStyle20Percent: HatchStyle = 8;
pub const HatchStyle_HatchStyle25Percent: HatchStyle = 9;
pub const HatchStyle_HatchStyle30Percent: HatchStyle = 10;
pub const HatchStyle_HatchStyle40Percent: HatchStyle = 11;
pub const HatchStyle_HatchStyle50Percent: HatchStyle = 12;
pub const HatchStyle_HatchStyle60Percent: HatchStyle = 13;
pub const HatchStyle_HatchStyle70Percent: HatchStyle = 14;
pub const HatchStyle_HatchStyle75Percent: HatchStyle = 15;
pub const HatchStyle_HatchStyle80Percent: HatchStyle = 16;
pub const HatchStyle_HatchStyle90Percent: HatchStyle = 17;
pub const HatchStyle_HatchStyleLightDownwardDiagonal: HatchStyle = 18;
pub const HatchStyle_HatchStyleLightUpwardDiagonal: HatchStyle = 19;
pub const HatchStyle_HatchStyleDarkDownwardDiagonal: HatchStyle = 20;
pub const HatchStyle_HatchStyleDarkUpwardDiagonal: HatchStyle = 21;
pub const HatchStyle_HatchStyleWideDownwardDiagonal: HatchStyle = 22;
pub const HatchStyle_HatchStyleWideUpwardDiagonal: HatchStyle = 23;
pub const HatchStyle_HatchStyleLightVertical: HatchStyle = 24;
pub const HatchStyle_HatchStyleLightHorizontal: HatchStyle = 25;
pub const HatchStyle_HatchStyleNarrowVertical: HatchStyle = 26;
pub const HatchStyle_HatchStyleNarrowHorizontal: HatchStyle = 27;
pub const HatchStyle_HatchStyleDarkVertical: HatchStyle = 28;
pub const HatchStyle_HatchStyleDarkHorizontal: HatchStyle = 29;
pub const HatchStyle_HatchStyleDashedDownwardDiagonal: HatchStyle = 30;
pub const HatchStyle_HatchStyleDashedUpwardDiagonal: HatchStyle = 31;
pub const HatchStyle_HatchStyleDashedHorizontal: HatchStyle = 32;
pub const HatchStyle_HatchStyleDashedVertical: HatchStyle = 33;
pub const HatchStyle_HatchStyleSmallConfetti: HatchStyle = 34;
pub const HatchStyle_HatchStyleLargeConfetti: HatchStyle = 35;
pub const HatchStyle_HatchStyleZigZag: HatchStyle = 36;
pub const HatchStyle_HatchStyleWave: HatchStyle = 37;
pub const HatchStyle_HatchStyleDiagonalBrick: HatchStyle = 38;
pub const HatchStyle_HatchStyleHorizontalBrick: HatchStyle = 39;
pub const HatchStyle_HatchStyleWeave: HatchStyle = 40;
pub const HatchStyle_HatchStylePlaid: HatchStyle = 41;
pub const HatchStyle_HatchStyleDivot: HatchStyle = 42;
pub const HatchStyle_HatchStyleDottedGrid: HatchStyle = 43;
pub const HatchStyle_HatchStyleDottedDiamond: HatchStyle = 44;
pub const HatchStyle_HatchStyleShingle: HatchStyle = 45;
pub const HatchStyle_HatchStyleTrellis: HatchStyle = 46;
pub const HatchStyle_HatchStyleSphere: HatchStyle = 47;
pub const HatchStyle_HatchStyleSmallGrid: HatchStyle = 48;
pub const HatchStyle_HatchStyleSmallCheckerBoard: HatchStyle = 49;
pub const HatchStyle_HatchStyleLargeCheckerBoard: HatchStyle = 50;
pub const HatchStyle_HatchStyleOutlinedDiamond: HatchStyle = 51;
pub const HatchStyle_HatchStyleSolidDiamond: HatchStyle = 52;
pub const HatchStyle_HatchStyleTotal: HatchStyle = 53;
pub const HatchStyle_HatchStyleLargeGrid: HatchStyle = 4;
pub const HatchStyle_HatchStyleMin: HatchStyle = 0;
pub const HatchStyle_HatchStyleMax: HatchStyle = 52;
pub type HatchStyle = ::core::ffi::c_int;
pub const DashStyle_DashStyleSolid: DashStyle = 0;
pub const DashStyle_DashStyleDash: DashStyle = 1;
pub const DashStyle_DashStyleDot: DashStyle = 2;
pub const DashStyle_DashStyleDashDot: DashStyle = 3;
pub const DashStyle_DashStyleDashDotDot: DashStyle = 4;
pub const DashStyle_DashStyleCustom: DashStyle = 5;
pub type DashStyle = ::core::ffi::c_int;
pub const DashCap_DashCapFlat: DashCap = 0;
pub const DashCap_DashCapRound: DashCap = 2;
pub const DashCap_DashCapTriangle: DashCap = 3;
pub type DashCap = ::core::ffi::c_int;
pub const LineCap_LineCapFlat: LineCap = 0;
pub const LineCap_LineCapSquare: LineCap = 1;
pub const LineCap_LineCapRound: LineCap = 2;
pub const LineCap_LineCapTriangle: LineCap = 3;
pub const LineCap_LineCapNoAnchor: LineCap = 16;
pub const LineCap_LineCapSquareAnchor: LineCap = 17;
pub const LineCap_LineCapRoundAnchor: LineCap = 18;
pub const LineCap_LineCapDiamondAnchor: LineCap = 19;
pub const LineCap_LineCapArrowAnchor: LineCap = 20;
pub const LineCap_LineCapCustom: LineCap = 255;
pub const LineCap_LineCapAnchorMask: LineCap = 240;
pub type LineCap = ::core::ffi::c_int;
pub const CustomLineCapType_CustomLineCapTypeDefault: CustomLineCapType = 0;
pub const CustomLineCapType_CustomLineCapTypeAdjustableArrow: CustomLineCapType = 1;
pub type CustomLineCapType = ::core::ffi::c_int;
pub const LineJoin_LineJoinMiter: LineJoin = 0;
pub const LineJoin_LineJoinBevel: LineJoin = 1;
pub const LineJoin_LineJoinRound: LineJoin = 2;
pub const LineJoin_LineJoinMiterClipped: LineJoin = 3;
pub type LineJoin = ::core::ffi::c_int;
pub const WarpMode_WarpModePerspective: WarpMode = 0;
pub const WarpMode_WarpModeBilinear: WarpMode = 1;
pub type WarpMode = ::core::ffi::c_int;
pub const LinearGradientMode_LinearGradientModeHorizontal: LinearGradientMode = 0;
pub const LinearGradientMode_LinearGradientModeVertical: LinearGradientMode = 1;
pub const LinearGradientMode_LinearGradientModeForwardDiagonal: LinearGradientMode = 2;
pub const LinearGradientMode_LinearGradientModeBackwardDiagonal: LinearGradientMode = 3;
pub type LinearGradientMode = ::core::ffi::c_int;
pub const CombineMode_CombineModeReplace: CombineMode = 0;
pub const CombineMode_CombineModeIntersect: CombineMode = 1;
pub const CombineMode_CombineModeUnion: CombineMode = 2;
pub const CombineMode_CombineModeXor: CombineMode = 3;
pub const CombineMode_CombineModeExclude: CombineMode = 4;
pub const CombineMode_CombineModeComplement: CombineMode = 5;
pub type CombineMode = ::core::ffi::c_int;
pub const ImageType_ImageTypeUnknown: ImageType = 0;
pub const ImageType_ImageTypeBitmap: ImageType = 1;
pub const ImageType_ImageTypeMetafile: ImageType = 2;
pub type ImageType = ::core::ffi::c_int;
pub const InterpolationMode_InterpolationModeInvalid: InterpolationMode = -1;
pub const InterpolationMode_InterpolationModeDefault: InterpolationMode = 0;
pub const InterpolationMode_InterpolationModeLowQuality: InterpolationMode = 1;
pub const InterpolationMode_InterpolationModeHighQuality: InterpolationMode = 2;
pub const InterpolationMode_InterpolationModeBilinear: InterpolationMode = 3;
pub const InterpolationMode_InterpolationModeBicubic: InterpolationMode = 4;
pub const InterpolationMode_InterpolationModeNearestNeighbor: InterpolationMode = 5;
pub const InterpolationMode_InterpolationModeHighQualityBilinear: InterpolationMode = 6;
pub const InterpolationMode_InterpolationModeHighQualityBicubic: InterpolationMode = 7;
pub type InterpolationMode = ::core::ffi::c_int;
pub const PenAlignment_PenAlignmentCenter: PenAlignment = 0;
pub const PenAlignment_PenAlignmentInset: PenAlignment = 1;
pub type PenAlignment = ::core::ffi::c_int;
pub const BrushType_BrushTypeSolidColor: BrushType = 0;
pub const BrushType_BrushTypeHatchFill: BrushType = 1;
pub const BrushType_BrushTypeTextureFill: BrushType = 2;
pub const BrushType_BrushTypePathGradient: BrushType = 3;
pub const BrushType_BrushTypeLinearGradient: BrushType = 4;
pub type BrushType = ::core::ffi::c_int;
pub const PenType_PenTypeSolidColor: PenType = 0;
pub const PenType_PenTypeHatchFill: PenType = 1;
pub const PenType_PenTypeTextureFill: PenType = 2;
pub const PenType_PenTypePathGradient: PenType = 3;
pub const PenType_PenTypeLinearGradient: PenType = 4;
pub const PenType_PenTypeUnknown: PenType = -1;
pub type PenType = ::core::ffi::c_int;
pub const MatrixOrder_MatrixOrderPrepend: MatrixOrder = 0;
pub const MatrixOrder_MatrixOrderAppend: MatrixOrder = 1;
pub type MatrixOrder = ::core::ffi::c_int;
pub const SmoothingMode_SmoothingModeInvalid: SmoothingMode = -1;
pub const SmoothingMode_SmoothingModeDefault: SmoothingMode = 0;
pub const SmoothingMode_SmoothingModeHighSpeed: SmoothingMode = 1;
pub const SmoothingMode_SmoothingModeHighQuality: SmoothingMode = 2;
pub const SmoothingMode_SmoothingModeNone: SmoothingMode = 3;
pub const SmoothingMode_SmoothingModeAntiAlias: SmoothingMode = 4;
pub type SmoothingMode = ::core::ffi::c_int;
pub const PixelOffsetMode_PixelOffsetModeInvalid: PixelOffsetMode = -1;
pub const PixelOffsetMode_PixelOffsetModeDefault: PixelOffsetMode = 0;
pub const PixelOffsetMode_PixelOffsetModeHighSpeed: PixelOffsetMode = 1;
pub const PixelOffsetMode_PixelOffsetModeHighQuality: PixelOffsetMode = 2;
pub const PixelOffsetMode_PixelOffsetModeNone: PixelOffsetMode = 3;
pub const PixelOffsetMode_PixelOffsetModeHalf: PixelOffsetMode = 4;
pub type PixelOffsetMode = ::core::ffi::c_int;
pub const TextRenderingHint_TextRenderingHintSystemDefault: TextRenderingHint = 0;
pub const TextRenderingHint_TextRenderingHintSingleBitPerPixelGridFit: TextRenderingHint = 1;
pub const TextRenderingHint_TextRenderingHintSingleBitPerPixel: TextRenderingHint = 2;
pub const TextRenderingHint_TextRenderingHintAntiAliasGridFit: TextRenderingHint = 3;
pub const TextRenderingHint_TextRenderingHintAntiAlias: TextRenderingHint = 4;
pub const TextRenderingHint_TextRenderingHintClearTypeGridFit: TextRenderingHint = 5;
pub type TextRenderingHint = ::core::ffi::c_int;
pub const MetafileType_MetafileTypeInvalid: MetafileType = 0;
pub const MetafileType_MetafileTypeWmf: MetafileType = 1;
pub const MetafileType_MetafileTypeWmfPlaceable: MetafileType = 2;
pub const MetafileType_MetafileTypeEmf: MetafileType = 3;
pub const MetafileType_MetafileTypeEmfPlusOnly: MetafileType = 4;
pub const MetafileType_MetafileTypeEmfPlusDual: MetafileType = 5;
pub type MetafileType = ::core::ffi::c_int;
pub const EmfType_EmfTypeEmfOnly: EmfType = 3;
pub const EmfType_EmfTypeEmfPlusOnly: EmfType = 4;
pub const EmfType_EmfTypeEmfPlusDual: EmfType = 5;
pub type EmfType = ::core::ffi::c_int;
pub const EmfPlusRecordType_WmfRecordTypeSetBkColor: EmfPlusRecordType = 66049;
pub const EmfPlusRecordType_WmfRecordTypeSetBkMode: EmfPlusRecordType = 65794;
pub const EmfPlusRecordType_WmfRecordTypeSetMapMode: EmfPlusRecordType = 65795;
pub const EmfPlusRecordType_WmfRecordTypeSetROP2: EmfPlusRecordType = 65796;
pub const EmfPlusRecordType_WmfRecordTypeSetRelAbs: EmfPlusRecordType = 65797;
pub const EmfPlusRecordType_WmfRecordTypeSetPolyFillMode: EmfPlusRecordType = 65798;
pub const EmfPlusRecordType_WmfRecordTypeSetStretchBltMode: EmfPlusRecordType = 65799;
pub const EmfPlusRecordType_WmfRecordTypeSetTextCharExtra: EmfPlusRecordType = 65800;
pub const EmfPlusRecordType_WmfRecordTypeSetTextColor: EmfPlusRecordType = 66057;
pub const EmfPlusRecordType_WmfRecordTypeSetTextJustification: EmfPlusRecordType = 66058;
pub const EmfPlusRecordType_WmfRecordTypeSetWindowOrg: EmfPlusRecordType = 66059;
pub const EmfPlusRecordType_WmfRecordTypeSetWindowExt: EmfPlusRecordType = 66060;
pub const EmfPlusRecordType_WmfRecordTypeSetViewportOrg: EmfPlusRecordType = 66061;
pub const EmfPlusRecordType_WmfRecordTypeSetViewportExt: EmfPlusRecordType = 66062;
pub const EmfPlusRecordType_WmfRecordTypeOffsetWindowOrg: EmfPlusRecordType = 66063;
pub const EmfPlusRecordType_WmfRecordTypeScaleWindowExt: EmfPlusRecordType = 66576;
pub const EmfPlusRecordType_WmfRecordTypeOffsetViewportOrg: EmfPlusRecordType = 66065;
pub const EmfPlusRecordType_WmfRecordTypeScaleViewportExt: EmfPlusRecordType = 66578;
pub const EmfPlusRecordType_WmfRecordTypeLineTo: EmfPlusRecordType = 66067;
pub const EmfPlusRecordType_WmfRecordTypeMoveTo: EmfPlusRecordType = 66068;
pub const EmfPlusRecordType_WmfRecordTypeExcludeClipRect: EmfPlusRecordType = 66581;
pub const EmfPlusRecordType_WmfRecordTypeIntersectClipRect: EmfPlusRecordType = 66582;
pub const EmfPlusRecordType_WmfRecordTypeArc: EmfPlusRecordType = 67607;
pub const EmfPlusRecordType_WmfRecordTypeEllipse: EmfPlusRecordType = 66584;
pub const EmfPlusRecordType_WmfRecordTypeFloodFill: EmfPlusRecordType = 66585;
pub const EmfPlusRecordType_WmfRecordTypePie: EmfPlusRecordType = 67610;
pub const EmfPlusRecordType_WmfRecordTypeRectangle: EmfPlusRecordType = 66587;
pub const EmfPlusRecordType_WmfRecordTypeRoundRect: EmfPlusRecordType = 67100;
pub const EmfPlusRecordType_WmfRecordTypePatBlt: EmfPlusRecordType = 67101;
pub const EmfPlusRecordType_WmfRecordTypeSaveDC: EmfPlusRecordType = 65566;
pub const EmfPlusRecordType_WmfRecordTypeSetPixel: EmfPlusRecordType = 66591;
pub const EmfPlusRecordType_WmfRecordTypeOffsetClipRgn: EmfPlusRecordType = 66080;
pub const EmfPlusRecordType_WmfRecordTypeTextOut: EmfPlusRecordType = 66849;
pub const EmfPlusRecordType_WmfRecordTypeBitBlt: EmfPlusRecordType = 67874;
pub const EmfPlusRecordType_WmfRecordTypeStretchBlt: EmfPlusRecordType = 68387;
pub const EmfPlusRecordType_WmfRecordTypePolygon: EmfPlusRecordType = 66340;
pub const EmfPlusRecordType_WmfRecordTypePolyline: EmfPlusRecordType = 66341;
pub const EmfPlusRecordType_WmfRecordTypeEscape: EmfPlusRecordType = 67110;
pub const EmfPlusRecordType_WmfRecordTypeRestoreDC: EmfPlusRecordType = 65831;
pub const EmfPlusRecordType_WmfRecordTypeFillRegion: EmfPlusRecordType = 66088;
pub const EmfPlusRecordType_WmfRecordTypeFrameRegion: EmfPlusRecordType = 66601;
pub const EmfPlusRecordType_WmfRecordTypeInvertRegion: EmfPlusRecordType = 65834;
pub const EmfPlusRecordType_WmfRecordTypePaintRegion: EmfPlusRecordType = 65835;
pub const EmfPlusRecordType_WmfRecordTypeSelectClipRegion: EmfPlusRecordType = 65836;
pub const EmfPlusRecordType_WmfRecordTypeSelectObject: EmfPlusRecordType = 65837;
pub const EmfPlusRecordType_WmfRecordTypeSetTextAlign: EmfPlusRecordType = 65838;
pub const EmfPlusRecordType_WmfRecordTypeDrawText: EmfPlusRecordType = 67119;
pub const EmfPlusRecordType_WmfRecordTypeChord: EmfPlusRecordType = 67632;
pub const EmfPlusRecordType_WmfRecordTypeSetMapperFlags: EmfPlusRecordType = 66097;
pub const EmfPlusRecordType_WmfRecordTypeExtTextOut: EmfPlusRecordType = 68146;
pub const EmfPlusRecordType_WmfRecordTypeSetDIBToDev: EmfPlusRecordType = 68915;
pub const EmfPlusRecordType_WmfRecordTypeSelectPalette: EmfPlusRecordType = 66100;
pub const EmfPlusRecordType_WmfRecordTypeRealizePalette: EmfPlusRecordType = 65589;
pub const EmfPlusRecordType_WmfRecordTypeAnimatePalette: EmfPlusRecordType = 66614;
pub const EmfPlusRecordType_WmfRecordTypeSetPalEntries: EmfPlusRecordType = 65591;
pub const EmfPlusRecordType_WmfRecordTypePolyPolygon: EmfPlusRecordType = 66872;
pub const EmfPlusRecordType_WmfRecordTypeResizePalette: EmfPlusRecordType = 65849;
pub const EmfPlusRecordType_WmfRecordTypeDIBBitBlt: EmfPlusRecordType = 67904;
pub const EmfPlusRecordType_WmfRecordTypeDIBStretchBlt: EmfPlusRecordType = 68417;
pub const EmfPlusRecordType_WmfRecordTypeDIBCreatePatternBrush: EmfPlusRecordType = 65858;
pub const EmfPlusRecordType_WmfRecordTypeStretchDIB: EmfPlusRecordType = 69443;
pub const EmfPlusRecordType_WmfRecordTypeExtFloodFill: EmfPlusRecordType = 66888;
pub const EmfPlusRecordType_WmfRecordTypeSetLayout: EmfPlusRecordType = 65865;
pub const EmfPlusRecordType_WmfRecordTypeResetDC: EmfPlusRecordType = 65868;
pub const EmfPlusRecordType_WmfRecordTypeStartDoc: EmfPlusRecordType = 65869;
pub const EmfPlusRecordType_WmfRecordTypeStartPage: EmfPlusRecordType = 65615;
pub const EmfPlusRecordType_WmfRecordTypeEndPage: EmfPlusRecordType = 65616;
pub const EmfPlusRecordType_WmfRecordTypeAbortDoc: EmfPlusRecordType = 65618;
pub const EmfPlusRecordType_WmfRecordTypeEndDoc: EmfPlusRecordType = 65630;
pub const EmfPlusRecordType_WmfRecordTypeDeleteObject: EmfPlusRecordType = 66032;
pub const EmfPlusRecordType_WmfRecordTypeCreatePalette: EmfPlusRecordType = 65783;
pub const EmfPlusRecordType_WmfRecordTypeCreateBrush: EmfPlusRecordType = 65784;
pub const EmfPlusRecordType_WmfRecordTypeCreatePatternBrush: EmfPlusRecordType = 66041;
pub const EmfPlusRecordType_WmfRecordTypeCreatePenIndirect: EmfPlusRecordType = 66298;
pub const EmfPlusRecordType_WmfRecordTypeCreateFontIndirect: EmfPlusRecordType = 66299;
pub const EmfPlusRecordType_WmfRecordTypeCreateBrushIndirect: EmfPlusRecordType = 66300;
pub const EmfPlusRecordType_WmfRecordTypeCreateBitmapIndirect: EmfPlusRecordType = 66301;
pub const EmfPlusRecordType_WmfRecordTypeCreateBitmap: EmfPlusRecordType = 67326;
pub const EmfPlusRecordType_WmfRecordTypeCreateRegion: EmfPlusRecordType = 67327;
pub const EmfPlusRecordType_EmfRecordTypeHeader: EmfPlusRecordType = 1;
pub const EmfPlusRecordType_EmfRecordTypePolyBezier: EmfPlusRecordType = 2;
pub const EmfPlusRecordType_EmfRecordTypePolygon: EmfPlusRecordType = 3;
pub const EmfPlusRecordType_EmfRecordTypePolyline: EmfPlusRecordType = 4;
pub const EmfPlusRecordType_EmfRecordTypePolyBezierTo: EmfPlusRecordType = 5;
pub const EmfPlusRecordType_EmfRecordTypePolyLineTo: EmfPlusRecordType = 6;
pub const EmfPlusRecordType_EmfRecordTypePolyPolyline: EmfPlusRecordType = 7;
pub const EmfPlusRecordType_EmfRecordTypePolyPolygon: EmfPlusRecordType = 8;
pub const EmfPlusRecordType_EmfRecordTypeSetWindowExtEx: EmfPlusRecordType = 9;
pub const EmfPlusRecordType_EmfRecordTypeSetWindowOrgEx: EmfPlusRecordType = 10;
pub const EmfPlusRecordType_EmfRecordTypeSetViewportExtEx: EmfPlusRecordType = 11;
pub const EmfPlusRecordType_EmfRecordTypeSetViewportOrgEx: EmfPlusRecordType = 12;
pub const EmfPlusRecordType_EmfRecordTypeSetBrushOrgEx: EmfPlusRecordType = 13;
pub const EmfPlusRecordType_EmfRecordTypeEOF: EmfPlusRecordType = 14;
pub const EmfPlusRecordType_EmfRecordTypeSetPixelV: EmfPlusRecordType = 15;
pub const EmfPlusRecordType_EmfRecordTypeSetMapperFlags: EmfPlusRecordType = 16;
pub const EmfPlusRecordType_EmfRecordTypeSetMapMode: EmfPlusRecordType = 17;
pub const EmfPlusRecordType_EmfRecordTypeSetBkMode: EmfPlusRecordType = 18;
pub const EmfPlusRecordType_EmfRecordTypeSetPolyFillMode: EmfPlusRecordType = 19;
pub const EmfPlusRecordType_EmfRecordTypeSetROP2: EmfPlusRecordType = 20;
pub const EmfPlusRecordType_EmfRecordTypeSetStretchBltMode: EmfPlusRecordType = 21;
pub const EmfPlusRecordType_EmfRecordTypeSetTextAlign: EmfPlusRecordType = 22;
pub const EmfPlusRecordType_EmfRecordTypeSetColorAdjustment: EmfPlusRecordType = 23;
pub const EmfPlusRecordType_EmfRecordTypeSetTextColor: EmfPlusRecordType = 24;
pub const EmfPlusRecordType_EmfRecordTypeSetBkColor: EmfPlusRecordType = 25;
pub const EmfPlusRecordType_EmfRecordTypeOffsetClipRgn: EmfPlusRecordType = 26;
pub const EmfPlusRecordType_EmfRecordTypeMoveToEx: EmfPlusRecordType = 27;
pub const EmfPlusRecordType_EmfRecordTypeSetMetaRgn: EmfPlusRecordType = 28;
pub const EmfPlusRecordType_EmfRecordTypeExcludeClipRect: EmfPlusRecordType = 29;
pub const EmfPlusRecordType_EmfRecordTypeIntersectClipRect: EmfPlusRecordType = 30;
pub const EmfPlusRecordType_EmfRecordTypeScaleViewportExtEx: EmfPlusRecordType = 31;
pub const EmfPlusRecordType_EmfRecordTypeScaleWindowExtEx: EmfPlusRecordType = 32;
pub const EmfPlusRecordType_EmfRecordTypeSaveDC: EmfPlusRecordType = 33;
pub const EmfPlusRecordType_EmfRecordTypeRestoreDC: EmfPlusRecordType = 34;
pub const EmfPlusRecordType_EmfRecordTypeSetWorldTransform: EmfPlusRecordType = 35;
pub const EmfPlusRecordType_EmfRecordTypeModifyWorldTransform: EmfPlusRecordType = 36;
pub const EmfPlusRecordType_EmfRecordTypeSelectObject: EmfPlusRecordType = 37;
pub const EmfPlusRecordType_EmfRecordTypeCreatePen: EmfPlusRecordType = 38;
pub const EmfPlusRecordType_EmfRecordTypeCreateBrushIndirect: EmfPlusRecordType = 39;
pub const EmfPlusRecordType_EmfRecordTypeDeleteObject: EmfPlusRecordType = 40;
pub const EmfPlusRecordType_EmfRecordTypeAngleArc: EmfPlusRecordType = 41;
pub const EmfPlusRecordType_EmfRecordTypeEllipse: EmfPlusRecordType = 42;
pub const EmfPlusRecordType_EmfRecordTypeRectangle: EmfPlusRecordType = 43;
pub const EmfPlusRecordType_EmfRecordTypeRoundRect: EmfPlusRecordType = 44;
pub const EmfPlusRecordType_EmfRecordTypeArc: EmfPlusRecordType = 45;
pub const EmfPlusRecordType_EmfRecordTypeChord: EmfPlusRecordType = 46;
pub const EmfPlusRecordType_EmfRecordTypePie: EmfPlusRecordType = 47;
pub const EmfPlusRecordType_EmfRecordTypeSelectPalette: EmfPlusRecordType = 48;
pub const EmfPlusRecordType_EmfRecordTypeCreatePalette: EmfPlusRecordType = 49;
pub const EmfPlusRecordType_EmfRecordTypeSetPaletteEntries: EmfPlusRecordType = 50;
pub const EmfPlusRecordType_EmfRecordTypeResizePalette: EmfPlusRecordType = 51;
pub const EmfPlusRecordType_EmfRecordTypeRealizePalette: EmfPlusRecordType = 52;
pub const EmfPlusRecordType_EmfRecordTypeExtFloodFill: EmfPlusRecordType = 53;
pub const EmfPlusRecordType_EmfRecordTypeLineTo: EmfPlusRecordType = 54;
pub const EmfPlusRecordType_EmfRecordTypeArcTo: EmfPlusRecordType = 55;
pub const EmfPlusRecordType_EmfRecordTypePolyDraw: EmfPlusRecordType = 56;
pub const EmfPlusRecordType_EmfRecordTypeSetArcDirection: EmfPlusRecordType = 57;
pub const EmfPlusRecordType_EmfRecordTypeSetMiterLimit: EmfPlusRecordType = 58;
pub const EmfPlusRecordType_EmfRecordTypeBeginPath: EmfPlusRecordType = 59;
pub const EmfPlusRecordType_EmfRecordTypeEndPath: EmfPlusRecordType = 60;
pub const EmfPlusRecordType_EmfRecordTypeCloseFigure: EmfPlusRecordType = 61;
pub const EmfPlusRecordType_EmfRecordTypeFillPath: EmfPlusRecordType = 62;
pub const EmfPlusRecordType_EmfRecordTypeStrokeAndFillPath: EmfPlusRecordType = 63;
pub const EmfPlusRecordType_EmfRecordTypeStrokePath: EmfPlusRecordType = 64;
pub const EmfPlusRecordType_EmfRecordTypeFlattenPath: EmfPlusRecordType = 65;
pub const EmfPlusRecordType_EmfRecordTypeWidenPath: EmfPlusRecordType = 66;
pub const EmfPlusRecordType_EmfRecordTypeSelectClipPath: EmfPlusRecordType = 67;
pub const EmfPlusRecordType_EmfRecordTypeAbortPath: EmfPlusRecordType = 68;
pub const EmfPlusRecordType_EmfRecordTypeReserved_069: EmfPlusRecordType = 69;
pub const EmfPlusRecordType_EmfRecordTypeGdiComment: EmfPlusRecordType = 70;
pub const EmfPlusRecordType_EmfRecordTypeFillRgn: EmfPlusRecordType = 71;
pub const EmfPlusRecordType_EmfRecordTypeFrameRgn: EmfPlusRecordType = 72;
pub const EmfPlusRecordType_EmfRecordTypeInvertRgn: EmfPlusRecordType = 73;
pub const EmfPlusRecordType_EmfRecordTypePaintRgn: EmfPlusRecordType = 74;
pub const EmfPlusRecordType_EmfRecordTypeExtSelectClipRgn: EmfPlusRecordType = 75;
pub const EmfPlusRecordType_EmfRecordTypeBitBlt: EmfPlusRecordType = 76;
pub const EmfPlusRecordType_EmfRecordTypeStretchBlt: EmfPlusRecordType = 77;
pub const EmfPlusRecordType_EmfRecordTypeMaskBlt: EmfPlusRecordType = 78;
pub const EmfPlusRecordType_EmfRecordTypePlgBlt: EmfPlusRecordType = 79;
pub const EmfPlusRecordType_EmfRecordTypeSetDIBitsToDevice: EmfPlusRecordType = 80;
pub const EmfPlusRecordType_EmfRecordTypeStretchDIBits: EmfPlusRecordType = 81;
pub const EmfPlusRecordType_EmfRecordTypeExtCreateFontIndirect: EmfPlusRecordType = 82;
pub const EmfPlusRecordType_EmfRecordTypeExtTextOutA: EmfPlusRecordType = 83;
pub const EmfPlusRecordType_EmfRecordTypeExtTextOutW: EmfPlusRecordType = 84;
pub const EmfPlusRecordType_EmfRecordTypePolyBezier16: EmfPlusRecordType = 85;
pub const EmfPlusRecordType_EmfRecordTypePolygon16: EmfPlusRecordType = 86;
pub const EmfPlusRecordType_EmfRecordTypePolyline16: EmfPlusRecordType = 87;
pub const EmfPlusRecordType_EmfRecordTypePolyBezierTo16: EmfPlusRecordType = 88;
pub const EmfPlusRecordType_EmfRecordTypePolylineTo16: EmfPlusRecordType = 89;
pub const EmfPlusRecordType_EmfRecordTypePolyPolyline16: EmfPlusRecordType = 90;
pub const EmfPlusRecordType_EmfRecordTypePolyPolygon16: EmfPlusRecordType = 91;
pub const EmfPlusRecordType_EmfRecordTypePolyDraw16: EmfPlusRecordType = 92;
pub const EmfPlusRecordType_EmfRecordTypeCreateMonoBrush: EmfPlusRecordType = 93;
pub const EmfPlusRecordType_EmfRecordTypeCreateDIBPatternBrushPt: EmfPlusRecordType = 94;
pub const EmfPlusRecordType_EmfRecordTypeExtCreatePen: EmfPlusRecordType = 95;
pub const EmfPlusRecordType_EmfRecordTypePolyTextOutA: EmfPlusRecordType = 96;
pub const EmfPlusRecordType_EmfRecordTypePolyTextOutW: EmfPlusRecordType = 97;
pub const EmfPlusRecordType_EmfRecordTypeSetICMMode: EmfPlusRecordType = 98;
pub const EmfPlusRecordType_EmfRecordTypeCreateColorSpace: EmfPlusRecordType = 99;
pub const EmfPlusRecordType_EmfRecordTypeSetColorSpace: EmfPlusRecordType = 100;
pub const EmfPlusRecordType_EmfRecordTypeDeleteColorSpace: EmfPlusRecordType = 101;
pub const EmfPlusRecordType_EmfRecordTypeGLSRecord: EmfPlusRecordType = 102;
pub const EmfPlusRecordType_EmfRecordTypeGLSBoundedRecord: EmfPlusRecordType = 103;
pub const EmfPlusRecordType_EmfRecordTypePixelFormat: EmfPlusRecordType = 104;
pub const EmfPlusRecordType_EmfRecordTypeDrawEscape: EmfPlusRecordType = 105;
pub const EmfPlusRecordType_EmfRecordTypeExtEscape: EmfPlusRecordType = 106;
pub const EmfPlusRecordType_EmfRecordTypeStartDoc: EmfPlusRecordType = 107;
pub const EmfPlusRecordType_EmfRecordTypeSmallTextOut: EmfPlusRecordType = 108;
pub const EmfPlusRecordType_EmfRecordTypeForceUFIMapping: EmfPlusRecordType = 109;
pub const EmfPlusRecordType_EmfRecordTypeNamedEscape: EmfPlusRecordType = 110;
pub const EmfPlusRecordType_EmfRecordTypeColorCorrectPalette: EmfPlusRecordType = 111;
pub const EmfPlusRecordType_EmfRecordTypeSetICMProfileA: EmfPlusRecordType = 112;
pub const EmfPlusRecordType_EmfRecordTypeSetICMProfileW: EmfPlusRecordType = 113;
pub const EmfPlusRecordType_EmfRecordTypeAlphaBlend: EmfPlusRecordType = 114;
pub const EmfPlusRecordType_EmfRecordTypeSetLayout: EmfPlusRecordType = 115;
pub const EmfPlusRecordType_EmfRecordTypeTransparentBlt: EmfPlusRecordType = 116;
pub const EmfPlusRecordType_EmfRecordTypeReserved_117: EmfPlusRecordType = 117;
pub const EmfPlusRecordType_EmfRecordTypeGradientFill: EmfPlusRecordType = 118;
pub const EmfPlusRecordType_EmfRecordTypeSetLinkedUFIs: EmfPlusRecordType = 119;
pub const EmfPlusRecordType_EmfRecordTypeSetTextJustification: EmfPlusRecordType = 120;
pub const EmfPlusRecordType_EmfRecordTypeColorMatchToTargetW: EmfPlusRecordType = 121;
pub const EmfPlusRecordType_EmfRecordTypeCreateColorSpaceW: EmfPlusRecordType = 122;
pub const EmfPlusRecordType_EmfRecordTypeMax: EmfPlusRecordType = 122;
pub const EmfPlusRecordType_EmfRecordTypeMin: EmfPlusRecordType = 1;
pub const EmfPlusRecordType_EmfPlusRecordTypeInvalid: EmfPlusRecordType = 16384;
pub const EmfPlusRecordType_EmfPlusRecordTypeHeader: EmfPlusRecordType = 16385;
pub const EmfPlusRecordType_EmfPlusRecordTypeEndOfFile: EmfPlusRecordType = 16386;
pub const EmfPlusRecordType_EmfPlusRecordTypeComment: EmfPlusRecordType = 16387;
pub const EmfPlusRecordType_EmfPlusRecordTypeGetDC: EmfPlusRecordType = 16388;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiFormatStart: EmfPlusRecordType = 16389;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiFormatSection: EmfPlusRecordType = 16390;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiFormatEnd: EmfPlusRecordType = 16391;
pub const EmfPlusRecordType_EmfPlusRecordTypeObject: EmfPlusRecordType = 16392;
pub const EmfPlusRecordType_EmfPlusRecordTypeClear: EmfPlusRecordType = 16393;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillRects: EmfPlusRecordType = 16394;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawRects: EmfPlusRecordType = 16395;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillPolygon: EmfPlusRecordType = 16396;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawLines: EmfPlusRecordType = 16397;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillEllipse: EmfPlusRecordType = 16398;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawEllipse: EmfPlusRecordType = 16399;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillPie: EmfPlusRecordType = 16400;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawPie: EmfPlusRecordType = 16401;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawArc: EmfPlusRecordType = 16402;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillRegion: EmfPlusRecordType = 16403;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillPath: EmfPlusRecordType = 16404;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawPath: EmfPlusRecordType = 16405;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillClosedCurve: EmfPlusRecordType = 16406;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawClosedCurve: EmfPlusRecordType = 16407;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawCurve: EmfPlusRecordType = 16408;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawBeziers: EmfPlusRecordType = 16409;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawImage: EmfPlusRecordType = 16410;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawImagePoints: EmfPlusRecordType = 16411;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawString: EmfPlusRecordType = 16412;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetRenderingOrigin: EmfPlusRecordType = 16413;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetAntiAliasMode: EmfPlusRecordType = 16414;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetTextRenderingHint: EmfPlusRecordType = 16415;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetTextContrast: EmfPlusRecordType = 16416;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetInterpolationMode: EmfPlusRecordType = 16417;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetPixelOffsetMode: EmfPlusRecordType = 16418;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetCompositingMode: EmfPlusRecordType = 16419;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetCompositingQuality: EmfPlusRecordType = 16420;
pub const EmfPlusRecordType_EmfPlusRecordTypeSave: EmfPlusRecordType = 16421;
pub const EmfPlusRecordType_EmfPlusRecordTypeRestore: EmfPlusRecordType = 16422;
pub const EmfPlusRecordType_EmfPlusRecordTypeBeginContainer: EmfPlusRecordType = 16423;
pub const EmfPlusRecordType_EmfPlusRecordTypeBeginContainerNoParams: EmfPlusRecordType = 16424;
pub const EmfPlusRecordType_EmfPlusRecordTypeEndContainer: EmfPlusRecordType = 16425;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetWorldTransform: EmfPlusRecordType = 16426;
pub const EmfPlusRecordType_EmfPlusRecordTypeResetWorldTransform: EmfPlusRecordType = 16427;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiplyWorldTransform: EmfPlusRecordType = 16428;
pub const EmfPlusRecordType_EmfPlusRecordTypeTranslateWorldTransform: EmfPlusRecordType = 16429;
pub const EmfPlusRecordType_EmfPlusRecordTypeScaleWorldTransform: EmfPlusRecordType = 16430;
pub const EmfPlusRecordType_EmfPlusRecordTypeRotateWorldTransform: EmfPlusRecordType = 16431;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetPageTransform: EmfPlusRecordType = 16432;
pub const EmfPlusRecordType_EmfPlusRecordTypeResetClip: EmfPlusRecordType = 16433;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetClipRect: EmfPlusRecordType = 16434;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetClipPath: EmfPlusRecordType = 16435;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetClipRegion: EmfPlusRecordType = 16436;
pub const EmfPlusRecordType_EmfPlusRecordTypeOffsetClip: EmfPlusRecordType = 16437;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawDriverString: EmfPlusRecordType = 16438;
pub const EmfPlusRecordType_EmfPlusRecordTotal: EmfPlusRecordType = 16439;
pub const EmfPlusRecordType_EmfPlusRecordTypeMax: EmfPlusRecordType = 16438;
pub const EmfPlusRecordType_EmfPlusRecordTypeMin: EmfPlusRecordType = 16385;
pub type EmfPlusRecordType = ::core::ffi::c_int;
pub const StringTrimming_StringTrimmingNone: StringTrimming = 0;
pub const StringTrimming_StringTrimmingCharacter: StringTrimming = 1;
pub const StringTrimming_StringTrimmingWord: StringTrimming = 2;
pub const StringTrimming_StringTrimmingEllipsisCharacter: StringTrimming = 3;
pub const StringTrimming_StringTrimmingEllipsisWord: StringTrimming = 4;
pub const StringTrimming_StringTrimmingEllipsisPath: StringTrimming = 5;
pub type StringTrimming = ::core::ffi::c_int;
pub const StringDigitSubstitute_StringDigitSubstituteUser: StringDigitSubstitute = 0;
pub const StringDigitSubstitute_StringDigitSubstituteNone: StringDigitSubstitute = 1;
pub const StringDigitSubstitute_StringDigitSubstituteNational: StringDigitSubstitute = 2;
pub const StringDigitSubstitute_StringDigitSubstituteTraditional: StringDigitSubstitute = 3;
pub type StringDigitSubstitute = ::core::ffi::c_int;
pub const StringAlignment_StringAlignmentNear: StringAlignment = 0;
pub const StringAlignment_StringAlignmentCenter: StringAlignment = 1;
pub const StringAlignment_StringAlignmentFar: StringAlignment = 2;
pub type StringAlignment = ::core::ffi::c_int;
pub const FlushIntention_FlushIntentionFlush: FlushIntention = 0;
pub const FlushIntention_FlushIntentionSync: FlushIntention = 1;
pub type FlushIntention = ::core::ffi::c_int;
pub const GpTestControlEnum_TestControlForceBilinear: GpTestControlEnum = 0;
pub const GpTestControlEnum_TestControlNoICM: GpTestControlEnum = 1;
pub const GpTestControlEnum_TestControlGetBuildNumber: GpTestControlEnum = 2;
pub type GpTestControlEnum = ::core::ffi::c_int;
pub type ImageAbort =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> BOOL>;
pub type DrawImageAbort = ImageAbort;
pub type GetThumbnailImageAbort = ImageAbort;
pub type EnumerateMetafileProc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: EmfPlusRecordType,
        arg2: UINT,
        arg3: UINT,
        arg4: *const BYTE,
        arg5: *mut ::core::ffi::c_void,
    ) -> BOOL,
>;
pub type REAL = f32;
pub const Status_Ok: Status = 0;
pub const Status_GenericError: Status = 1;
pub const Status_InvalidParameter: Status = 2;
pub const Status_OutOfMemory: Status = 3;
pub const Status_ObjectBusy: Status = 4;
pub const Status_InsufficientBuffer: Status = 5;
pub const Status_NotImplemented: Status = 6;
pub const Status_Win32Error: Status = 7;
pub const Status_WrongState: Status = 8;
pub const Status_Aborted: Status = 9;
pub const Status_FileNotFound: Status = 10;
pub const Status_ValueOverflow: Status = 11;
pub const Status_AccessDenied: Status = 12;
pub const Status_UnknownImageFormat: Status = 13;
pub const Status_FontFamilyNotFound: Status = 14;
pub const Status_FontStyleNotFound: Status = 15;
pub const Status_NotTrueTypeFont: Status = 16;
pub const Status_UnsupportedGdiplusVersion: Status = 17;
pub const Status_GdiplusNotInitialized: Status = 18;
pub const Status_PropertyNotFound: Status = 19;
pub const Status_PropertyNotSupported: Status = 20;
pub type Status = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SizeF {
    pub Width: REAL,
    pub Height: REAL,
}
#[test]
fn bindgen_test_layout_SizeF() {
    assert_eq!(
        ::core::mem::size_of::<SizeF>(),
        8usize,
        concat!("Size of: ", stringify!(SizeF))
    );
    assert_eq!(
        ::core::mem::align_of::<SizeF>(),
        4usize,
        concat!("Alignment of ", stringify!(SizeF))
    );
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SizeF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SizeF),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SizeF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SizeF),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PointF {
    pub X: REAL,
    pub Y: REAL,
}
#[test]
fn bindgen_test_layout_PointF() {
    assert_eq!(
        ::core::mem::size_of::<PointF>(),
        8usize,
        concat!("Size of: ", stringify!(PointF))
    );
    assert_eq!(
        ::core::mem::align_of::<PointF>(),
        4usize,
        concat!("Alignment of ", stringify!(PointF))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PointF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PointF), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PointF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(PointF), "::", stringify!(Y))
        );
    }
    test_field_Y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Point {
    pub X: INT,
    pub Y: INT,
}
#[test]
fn bindgen_test_layout_Point() {
    assert_eq!(
        ::core::mem::size_of::<Point>(),
        8usize,
        concat!("Size of: ", stringify!(Point))
    );
    assert_eq!(
        ::core::mem::align_of::<Point>(),
        4usize,
        concat!("Alignment of ", stringify!(Point))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Point>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(Point), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Point>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(Point), "::", stringify!(Y))
        );
    }
    test_field_Y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RectF {
    pub X: REAL,
    pub Y: REAL,
    pub Width: REAL,
    pub Height: REAL,
}
#[test]
fn bindgen_test_layout_RectF() {
    assert_eq!(
        ::core::mem::size_of::<RectF>(),
        16usize,
        concat!("Size of: ", stringify!(RectF))
    );
    assert_eq!(
        ::core::mem::align_of::<RectF>(),
        4usize,
        concat!("Alignment of ", stringify!(RectF))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RectF), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(RectF), "::", stringify!(Y))
        );
    }
    test_field_Y();
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RectF),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(RectF),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rect {
    pub X: INT,
    pub Y: INT,
    pub Width: INT,
    pub Height: INT,
}
#[test]
fn bindgen_test_layout_Rect() {
    assert_eq!(
        ::core::mem::size_of::<Rect>(),
        16usize,
        concat!("Size of: ", stringify!(Rect))
    );
    assert_eq!(
        ::core::mem::align_of::<Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(Rect))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(Rect), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(Rect), "::", stringify!(Y))
        );
    }
    test_field_Y();
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Rect),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Rect),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
#[repr(C)]
#[derive(Debug)]
pub struct PathData {
    pub Count: INT,
    pub Points: *mut PointF,
    pub Types: *mut BYTE,
}
#[test]
fn bindgen_test_layout_PathData() {
    assert_eq!(
        ::core::mem::size_of::<PathData>(),
        24usize,
        concat!("Size of: ", stringify!(PathData))
    );
    assert_eq!(
        ::core::mem::align_of::<PathData>(),
        8usize,
        concat!("Alignment of ", stringify!(PathData))
    );
    fn test_field_Count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PathData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PathData),
                "::",
                stringify!(Count)
            )
        );
    }
    test_field_Count();
    fn test_field_Points() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PathData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Points) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PathData),
                "::",
                stringify!(Points)
            )
        );
    }
    test_field_Points();
    fn test_field_Types() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PathData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Types) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PathData),
                "::",
                stringify!(Types)
            )
        );
    }
    test_field_Types();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CharacterRange {
    pub First: INT,
    pub Length: INT,
}
#[test]
fn bindgen_test_layout_CharacterRange() {
    assert_eq!(
        ::core::mem::size_of::<CharacterRange>(),
        8usize,
        concat!("Size of: ", stringify!(CharacterRange))
    );
    assert_eq!(
        ::core::mem::align_of::<CharacterRange>(),
        4usize,
        concat!("Alignment of ", stringify!(CharacterRange))
    );
    fn test_field_First() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CharacterRange>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).First) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CharacterRange),
                "::",
                stringify!(First)
            )
        );
    }
    test_field_First();
    fn test_field_Length() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CharacterRange>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CharacterRange),
                "::",
                stringify!(Length)
            )
        );
    }
    test_field_Length();
}
pub const DebugEventLevel_DebugEventLevelFatal: DebugEventLevel = 0;
pub const DebugEventLevel_DebugEventLevelWarning: DebugEventLevel = 1;
pub type DebugEventLevel = ::core::ffi::c_int;
pub type DebugEventProc =
    ::core::option::Option<unsafe extern "C" fn(level: DebugEventLevel, message: *mut CHAR)>;
pub type NotificationHookProc =
    ::core::option::Option<unsafe extern "C" fn(token: *mut ULONG_PTR) -> Status>;
pub type NotificationUnhookProc = ::core::option::Option<unsafe extern "C" fn(token: ULONG_PTR)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GdiplusStartupInput {
    pub GdiplusVersion: UINT32,
    pub DebugEventCallback: DebugEventProc,
    pub SuppressBackgroundThread: BOOL,
    pub SuppressExternalCodecs: BOOL,
}
#[test]
fn bindgen_test_layout_GdiplusStartupInput() {
    assert_eq!(
        ::core::mem::size_of::<GdiplusStartupInput>(),
        24usize,
        concat!("Size of: ", stringify!(GdiplusStartupInput))
    );
    assert_eq!(
        ::core::mem::align_of::<GdiplusStartupInput>(),
        8usize,
        concat!("Alignment of ", stringify!(GdiplusStartupInput))
    );
    fn test_field_GdiplusVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).GdiplusVersion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(GdiplusVersion)
            )
        );
    }
    test_field_GdiplusVersion();
    fn test_field_DebugEventCallback() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DebugEventCallback) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(DebugEventCallback)
            )
        );
    }
    test_field_DebugEventCallback();
    fn test_field_SuppressBackgroundThread() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SuppressBackgroundThread) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(SuppressBackgroundThread)
            )
        );
    }
    test_field_SuppressBackgroundThread();
    fn test_field_SuppressExternalCodecs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SuppressExternalCodecs) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(SuppressExternalCodecs)
            )
        );
    }
    test_field_SuppressExternalCodecs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GdiplusStartupOutput {
    pub NotificationHook: NotificationHookProc,
    pub NotificationUnhook: NotificationUnhookProc,
}
#[test]
fn bindgen_test_layout_GdiplusStartupOutput() {
    assert_eq!(
        ::core::mem::size_of::<GdiplusStartupOutput>(),
        16usize,
        concat!("Size of: ", stringify!(GdiplusStartupOutput))
    );
    assert_eq!(
        ::core::mem::align_of::<GdiplusStartupOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(GdiplusStartupOutput))
    );
    fn test_field_NotificationHook() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupOutput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).NotificationHook) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupOutput),
                "::",
                stringify!(NotificationHook)
            )
        );
    }
    test_field_NotificationHook();
    fn test_field_NotificationUnhook() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupOutput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).NotificationUnhook) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupOutput),
                "::",
                stringify!(NotificationUnhook)
            )
        );
    }
    test_field_NotificationUnhook();
}
extern "C" {
    pub fn GdiplusStartup(
        token: *mut ULONG_PTR,
        input: *const GdiplusStartupInput,
        output: *mut GdiplusStartupOutput,
    ) -> Status;
}
extern "C" {
    pub fn GdiplusShutdown(token: ULONG_PTR);
}
pub type ARGB = DWORD;
pub type PixelFormat = INT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorPalette {
    pub Flags: UINT,
    pub Count: UINT,
    pub Entries: [ARGB; 1usize],
}
#[test]
fn bindgen_test_layout_ColorPalette() {
    assert_eq!(
        ::core::mem::size_of::<ColorPalette>(),
        12usize,
        concat!("Size of: ", stringify!(ColorPalette))
    );
    assert_eq!(
        ::core::mem::align_of::<ColorPalette>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorPalette))
    );
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorPalette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorPalette),
                "::",
                stringify!(Flags)
            )
        );
    }
    test_field_Flags();
    fn test_field_Count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorPalette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorPalette),
                "::",
                stringify!(Count)
            )
        );
    }
    test_field_Count();
    fn test_field_Entries() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorPalette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Entries) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorPalette),
                "::",
                stringify!(Entries)
            )
        );
    }
    test_field_Entries();
}
pub const ColorChannelFlags_ColorChannelFlagsC: ColorChannelFlags = 0;
pub const ColorChannelFlags_ColorChannelFlagsM: ColorChannelFlags = 1;
pub const ColorChannelFlags_ColorChannelFlagsY: ColorChannelFlags = 2;
pub const ColorChannelFlags_ColorChannelFlagsK: ColorChannelFlags = 3;
pub const ColorChannelFlags_ColorChannelFlagsLast: ColorChannelFlags = 4;
pub type ColorChannelFlags = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Color {
    pub Argb: ARGB,
}
pub const Color_AliceBlue: Color__bindgen_ty_1 = -984833;
pub const Color_AntiqueWhite: Color__bindgen_ty_1 = -332841;
pub const Color_Aqua: Color__bindgen_ty_1 = -16711681;
pub const Color_Aquamarine: Color__bindgen_ty_1 = -8388652;
pub const Color_Azure: Color__bindgen_ty_1 = -983041;
pub const Color_Beige: Color__bindgen_ty_1 = -657956;
pub const Color_Bisque: Color__bindgen_ty_1 = -6972;
pub const Color_Black: Color__bindgen_ty_1 = -16777216;
pub const Color_BlanchedAlmond: Color__bindgen_ty_1 = -5171;
pub const Color_Blue: Color__bindgen_ty_1 = -16776961;
pub const Color_BlueViolet: Color__bindgen_ty_1 = -7722014;
pub const Color_Brown: Color__bindgen_ty_1 = -5952982;
pub const Color_BurlyWood: Color__bindgen_ty_1 = -2180985;
pub const Color_CadetBlue: Color__bindgen_ty_1 = -10510688;
pub const Color_Chartreuse: Color__bindgen_ty_1 = -8388864;
pub const Color_Chocolate: Color__bindgen_ty_1 = -2987746;
pub const Color_Coral: Color__bindgen_ty_1 = -32944;
pub const Color_CornflowerBlue: Color__bindgen_ty_1 = -10185235;
pub const Color_Cornsilk: Color__bindgen_ty_1 = -1828;
pub const Color_Crimson: Color__bindgen_ty_1 = -2354116;
pub const Color_Cyan: Color__bindgen_ty_1 = -16711681;
pub const Color_DarkBlue: Color__bindgen_ty_1 = -16777077;
pub const Color_DarkCyan: Color__bindgen_ty_1 = -16741493;
pub const Color_DarkGoldenrod: Color__bindgen_ty_1 = -4684277;
pub const Color_DarkGray: Color__bindgen_ty_1 = -5658199;
pub const Color_DarkGreen: Color__bindgen_ty_1 = -16751616;
pub const Color_DarkKhaki: Color__bindgen_ty_1 = -4343957;
pub const Color_DarkMagenta: Color__bindgen_ty_1 = -7667573;
pub const Color_DarkOliveGreen: Color__bindgen_ty_1 = -11179217;
pub const Color_DarkOrange: Color__bindgen_ty_1 = -29696;
pub const Color_DarkOrchid: Color__bindgen_ty_1 = -6737204;
pub const Color_DarkRed: Color__bindgen_ty_1 = -7667712;
pub const Color_DarkSalmon: Color__bindgen_ty_1 = -1468806;
pub const Color_DarkSeaGreen: Color__bindgen_ty_1 = -7357301;
pub const Color_DarkSlateBlue: Color__bindgen_ty_1 = -12042869;
pub const Color_DarkSlateGray: Color__bindgen_ty_1 = -13676721;
pub const Color_DarkTurquoise: Color__bindgen_ty_1 = -16724271;
pub const Color_DarkViolet: Color__bindgen_ty_1 = -7077677;
pub const Color_DeepPink: Color__bindgen_ty_1 = -60269;
pub const Color_DeepSkyBlue: Color__bindgen_ty_1 = -16728065;
pub const Color_DimGray: Color__bindgen_ty_1 = -9868951;
pub const Color_DodgerBlue: Color__bindgen_ty_1 = -14774017;
pub const Color_Firebrick: Color__bindgen_ty_1 = -5103070;
pub const Color_FloralWhite: Color__bindgen_ty_1 = -1296;
pub const Color_ForestGreen: Color__bindgen_ty_1 = -14513374;
pub const Color_Fuchsia: Color__bindgen_ty_1 = -65281;
pub const Color_Gainsboro: Color__bindgen_ty_1 = -2302756;
pub const Color_GhostWhite: Color__bindgen_ty_1 = -460545;
pub const Color_Gold: Color__bindgen_ty_1 = -10496;
pub const Color_Goldenrod: Color__bindgen_ty_1 = -2448096;
pub const Color_Gray: Color__bindgen_ty_1 = -8355712;
pub const Color_Green: Color__bindgen_ty_1 = -16744448;
pub const Color_GreenYellow: Color__bindgen_ty_1 = -5374161;
pub const Color_Honeydew: Color__bindgen_ty_1 = -983056;
pub const Color_HotPink: Color__bindgen_ty_1 = -38476;
pub const Color_IndianRed: Color__bindgen_ty_1 = -3318692;
pub const Color_Indigo: Color__bindgen_ty_1 = -11861886;
pub const Color_Ivory: Color__bindgen_ty_1 = -16;
pub const Color_Khaki: Color__bindgen_ty_1 = -989556;
pub const Color_Lavender: Color__bindgen_ty_1 = -1644806;
pub const Color_LavenderBlush: Color__bindgen_ty_1 = -3851;
pub const Color_LawnGreen: Color__bindgen_ty_1 = -8586240;
pub const Color_LemonChiffon: Color__bindgen_ty_1 = -1331;
pub const Color_LightBlue: Color__bindgen_ty_1 = -5383962;
pub const Color_LightCoral: Color__bindgen_ty_1 = -1015680;
pub const Color_LightCyan: Color__bindgen_ty_1 = -2031617;
pub const Color_LightGoldenrodYellow: Color__bindgen_ty_1 = -329006;
pub const Color_LightGray: Color__bindgen_ty_1 = -2894893;
pub const Color_LightGreen: Color__bindgen_ty_1 = -7278960;
pub const Color_LightPink: Color__bindgen_ty_1 = -18751;
pub const Color_LightSalmon: Color__bindgen_ty_1 = -24454;
pub const Color_LightSeaGreen: Color__bindgen_ty_1 = -14634326;
pub const Color_LightSkyBlue: Color__bindgen_ty_1 = -7876870;
pub const Color_LightSlateGray: Color__bindgen_ty_1 = -8943463;
pub const Color_LightSteelBlue: Color__bindgen_ty_1 = -5192482;
pub const Color_LightYellow: Color__bindgen_ty_1 = -32;
pub const Color_Lime: Color__bindgen_ty_1 = -16711936;
pub const Color_LimeGreen: Color__bindgen_ty_1 = -13447886;
pub const Color_Linen: Color__bindgen_ty_1 = -331546;
pub const Color_Magenta: Color__bindgen_ty_1 = -65281;
pub const Color_Maroon: Color__bindgen_ty_1 = -8388608;
pub const Color_MediumAquamarine: Color__bindgen_ty_1 = -10039894;
pub const Color_MediumBlue: Color__bindgen_ty_1 = -16777011;
pub const Color_MediumOrchid: Color__bindgen_ty_1 = -4565549;
pub const Color_MediumPurple: Color__bindgen_ty_1 = -7114533;
pub const Color_MediumSeaGreen: Color__bindgen_ty_1 = -12799119;
pub const Color_MediumSlateBlue: Color__bindgen_ty_1 = -8689426;
pub const Color_MediumSpringGreen: Color__bindgen_ty_1 = -16713062;
pub const Color_MediumTurquoise: Color__bindgen_ty_1 = -12004916;
pub const Color_MediumVioletRed: Color__bindgen_ty_1 = -3730043;
pub const Color_MidnightBlue: Color__bindgen_ty_1 = -15132304;
pub const Color_MintCream: Color__bindgen_ty_1 = -655366;
pub const Color_MistyRose: Color__bindgen_ty_1 = -6943;
pub const Color_Moccasin: Color__bindgen_ty_1 = -6987;
pub const Color_NavajoWhite: Color__bindgen_ty_1 = -8531;
pub const Color_Navy: Color__bindgen_ty_1 = -16777088;
pub const Color_OldLace: Color__bindgen_ty_1 = -133658;
pub const Color_Olive: Color__bindgen_ty_1 = -8355840;
pub const Color_OliveDrab: Color__bindgen_ty_1 = -9728477;
pub const Color_Orange: Color__bindgen_ty_1 = -23296;
pub const Color_OrangeRed: Color__bindgen_ty_1 = -47872;
pub const Color_Orchid: Color__bindgen_ty_1 = -2461482;
pub const Color_PaleGoldenrod: Color__bindgen_ty_1 = -1120086;
pub const Color_PaleGreen: Color__bindgen_ty_1 = -6751336;
pub const Color_PaleTurquoise: Color__bindgen_ty_1 = -5247250;
pub const Color_PaleVioletRed: Color__bindgen_ty_1 = -2396013;
pub const Color_PapayaWhip: Color__bindgen_ty_1 = -4139;
pub const Color_PeachPuff: Color__bindgen_ty_1 = -9543;
pub const Color_Peru: Color__bindgen_ty_1 = -3308225;
pub const Color_Pink: Color__bindgen_ty_1 = -16181;
pub const Color_Plum: Color__bindgen_ty_1 = -2252579;
pub const Color_PowderBlue: Color__bindgen_ty_1 = -5185306;
pub const Color_Purple: Color__bindgen_ty_1 = -8388480;
pub const Color_Red: Color__bindgen_ty_1 = -65536;
pub const Color_RosyBrown: Color__bindgen_ty_1 = -4419697;
pub const Color_RoyalBlue: Color__bindgen_ty_1 = -12490271;
pub const Color_SaddleBrown: Color__bindgen_ty_1 = -7650029;
pub const Color_Salmon: Color__bindgen_ty_1 = -360334;
pub const Color_SandyBrown: Color__bindgen_ty_1 = -744352;
pub const Color_SeaGreen: Color__bindgen_ty_1 = -13726889;
pub const Color_SeaShell: Color__bindgen_ty_1 = -2578;
pub const Color_Sienna: Color__bindgen_ty_1 = -6270419;
pub const Color_Silver: Color__bindgen_ty_1 = -4144960;
pub const Color_SkyBlue: Color__bindgen_ty_1 = -7876885;
pub const Color_SlateBlue: Color__bindgen_ty_1 = -9807155;
pub const Color_SlateGray: Color__bindgen_ty_1 = -9404272;
pub const Color_Snow: Color__bindgen_ty_1 = -1286;
pub const Color_SpringGreen: Color__bindgen_ty_1 = -16711809;
pub const Color_SteelBlue: Color__bindgen_ty_1 = -12156236;
pub const Color_Tan: Color__bindgen_ty_1 = -2968436;
pub const Color_Teal: Color__bindgen_ty_1 = -16744320;
pub const Color_Thistle: Color__bindgen_ty_1 = -2572328;
pub const Color_Tomato: Color__bindgen_ty_1 = -40121;
pub const Color_Transparent: Color__bindgen_ty_1 = 16777215;
pub const Color_Turquoise: Color__bindgen_ty_1 = -12525360;
pub const Color_Violet: Color__bindgen_ty_1 = -1146130;
pub const Color_Wheat: Color__bindgen_ty_1 = -663885;
pub const Color_White: Color__bindgen_ty_1 = -1;
pub const Color_WhiteSmoke: Color__bindgen_ty_1 = -657931;
pub const Color_Yellow: Color__bindgen_ty_1 = -256;
pub const Color_YellowGreen: Color__bindgen_ty_1 = -6632142;
pub type Color__bindgen_ty_1 = ::core::ffi::c_int;
pub const Color_AlphaShift: Color__bindgen_ty_2 = 24;
pub const Color_RedShift: Color__bindgen_ty_2 = 16;
pub const Color_GreenShift: Color__bindgen_ty_2 = 8;
pub const Color_BlueShift: Color__bindgen_ty_2 = 0;
pub type Color__bindgen_ty_2 = ::core::ffi::c_int;
pub const Color_AlphaMask: Color__bindgen_ty_3 = -16777216;
pub const Color_RedMask: Color__bindgen_ty_3 = 16711680;
pub const Color_GreenMask: Color__bindgen_ty_3 = 65280;
pub const Color_BlueMask: Color__bindgen_ty_3 = 255;
pub type Color__bindgen_ty_3 = ::core::ffi::c_int;
#[test]
fn bindgen_test_layout_Color() {
    assert_eq!(
        ::core::mem::size_of::<Color>(),
        4usize,
        concat!("Size of: ", stringify!(Color))
    );
    assert_eq!(
        ::core::mem::align_of::<Color>(),
        4usize,
        concat!("Alignment of ", stringify!(Color))
    );
    fn test_field_Argb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Color>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Argb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Color),
                "::",
                stringify!(Argb)
            )
        );
    }
    test_field_Argb();
}
#[repr(C)]
pub struct ENHMETAHEADER3 {
    pub iType: DWORD,
    pub nSize: DWORD,
    pub rclBounds: RECTL,
    pub rclFrame: RECTL,
    pub dSignature: DWORD,
    pub nVersion: DWORD,
    pub nBytes: DWORD,
    pub nRecords: DWORD,
    pub nHandles: WORD,
    pub sReserved: WORD,
    pub nDescription: DWORD,
    pub offDescription: DWORD,
    pub nPalEntries: DWORD,
    pub szlDevice: SIZEL,
    pub szlMillimeters: SIZEL,
}
#[test]
fn bindgen_test_layout_ENHMETAHEADER3() {
    assert_eq!(
        ::core::mem::size_of::<ENHMETAHEADER3>(),
        88usize,
        concat!("Size of: ", stringify!(ENHMETAHEADER3))
    );
    assert_eq!(
        ::core::mem::align_of::<ENHMETAHEADER3>(),
        4usize,
        concat!("Alignment of ", stringify!(ENHMETAHEADER3))
    );
    fn test_field_iType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).iType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(iType)
            )
        );
    }
    test_field_iType();
    fn test_field_nSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nSize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nSize)
            )
        );
    }
    test_field_nSize();
    fn test_field_rclBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rclBounds) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(rclBounds)
            )
        );
    }
    test_field_rclBounds();
    fn test_field_rclFrame() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rclFrame) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(rclFrame)
            )
        );
    }
    test_field_rclFrame();
    fn test_field_dSignature() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).dSignature) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(dSignature)
            )
        );
    }
    test_field_dSignature();
    fn test_field_nVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nVersion) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nVersion)
            )
        );
    }
    test_field_nVersion();
    fn test_field_nBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nBytes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nBytes)
            )
        );
    }
    test_field_nBytes();
    fn test_field_nRecords() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nRecords) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nRecords)
            )
        );
    }
    test_field_nRecords();
    fn test_field_nHandles() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nHandles) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nHandles)
            )
        );
    }
    test_field_nHandles();
    fn test_field_sReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sReserved) as usize - ptr as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(sReserved)
            )
        );
    }
    test_field_sReserved();
    fn test_field_nDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nDescription) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nDescription)
            )
        );
    }
    test_field_nDescription();
    fn test_field_offDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).offDescription) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(offDescription)
            )
        );
    }
    test_field_offDescription();
    fn test_field_nPalEntries() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nPalEntries) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nPalEntries)
            )
        );
    }
    test_field_nPalEntries();
    fn test_field_szlDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).szlDevice) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(szlDevice)
            )
        );
    }
    test_field_szlDevice();
    fn test_field_szlMillimeters() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).szlMillimeters) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(szlMillimeters)
            )
        );
    }
    test_field_szlMillimeters();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PWMFRect16 {
    pub Left: INT16,
    pub Top: INT16,
    pub Right: INT16,
    pub Bottom: INT16,
}
#[test]
fn bindgen_test_layout_PWMFRect16() {
    assert_eq!(
        ::core::mem::size_of::<PWMFRect16>(),
        8usize,
        concat!("Size of: ", stringify!(PWMFRect16))
    );
    assert_eq!(
        ::core::mem::align_of::<PWMFRect16>(),
        2usize,
        concat!("Alignment of ", stringify!(PWMFRect16))
    );
    fn test_field_Left() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Left)
            )
        );
    }
    test_field_Left();
    fn test_field_Top() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Top) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Top)
            )
        );
    }
    test_field_Top();
    fn test_field_Right() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Right) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Right)
            )
        );
    }
    test_field_Right();
    fn test_field_Bottom() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Bottom) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Bottom)
            )
        );
    }
    test_field_Bottom();
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct WmfPlaceableFileHeader {
    pub Key: UINT32,
    pub Hmf: INT16,
    pub BoundingBox: PWMFRect16,
    pub Inch: INT16,
    pub Reserved: UINT32,
    pub Checksum: INT16,
}
#[test]
fn bindgen_test_layout_WmfPlaceableFileHeader() {
    assert_eq!(
        ::core::mem::size_of::<WmfPlaceableFileHeader>(),
        22usize,
        concat!("Size of: ", stringify!(WmfPlaceableFileHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<WmfPlaceableFileHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(WmfPlaceableFileHeader))
    );
    fn test_field_Key() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Key)
            )
        );
    }
    test_field_Key();
    fn test_field_Hmf() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Hmf) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Hmf)
            )
        );
    }
    test_field_Hmf();
    fn test_field_BoundingBox() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).BoundingBox) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(BoundingBox)
            )
        );
    }
    test_field_BoundingBox();
    fn test_field_Inch() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Inch) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Inch)
            )
        );
    }
    test_field_Inch();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
    fn test_field_Checksum() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Checksum) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Checksum)
            )
        );
    }
    test_field_Checksum();
}
#[repr(C)]
pub struct MetafileHeader {
    pub Type: MetafileType,
    pub Size: UINT,
    pub Version: UINT,
    pub EmfPlusFlags: UINT,
    pub DpiX: REAL,
    pub DpiY: REAL,
    pub X: INT,
    pub Y: INT,
    pub Width: INT,
    pub Height: INT,
    pub __bindgen_anon_1: MetafileHeader__bindgen_ty_1,
    pub EmfPlusHeaderSize: INT,
    pub LogicalDpiX: INT,
    pub LogicalDpiY: INT,
}
#[repr(C)]
pub struct MetafileHeader__bindgen_ty_1 {
    pub WmfHeader: __BindgenUnionField<METAHEADER>,
    pub EmfHeader: __BindgenUnionField<ENHMETAHEADER3>,
    pub bindgen_union_field: [u32; 22usize],
}
#[test]
fn bindgen_test_layout_MetafileHeader__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MetafileHeader__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(MetafileHeader__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MetafileHeader__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MetafileHeader__bindgen_ty_1))
    );
    fn test_field_WmfHeader() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).WmfHeader) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader__bindgen_ty_1),
                "::",
                stringify!(WmfHeader)
            )
        );
    }
    test_field_WmfHeader();
    fn test_field_EmfHeader() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).EmfHeader) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader__bindgen_ty_1),
                "::",
                stringify!(EmfHeader)
            )
        );
    }
    test_field_EmfHeader();
}
#[test]
fn bindgen_test_layout_MetafileHeader() {
    assert_eq!(
        ::core::mem::size_of::<MetafileHeader>(),
        140usize,
        concat!("Size of: ", stringify!(MetafileHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<MetafileHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(MetafileHeader))
    );
    fn test_field_Type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Type)
            )
        );
    }
    test_field_Type();
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_EmfPlusFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).EmfPlusFlags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(EmfPlusFlags)
            )
        );
    }
    test_field_EmfPlusFlags();
    fn test_field_DpiX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DpiX) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(DpiX)
            )
        );
    }
    test_field_DpiX();
    fn test_field_DpiY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DpiY) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(DpiY)
            )
        );
    }
    test_field_DpiY();
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(X)
            )
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Y)
            )
        );
    }
    test_field_Y();
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_EmfPlusHeaderSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).EmfPlusHeaderSize) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(EmfPlusHeaderSize)
            )
        );
    }
    test_field_EmfPlusHeaderSize();
    fn test_field_LogicalDpiX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LogicalDpiX) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(LogicalDpiX)
            )
        );
    }
    test_field_LogicalDpiX();
    fn test_field_LogicalDpiY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LogicalDpiY) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(LogicalDpiY)
            )
        );
    }
    test_field_LogicalDpiY();
}
#[repr(C)]
pub struct ImageCodecInfo {
    pub Clsid: CLSID,
    pub FormatID: GUID,
    pub CodecName: *const WCHAR,
    pub DllName: *const WCHAR,
    pub FormatDescription: *const WCHAR,
    pub FilenameExtension: *const WCHAR,
    pub MimeType: *const WCHAR,
    pub Flags: DWORD,
    pub Version: DWORD,
    pub SigCount: DWORD,
    pub SigSize: DWORD,
    pub SigPattern: *const BYTE,
    pub SigMask: *const BYTE,
}
#[test]
fn bindgen_test_layout_ImageCodecInfo() {
    assert_eq!(
        ::core::mem::size_of::<ImageCodecInfo>(),
        104usize,
        concat!("Size of: ", stringify!(ImageCodecInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ImageCodecInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ImageCodecInfo))
    );
    fn test_field_Clsid() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Clsid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(Clsid)
            )
        );
    }
    test_field_Clsid();
    fn test_field_FormatID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).FormatID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(FormatID)
            )
        );
    }
    test_field_FormatID();
    fn test_field_CodecName() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).CodecName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(CodecName)
            )
        );
    }
    test_field_CodecName();
    fn test_field_DllName() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DllName) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(DllName)
            )
        );
    }
    test_field_DllName();
    fn test_field_FormatDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).FormatDescription) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(FormatDescription)
            )
        );
    }
    test_field_FormatDescription();
    fn test_field_FilenameExtension() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).FilenameExtension) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(FilenameExtension)
            )
        );
    }
    test_field_FilenameExtension();
    fn test_field_MimeType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).MimeType) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(MimeType)
            )
        );
    }
    test_field_MimeType();
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(Flags)
            )
        );
    }
    test_field_Flags();
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_SigCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigCount) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigCount)
            )
        );
    }
    test_field_SigCount();
    fn test_field_SigSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigSize) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigSize)
            )
        );
    }
    test_field_SigSize();
    fn test_field_SigPattern() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigPattern) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigPattern)
            )
        );
    }
    test_field_SigPattern();
    fn test_field_SigMask() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigMask) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigMask)
            )
        );
    }
    test_field_SigMask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapData {
    pub Width: UINT,
    pub Height: UINT,
    pub Stride: INT,
    pub PixelFormat: PixelFormat,
    pub Scan0: *mut ::core::ffi::c_void,
    pub Reserved: UINT_PTR,
}
#[test]
fn bindgen_test_layout_BitmapData() {
    assert_eq!(
        ::core::mem::size_of::<BitmapData>(),
        32usize,
        concat!("Size of: ", stringify!(BitmapData))
    );
    assert_eq!(
        ::core::mem::align_of::<BitmapData>(),
        8usize,
        concat!("Alignment of ", stringify!(BitmapData))
    );
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_Stride() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Stride) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Stride)
            )
        );
    }
    test_field_Stride();
    fn test_field_PixelFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).PixelFormat) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(PixelFormat)
            )
        );
    }
    test_field_PixelFormat();
    fn test_field_Scan0() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Scan0) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Scan0)
            )
        );
    }
    test_field_Scan0();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
}
pub const RotateFlipType_RotateNoneFlipNone: RotateFlipType = 0;
pub const RotateFlipType_Rotate90FlipNone: RotateFlipType = 1;
pub const RotateFlipType_Rotate180FlipNone: RotateFlipType = 2;
pub const RotateFlipType_Rotate270FlipNone: RotateFlipType = 3;
pub const RotateFlipType_RotateNoneFlipX: RotateFlipType = 4;
pub const RotateFlipType_Rotate90FlipX: RotateFlipType = 5;
pub const RotateFlipType_Rotate180FlipX: RotateFlipType = 6;
pub const RotateFlipType_Rotate270FlipX: RotateFlipType = 7;
pub const RotateFlipType_RotateNoneFlipY: RotateFlipType = 6;
pub const RotateFlipType_Rotate90FlipY: RotateFlipType = 7;
pub const RotateFlipType_Rotate180FlipY: RotateFlipType = 4;
pub const RotateFlipType_Rotate270FlipY: RotateFlipType = 5;
pub const RotateFlipType_RotateNoneFlipXY: RotateFlipType = 2;
pub const RotateFlipType_Rotate90FlipXY: RotateFlipType = 3;
pub const RotateFlipType_Rotate180FlipXY: RotateFlipType = 0;
pub const RotateFlipType_Rotate270FlipXY: RotateFlipType = 1;
pub type RotateFlipType = ::core::ffi::c_int;
#[repr(C)]
pub struct EncoderParameter {
    pub Guid: GUID,
    pub NumberOfValues: ULONG,
    pub Type: ULONG,
    pub Value: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_EncoderParameter() {
    assert_eq!(
        ::core::mem::size_of::<EncoderParameter>(),
        32usize,
        concat!("Size of: ", stringify!(EncoderParameter))
    );
    assert_eq!(
        ::core::mem::align_of::<EncoderParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(EncoderParameter))
    );
    fn test_field_Guid() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Guid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(Guid)
            )
        );
    }
    test_field_Guid();
    fn test_field_NumberOfValues() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).NumberOfValues) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(NumberOfValues)
            )
        );
    }
    test_field_NumberOfValues();
    fn test_field_Type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(Type)
            )
        );
    }
    test_field_Type();
    fn test_field_Value() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(Value)
            )
        );
    }
    test_field_Value();
}
#[repr(C)]
pub struct EncoderParameters {
    pub Count: UINT,
    pub Parameter: [EncoderParameter; 1usize],
}
#[test]
fn bindgen_test_layout_EncoderParameters() {
    assert_eq!(
        ::core::mem::size_of::<EncoderParameters>(),
        40usize,
        concat!("Size of: ", stringify!(EncoderParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<EncoderParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(EncoderParameters))
    );
    fn test_field_Count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameters),
                "::",
                stringify!(Count)
            )
        );
    }
    test_field_Count();
    fn test_field_Parameter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Parameter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameters),
                "::",
                stringify!(Parameter)
            )
        );
    }
    test_field_Parameter();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyItem {
    pub id: PROPID,
    pub length: ULONG,
    pub type_: WORD,
    pub value: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_PropertyItem() {
    assert_eq!(
        ::core::mem::size_of::<PropertyItem>(),
        24usize,
        concat!("Size of: ", stringify!(PropertyItem))
    );
    assert_eq!(
        ::core::mem::align_of::<PropertyItem>(),
        8usize,
        concat!("Alignment of ", stringify!(PropertyItem))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorMatrix {
    pub m: [[REAL; 5usize]; 5usize],
}
#[test]
fn bindgen_test_layout_ColorMatrix() {
    assert_eq!(
        ::core::mem::size_of::<ColorMatrix>(),
        100usize,
        concat!("Size of: ", stringify!(ColorMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<ColorMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorMatrix))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorMatrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorMatrix),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
pub const ColorMatrixFlags_ColorMatrixFlagsDefault: ColorMatrixFlags = 0;
pub const ColorMatrixFlags_ColorMatrixFlagsSkipGrays: ColorMatrixFlags = 1;
pub const ColorMatrixFlags_ColorMatrixFlagsAltGray: ColorMatrixFlags = 2;
pub type ColorMatrixFlags = ::core::ffi::c_int;
pub const ColorAdjustType_ColorAdjustTypeDefault: ColorAdjustType = 0;
pub const ColorAdjustType_ColorAdjustTypeBitmap: ColorAdjustType = 1;
pub const ColorAdjustType_ColorAdjustTypeBrush: ColorAdjustType = 2;
pub const ColorAdjustType_ColorAdjustTypePen: ColorAdjustType = 3;
pub const ColorAdjustType_ColorAdjustTypeText: ColorAdjustType = 4;
pub const ColorAdjustType_ColorAdjustTypeCount: ColorAdjustType = 5;
pub const ColorAdjustType_ColorAdjustTypeAny: ColorAdjustType = 6;
pub type ColorAdjustType = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorMap {
    pub oldColor: Color,
    pub newColor: Color,
}
#[test]
fn bindgen_test_layout_ColorMap() {
    assert_eq!(
        ::core::mem::size_of::<ColorMap>(),
        8usize,
        concat!("Size of: ", stringify!(ColorMap))
    );
    assert_eq!(
        ::core::mem::align_of::<ColorMap>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorMap))
    );
    fn test_field_oldColor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorMap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).oldColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorMap),
                "::",
                stringify!(oldColor)
            )
        );
    }
    test_field_oldColor();
    fn test_field_newColor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorMap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).newColor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorMap),
                "::",
                stringify!(newColor)
            )
        );
    }
    test_field_newColor();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpGraphics {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpGraphics() {
    assert_eq!(
        ::core::mem::size_of::<GpGraphics>(),
        1usize,
        concat!("Size of: ", stringify!(GpGraphics))
    );
    assert_eq!(
        ::core::mem::align_of::<GpGraphics>(),
        1usize,
        concat!("Alignment of ", stringify!(GpGraphics))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpBrush {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpBrush() {
    assert_eq!(
        ::core::mem::size_of::<GpBrush>(),
        1usize,
        concat!("Size of: ", stringify!(GpBrush))
    );
    assert_eq!(
        ::core::mem::align_of::<GpBrush>(),
        1usize,
        concat!("Alignment of ", stringify!(GpBrush))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpTexture {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpTexture() {
    assert_eq!(
        ::core::mem::size_of::<GpTexture>(),
        1usize,
        concat!("Size of: ", stringify!(GpTexture))
    );
    assert_eq!(
        ::core::mem::align_of::<GpTexture>(),
        1usize,
        concat!("Alignment of ", stringify!(GpTexture))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpSolidFill {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpSolidFill() {
    assert_eq!(
        ::core::mem::size_of::<GpSolidFill>(),
        1usize,
        concat!("Size of: ", stringify!(GpSolidFill))
    );
    assert_eq!(
        ::core::mem::align_of::<GpSolidFill>(),
        1usize,
        concat!("Alignment of ", stringify!(GpSolidFill))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpLineGradient {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpLineGradient() {
    assert_eq!(
        ::core::mem::size_of::<GpLineGradient>(),
        1usize,
        concat!("Size of: ", stringify!(GpLineGradient))
    );
    assert_eq!(
        ::core::mem::align_of::<GpLineGradient>(),
        1usize,
        concat!("Alignment of ", stringify!(GpLineGradient))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPathGradient {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPathGradient() {
    assert_eq!(
        ::core::mem::size_of::<GpPathGradient>(),
        1usize,
        concat!("Size of: ", stringify!(GpPathGradient))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPathGradient>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPathGradient))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpHatch {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpHatch() {
    assert_eq!(
        ::core::mem::size_of::<GpHatch>(),
        1usize,
        concat!("Size of: ", stringify!(GpHatch))
    );
    assert_eq!(
        ::core::mem::align_of::<GpHatch>(),
        1usize,
        concat!("Alignment of ", stringify!(GpHatch))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPen {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPen() {
    assert_eq!(
        ::core::mem::size_of::<GpPen>(),
        1usize,
        concat!("Size of: ", stringify!(GpPen))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPen>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPen))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpCustomLineCap {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpCustomLineCap() {
    assert_eq!(
        ::core::mem::size_of::<GpCustomLineCap>(),
        1usize,
        concat!("Size of: ", stringify!(GpCustomLineCap))
    );
    assert_eq!(
        ::core::mem::align_of::<GpCustomLineCap>(),
        1usize,
        concat!("Alignment of ", stringify!(GpCustomLineCap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpAdjustableArrowCap {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpAdjustableArrowCap() {
    assert_eq!(
        ::core::mem::size_of::<GpAdjustableArrowCap>(),
        1usize,
        concat!("Size of: ", stringify!(GpAdjustableArrowCap))
    );
    assert_eq!(
        ::core::mem::align_of::<GpAdjustableArrowCap>(),
        1usize,
        concat!("Alignment of ", stringify!(GpAdjustableArrowCap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpImage {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpImage() {
    assert_eq!(
        ::core::mem::size_of::<GpImage>(),
        1usize,
        concat!("Size of: ", stringify!(GpImage))
    );
    assert_eq!(
        ::core::mem::align_of::<GpImage>(),
        1usize,
        concat!("Alignment of ", stringify!(GpImage))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpBitmap {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpBitmap() {
    assert_eq!(
        ::core::mem::size_of::<GpBitmap>(),
        1usize,
        concat!("Size of: ", stringify!(GpBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<GpBitmap>(),
        1usize,
        concat!("Alignment of ", stringify!(GpBitmap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpMetafile {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpMetafile() {
    assert_eq!(
        ::core::mem::size_of::<GpMetafile>(),
        1usize,
        concat!("Size of: ", stringify!(GpMetafile))
    );
    assert_eq!(
        ::core::mem::align_of::<GpMetafile>(),
        1usize,
        concat!("Alignment of ", stringify!(GpMetafile))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpImageAttributes {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpImageAttributes() {
    assert_eq!(
        ::core::mem::size_of::<GpImageAttributes>(),
        1usize,
        concat!("Size of: ", stringify!(GpImageAttributes))
    );
    assert_eq!(
        ::core::mem::align_of::<GpImageAttributes>(),
        1usize,
        concat!("Alignment of ", stringify!(GpImageAttributes))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPath {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPath() {
    assert_eq!(
        ::core::mem::size_of::<GpPath>(),
        1usize,
        concat!("Size of: ", stringify!(GpPath))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPath>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPath))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpRegion {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpRegion() {
    assert_eq!(
        ::core::mem::size_of::<GpRegion>(),
        1usize,
        concat!("Size of: ", stringify!(GpRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<GpRegion>(),
        1usize,
        concat!("Alignment of ", stringify!(GpRegion))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPathIterator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPathIterator() {
    assert_eq!(
        ::core::mem::size_of::<GpPathIterator>(),
        1usize,
        concat!("Size of: ", stringify!(GpPathIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPathIterator>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPathIterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpFontFamily {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpFontFamily() {
    assert_eq!(
        ::core::mem::size_of::<GpFontFamily>(),
        1usize,
        concat!("Size of: ", stringify!(GpFontFamily))
    );
    assert_eq!(
        ::core::mem::align_of::<GpFontFamily>(),
        1usize,
        concat!("Alignment of ", stringify!(GpFontFamily))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpFont {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpFont() {
    assert_eq!(
        ::core::mem::size_of::<GpFont>(),
        1usize,
        concat!("Size of: ", stringify!(GpFont))
    );
    assert_eq!(
        ::core::mem::align_of::<GpFont>(),
        1usize,
        concat!("Alignment of ", stringify!(GpFont))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpStringFormat {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpStringFormat() {
    assert_eq!(
        ::core::mem::size_of::<GpStringFormat>(),
        1usize,
        concat!("Size of: ", stringify!(GpStringFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<GpStringFormat>(),
        1usize,
        concat!("Alignment of ", stringify!(GpStringFormat))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpFontCollection {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpFontCollection() {
    assert_eq!(
        ::core::mem::size_of::<GpFontCollection>(),
        1usize,
        concat!("Size of: ", stringify!(GpFontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<GpFontCollection>(),
        1usize,
        concat!("Alignment of ", stringify!(GpFontCollection))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpCachedBitmap {
    _unused: [u8; 0],
}
pub use self::CoordinateSpace as GpCoordinateSpace;
pub use self::FillMode as GpFillMode;
pub use self::Status as GpStatus;
pub use self::Unit as GpUnit;
pub use self::WrapMode as GpWrapMode;
pub type GpPointF = PointF;
pub type GpPoint = Point;
pub type GpRectF = RectF;
pub type GpRect = Rect;
pub use self::DashCap as GpDashCap;
pub use self::DashStyle as GpDashStyle;
pub use self::HatchStyle as GpHatchStyle;
pub use self::LineCap as GpLineCap;
pub use self::LineJoin as GpLineJoin;
pub use self::PenAlignment as GpPenAlignment;
pub use self::PenType as GpPenType;
pub type GpMatrix = Matrix;
pub use self::BrushType as GpBrushType;
pub use self::FlushIntention as GpFlushIntention;
pub use self::MatrixOrder as GpMatrixOrder;
pub type GpPathData = PathData;
#[repr(C)]
#[derive(Debug)]
pub struct Region {
    pub nativeRegion: *mut GpRegion,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Region() {
    assert_eq!(
        ::core::mem::size_of::<Region>(),
        16usize,
        concat!("Size of: ", stringify!(Region))
    );
    assert_eq!(
        ::core::mem::align_of::<Region>(),
        8usize,
        concat!("Alignment of ", stringify!(Region))
    );
    fn test_field_nativeRegion() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Region>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeRegion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Region),
                "::",
                stringify!(nativeRegion)
            )
        );
    }
    test_field_nativeRegion();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Region>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Region),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?FromHRGN@Region@Gdiplus@@SAPEAV12@PEAUHRGN__@@@Z"]
    pub fn Region_FromHRGN(hRgn: HRGN) -> *mut Region;
}
extern "C" {
    #[link_name = "\u{1}?Clone@Region@Gdiplus@@QEBAPEAV12@XZ"]
    pub fn Region_Clone(this: *const Region) -> *mut Region;
}
extern "C" {
    #[link_name = "\u{1}?MakeInfinite@Region@Gdiplus@@QEAA?AW4Status@2@XZ"]
    pub fn Region_MakeInfinite(this: *mut Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?MakeEmpty@Region@Gdiplus@@QEAA?AW4Status@2@XZ"]
    pub fn Region_MakeEmpty(this: *mut Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetDataSize@Region@Gdiplus@@QEBAIXZ"]
    pub fn Region_GetDataSize(this: *const Region) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetData@Region@Gdiplus@@QEBA?AW4Status@2@PEAEIPEAI@Z"]
    pub fn Region_GetData(
        this: *const Region,
        buffer: *mut BYTE,
        bufferSize: UINT,
        sizeFilled: *mut UINT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Intersect@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRect@2@@Z"]
    pub fn Region_Intersect(this: *mut Region, rect: *const Rect) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Intersect@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRectF@2@@Z"]
    pub fn Region_Intersect1(this: *mut Region, rect: *const RectF) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Intersect@Region@Gdiplus@@QEAA?AW4Status@2@PEBVGraphicsPath@2@@Z"]
    pub fn Region_Intersect2(this: *mut Region, path: *const GraphicsPath) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Intersect@Region@Gdiplus@@QEAA?AW4Status@2@PEBV12@@Z"]
    pub fn Region_Intersect3(this: *mut Region, region: *const Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Union@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRect@2@@Z"]
    pub fn Region_Union(this: *mut Region, rect: *const Rect) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Union@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRectF@2@@Z"]
    pub fn Region_Union1(this: *mut Region, rect: *const RectF) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Union@Region@Gdiplus@@QEAA?AW4Status@2@PEBVGraphicsPath@2@@Z"]
    pub fn Region_Union2(this: *mut Region, path: *const GraphicsPath) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Union@Region@Gdiplus@@QEAA?AW4Status@2@PEBV12@@Z"]
    pub fn Region_Union3(this: *mut Region, region: *const Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Xor@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRect@2@@Z"]
    pub fn Region_Xor(this: *mut Region, rect: *const Rect) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Xor@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRectF@2@@Z"]
    pub fn Region_Xor1(this: *mut Region, rect: *const RectF) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Xor@Region@Gdiplus@@QEAA?AW4Status@2@PEBVGraphicsPath@2@@Z"]
    pub fn Region_Xor2(this: *mut Region, path: *const GraphicsPath) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Xor@Region@Gdiplus@@QEAA?AW4Status@2@PEBV12@@Z"]
    pub fn Region_Xor3(this: *mut Region, region: *const Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Exclude@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRect@2@@Z"]
    pub fn Region_Exclude(this: *mut Region, rect: *const Rect) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Exclude@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRectF@2@@Z"]
    pub fn Region_Exclude1(this: *mut Region, rect: *const RectF) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Exclude@Region@Gdiplus@@QEAA?AW4Status@2@PEBVGraphicsPath@2@@Z"]
    pub fn Region_Exclude2(this: *mut Region, path: *const GraphicsPath) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Exclude@Region@Gdiplus@@QEAA?AW4Status@2@PEBV12@@Z"]
    pub fn Region_Exclude3(this: *mut Region, region: *const Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Complement@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRect@2@@Z"]
    pub fn Region_Complement(this: *mut Region, rect: *const Rect) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Complement@Region@Gdiplus@@QEAA?AW4Status@2@AEBVRectF@2@@Z"]
    pub fn Region_Complement1(this: *mut Region, rect: *const RectF) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Complement@Region@Gdiplus@@QEAA?AW4Status@2@PEBVGraphicsPath@2@@Z"]
    pub fn Region_Complement2(this: *mut Region, path: *const GraphicsPath) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Complement@Region@Gdiplus@@QEAA?AW4Status@2@PEBV12@@Z"]
    pub fn Region_Complement3(this: *mut Region, region: *const Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Translate@Region@Gdiplus@@QEAA?AW4Status@2@MM@Z"]
    pub fn Region_Translate(this: *mut Region, dx: REAL, dy: REAL) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Translate@Region@Gdiplus@@QEAA?AW4Status@2@HH@Z"]
    pub fn Region_Translate1(this: *mut Region, dx: INT, dy: INT) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Transform@Region@Gdiplus@@QEAA?AW4Status@2@PEBVMatrix@2@@Z"]
    pub fn Region_Transform(this: *mut Region, matrix: *const Matrix) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetBounds@Region@Gdiplus@@QEBA?AW4Status@2@PEAVRect@2@PEBVGraphics@2@@Z"]
    pub fn Region_GetBounds(this: *const Region, rect: *mut Rect, g: *const Graphics) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetBounds@Region@Gdiplus@@QEBA?AW4Status@2@PEAVRectF@2@PEBVGraphics@2@@Z"]
    pub fn Region_GetBounds1(this: *const Region, rect: *mut RectF, g: *const Graphics) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetHRGN@Region@Gdiplus@@QEBAPEAUHRGN__@@PEBVGraphics@2@@Z"]
    pub fn Region_GetHRGN(this: *const Region, g: *const Graphics) -> HRGN;
}
extern "C" {
    #[link_name = "\u{1}?IsEmpty@Region@Gdiplus@@QEBAHPEBVGraphics@2@@Z"]
    pub fn Region_IsEmpty(this: *const Region, g: *const Graphics) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsInfinite@Region@Gdiplus@@QEBAHPEBVGraphics@2@@Z"]
    pub fn Region_IsInfinite(this: *const Region, g: *const Graphics) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsVisible@Region@Gdiplus@@QEBAHAEBVPoint@2@PEBVGraphics@2@@Z"]
    pub fn Region_IsVisible(this: *const Region, point: *const Point, g: *const Graphics) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsVisible@Region@Gdiplus@@QEBAHAEBVPointF@2@PEBVGraphics@2@@Z"]
    pub fn Region_IsVisible1(this: *const Region, point: *const PointF, g: *const Graphics)
        -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsVisible@Region@Gdiplus@@QEBAHAEBVRect@2@PEBVGraphics@2@@Z"]
    pub fn Region_IsVisible2(this: *const Region, rect: *const Rect, g: *const Graphics) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsVisible@Region@Gdiplus@@QEBAHAEBVRectF@2@PEBVGraphics@2@@Z"]
    pub fn Region_IsVisible3(this: *const Region, rect: *const RectF, g: *const Graphics) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?Equals@Region@Gdiplus@@QEBAHPEBV12@PEBVGraphics@2@@Z"]
    pub fn Region_Equals(this: *const Region, region: *const Region, g: *const Graphics) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?GetRegionScansCount@Region@Gdiplus@@QEBAIPEBVMatrix@2@@Z"]
    pub fn Region_GetRegionScansCount(this: *const Region, matrix: *const Matrix) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetRegionScans@Region@Gdiplus@@QEBA?AW4Status@2@PEBVMatrix@2@PEAVRectF@2@PEAH@Z"]
    pub fn Region_GetRegionScans(
        this: *const Region,
        matrix: *const Matrix,
        rects: *mut RectF,
        count: *mut INT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetRegionScans@Region@Gdiplus@@QEBA?AW4Status@2@PEBVMatrix@2@PEAVRect@2@PEAH@Z"]
    pub fn Region_GetRegionScans1(
        this: *const Region,
        matrix: *const Matrix,
        rects: *mut Rect,
        count: *mut INT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@Region@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn Region_GetLastStatus(this: *const Region) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetNativeRegion@Region@Gdiplus@@IEAAXPEAVGpRegion@2@@Z"]
    pub fn Region_SetNativeRegion(this: *mut Region, nativeRegion: *mut GpRegion);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@QEAA@XZ"]
    pub fn Region_Region(this: *mut Region);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@QEAA@AEBVRectF@1@@Z"]
    pub fn Region_Region1(this: *mut Region, rect: *const RectF);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@QEAA@AEBVRect@1@@Z"]
    pub fn Region_Region2(this: *mut Region, rect: *const Rect);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@QEAA@PEBVGraphicsPath@1@@Z"]
    pub fn Region_Region3(this: *mut Region, path: *const GraphicsPath);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@QEAA@PEBEH@Z"]
    pub fn Region_Region4(this: *mut Region, regionData: *const BYTE, size: INT);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@QEAA@PEAUHRGN__@@@Z"]
    pub fn Region_Region5(this: *mut Region, hRgn: HRGN);
}
extern "C" {
    #[link_name = "\u{1}??0Region@Gdiplus@@IEAA@PEAVGpRegion@1@@Z"]
    pub fn Region_Region6(this: *mut Region, nativeRegion: *mut GpRegion);
}
extern "C" {
    #[link_name = "\u{1}??_DRegion@Gdiplus@@QEAAXXZ"]
    pub fn Region_Region_destructor(this: *mut Region);
}
impl Region {
    #[inline]
    pub unsafe fn FromHRGN(hRgn: HRGN) -> *mut Region {
        Region_FromHRGN(hRgn)
    }
    #[inline]
    pub unsafe fn Clone(&self) -> *mut Region {
        Region_Clone(self)
    }
    #[inline]
    pub unsafe fn MakeInfinite(&mut self) -> Status {
        Region_MakeInfinite(self)
    }
    #[inline]
    pub unsafe fn MakeEmpty(&mut self) -> Status {
        Region_MakeEmpty(self)
    }
    #[inline]
    pub unsafe fn GetDataSize(&self) -> UINT {
        Region_GetDataSize(self)
    }
    #[inline]
    pub unsafe fn GetData(
        &self,
        buffer: *mut BYTE,
        bufferSize: UINT,
        sizeFilled: *mut UINT,
    ) -> Status {
        Region_GetData(self, buffer, bufferSize, sizeFilled)
    }
    #[inline]
    pub unsafe fn Intersect(&mut self, rect: *const Rect) -> Status {
        Region_Intersect(self, rect)
    }
    #[inline]
    pub unsafe fn Intersect1(&mut self, rect: *const RectF) -> Status {
        Region_Intersect1(self, rect)
    }
    #[inline]
    pub unsafe fn Intersect2(&mut self, path: *const GraphicsPath) -> Status {
        Region_Intersect2(self, path)
    }
    #[inline]
    pub unsafe fn Intersect3(&mut self, region: *const Region) -> Status {
        Region_Intersect3(self, region)
    }
    #[inline]
    pub unsafe fn Union(&mut self, rect: *const Rect) -> Status {
        Region_Union(self, rect)
    }
    #[inline]
    pub unsafe fn Union1(&mut self, rect: *const RectF) -> Status {
        Region_Union1(self, rect)
    }
    #[inline]
    pub unsafe fn Union2(&mut self, path: *const GraphicsPath) -> Status {
        Region_Union2(self, path)
    }
    #[inline]
    pub unsafe fn Union3(&mut self, region: *const Region) -> Status {
        Region_Union3(self, region)
    }
    #[inline]
    pub unsafe fn Xor(&mut self, rect: *const Rect) -> Status {
        Region_Xor(self, rect)
    }
    #[inline]
    pub unsafe fn Xor1(&mut self, rect: *const RectF) -> Status {
        Region_Xor1(self, rect)
    }
    #[inline]
    pub unsafe fn Xor2(&mut self, path: *const GraphicsPath) -> Status {
        Region_Xor2(self, path)
    }
    #[inline]
    pub unsafe fn Xor3(&mut self, region: *const Region) -> Status {
        Region_Xor3(self, region)
    }
    #[inline]
    pub unsafe fn Exclude(&mut self, rect: *const Rect) -> Status {
        Region_Exclude(self, rect)
    }
    #[inline]
    pub unsafe fn Exclude1(&mut self, rect: *const RectF) -> Status {
        Region_Exclude1(self, rect)
    }
    #[inline]
    pub unsafe fn Exclude2(&mut self, path: *const GraphicsPath) -> Status {
        Region_Exclude2(self, path)
    }
    #[inline]
    pub unsafe fn Exclude3(&mut self, region: *const Region) -> Status {
        Region_Exclude3(self, region)
    }
    #[inline]
    pub unsafe fn Complement(&mut self, rect: *const Rect) -> Status {
        Region_Complement(self, rect)
    }
    #[inline]
    pub unsafe fn Complement1(&mut self, rect: *const RectF) -> Status {
        Region_Complement1(self, rect)
    }
    #[inline]
    pub unsafe fn Complement2(&mut self, path: *const GraphicsPath) -> Status {
        Region_Complement2(self, path)
    }
    #[inline]
    pub unsafe fn Complement3(&mut self, region: *const Region) -> Status {
        Region_Complement3(self, region)
    }
    #[inline]
    pub unsafe fn Translate(&mut self, dx: REAL, dy: REAL) -> Status {
        Region_Translate(self, dx, dy)
    }
    #[inline]
    pub unsafe fn Translate1(&mut self, dx: INT, dy: INT) -> Status {
        Region_Translate1(self, dx, dy)
    }
    #[inline]
    pub unsafe fn Transform(&mut self, matrix: *const Matrix) -> Status {
        Region_Transform(self, matrix)
    }
    #[inline]
    pub unsafe fn GetBounds(&self, rect: *mut Rect, g: *const Graphics) -> Status {
        Region_GetBounds(self, rect, g)
    }
    #[inline]
    pub unsafe fn GetBounds1(&self, rect: *mut RectF, g: *const Graphics) -> Status {
        Region_GetBounds1(self, rect, g)
    }
    #[inline]
    pub unsafe fn GetHRGN(&self, g: *const Graphics) -> HRGN {
        Region_GetHRGN(self, g)
    }
    #[inline]
    pub unsafe fn IsEmpty(&self, g: *const Graphics) -> BOOL {
        Region_IsEmpty(self, g)
    }
    #[inline]
    pub unsafe fn IsInfinite(&self, g: *const Graphics) -> BOOL {
        Region_IsInfinite(self, g)
    }
    #[inline]
    pub unsafe fn IsVisible(&self, point: *const Point, g: *const Graphics) -> BOOL {
        Region_IsVisible(self, point, g)
    }
    #[inline]
    pub unsafe fn IsVisible1(&self, point: *const PointF, g: *const Graphics) -> BOOL {
        Region_IsVisible1(self, point, g)
    }
    #[inline]
    pub unsafe fn IsVisible2(&self, rect: *const Rect, g: *const Graphics) -> BOOL {
        Region_IsVisible2(self, rect, g)
    }
    #[inline]
    pub unsafe fn IsVisible3(&self, rect: *const RectF, g: *const Graphics) -> BOOL {
        Region_IsVisible3(self, rect, g)
    }
    #[inline]
    pub unsafe fn Equals(&self, region: *const Region, g: *const Graphics) -> BOOL {
        Region_Equals(self, region, g)
    }
    #[inline]
    pub unsafe fn GetRegionScansCount(&self, matrix: *const Matrix) -> UINT {
        Region_GetRegionScansCount(self, matrix)
    }
    #[inline]
    pub unsafe fn GetRegionScans(
        &self,
        matrix: *const Matrix,
        rects: *mut RectF,
        count: *mut INT,
    ) -> Status {
        Region_GetRegionScans(self, matrix, rects, count)
    }
    #[inline]
    pub unsafe fn GetRegionScans1(
        &self,
        matrix: *const Matrix,
        rects: *mut Rect,
        count: *mut INT,
    ) -> Status {
        Region_GetRegionScans1(self, matrix, rects, count)
    }
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        Region_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn SetNativeRegion(&mut self, nativeRegion: *mut GpRegion) {
        Region_SetNativeRegion(self, nativeRegion)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rect: *const RectF) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region1(__bindgen_tmp.as_mut_ptr(), rect);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rect: *const Rect) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region2(__bindgen_tmp.as_mut_ptr(), rect);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(path: *const GraphicsPath) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region3(__bindgen_tmp.as_mut_ptr(), path);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(regionData: *const BYTE, size: INT) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region4(__bindgen_tmp.as_mut_ptr(), regionData, size);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(hRgn: HRGN) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region5(__bindgen_tmp.as_mut_ptr(), hRgn);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(nativeRegion: *mut GpRegion) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Region_Region6(__bindgen_tmp.as_mut_ptr(), nativeRegion);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Region_Region_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FontFamily {
    pub nativeFamily: *mut GpFontFamily,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_FontFamily() {
    assert_eq!(
        ::core::mem::size_of::<FontFamily>(),
        16usize,
        concat!("Size of: ", stringify!(FontFamily))
    );
    assert_eq!(
        ::core::mem::align_of::<FontFamily>(),
        8usize,
        concat!("Alignment of ", stringify!(FontFamily))
    );
    fn test_field_nativeFamily() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontFamily>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFamily) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(FontFamily),
                "::",
                stringify!(nativeFamily)
            )
        );
    }
    test_field_nativeFamily();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontFamily>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(FontFamily),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?GenericSansSerif@FontFamily@Gdiplus@@SAPEBV12@XZ"]
    pub fn FontFamily_GenericSansSerif() -> *const FontFamily;
}
extern "C" {
    #[link_name = "\u{1}?GenericSerif@FontFamily@Gdiplus@@SAPEBV12@XZ"]
    pub fn FontFamily_GenericSerif() -> *const FontFamily;
}
extern "C" {
    #[link_name = "\u{1}?GenericMonospace@FontFamily@Gdiplus@@SAPEBV12@XZ"]
    pub fn FontFamily_GenericMonospace() -> *const FontFamily;
}
extern "C" {
    #[link_name = "\u{1}?GetFamilyName@FontFamily@Gdiplus@@QEBA?AW4Status@2@PEA_WG@Z"]
    pub fn FontFamily_GetFamilyName(
        this: *const FontFamily,
        name: LPWSTR,
        language: LANGID,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Clone@FontFamily@Gdiplus@@QEBAPEAV12@XZ"]
    pub fn FontFamily_Clone(this: *const FontFamily) -> *mut FontFamily;
}
extern "C" {
    #[link_name = "\u{1}?IsStyleAvailable@FontFamily@Gdiplus@@QEBAHH@Z"]
    pub fn FontFamily_IsStyleAvailable(this: *const FontFamily, style: INT) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?GetEmHeight@FontFamily@Gdiplus@@QEBAGH@Z"]
    pub fn FontFamily_GetEmHeight(this: *const FontFamily, style: INT) -> UINT16;
}
extern "C" {
    #[link_name = "\u{1}?GetCellAscent@FontFamily@Gdiplus@@QEBAGH@Z"]
    pub fn FontFamily_GetCellAscent(this: *const FontFamily, style: INT) -> UINT16;
}
extern "C" {
    #[link_name = "\u{1}?GetCellDescent@FontFamily@Gdiplus@@QEBAGH@Z"]
    pub fn FontFamily_GetCellDescent(this: *const FontFamily, style: INT) -> UINT16;
}
extern "C" {
    #[link_name = "\u{1}?GetLineSpacing@FontFamily@Gdiplus@@QEBAGH@Z"]
    pub fn FontFamily_GetLineSpacing(this: *const FontFamily, style: INT) -> UINT16;
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@FontFamily@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn FontFamily_GetLastStatus(this: *const FontFamily) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetStatus@FontFamily@Gdiplus@@IEBA?AW4Status@2@W432@@Z"]
    pub fn FontFamily_SetStatus(this: *const FontFamily, status: Status) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0FontFamily@Gdiplus@@QEAA@XZ"]
    pub fn FontFamily_FontFamily(this: *mut FontFamily);
}
extern "C" {
    #[link_name = "\u{1}??0FontFamily@Gdiplus@@QEAA@PEB_WPEBVFontCollection@1@@Z"]
    pub fn FontFamily_FontFamily1(
        this: *mut FontFamily,
        name: *const WCHAR,
        fontCollection: *const FontCollection,
    );
}
extern "C" {
    #[link_name = "\u{1}??0FontFamily@Gdiplus@@IEAA@PEAVGpFontFamily@1@W4Status@1@@Z"]
    pub fn FontFamily_FontFamily2(
        this: *mut FontFamily,
        nativeFamily: *mut GpFontFamily,
        status: Status,
    );
}
extern "C" {
    #[link_name = "\u{1}??_DFontFamily@Gdiplus@@QEAAXXZ"]
    pub fn FontFamily_FontFamily_destructor(this: *mut FontFamily);
}
impl FontFamily {
    #[inline]
    pub unsafe fn GenericSansSerif() -> *const FontFamily {
        FontFamily_GenericSansSerif()
    }
    #[inline]
    pub unsafe fn GenericSerif() -> *const FontFamily {
        FontFamily_GenericSerif()
    }
    #[inline]
    pub unsafe fn GenericMonospace() -> *const FontFamily {
        FontFamily_GenericMonospace()
    }
    #[inline]
    pub unsafe fn GetFamilyName(&self, name: LPWSTR, language: LANGID) -> Status {
        FontFamily_GetFamilyName(self, name, language)
    }
    #[inline]
    pub unsafe fn Clone(&self) -> *mut FontFamily {
        FontFamily_Clone(self)
    }
    #[inline]
    pub unsafe fn IsStyleAvailable(&self, style: INT) -> BOOL {
        FontFamily_IsStyleAvailable(self, style)
    }
    #[inline]
    pub unsafe fn GetEmHeight(&self, style: INT) -> UINT16 {
        FontFamily_GetEmHeight(self, style)
    }
    #[inline]
    pub unsafe fn GetCellAscent(&self, style: INT) -> UINT16 {
        FontFamily_GetCellAscent(self, style)
    }
    #[inline]
    pub unsafe fn GetCellDescent(&self, style: INT) -> UINT16 {
        FontFamily_GetCellDescent(self, style)
    }
    #[inline]
    pub unsafe fn GetLineSpacing(&self, style: INT) -> UINT16 {
        FontFamily_GetLineSpacing(self, style)
    }
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        FontFamily_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn SetStatus(&self, status: Status) -> Status {
        FontFamily_SetStatus(self, status)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        FontFamily_FontFamily(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(name: *const WCHAR, fontCollection: *const FontCollection) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        FontFamily_FontFamily1(__bindgen_tmp.as_mut_ptr(), name, fontCollection);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(nativeFamily: *mut GpFontFamily, status: Status) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        FontFamily_FontFamily2(__bindgen_tmp.as_mut_ptr(), nativeFamily, status);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        FontFamily_FontFamily_destructor(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Font {
    pub nativeFont: *mut GpFont,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Font() {
    assert_eq!(
        ::core::mem::size_of::<Font>(),
        16usize,
        concat!("Size of: ", stringify!(Font))
    );
    assert_eq!(
        ::core::mem::align_of::<Font>(),
        8usize,
        concat!("Alignment of ", stringify!(Font))
    );
    fn test_field_nativeFont() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Font>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFont) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Font),
                "::",
                stringify!(nativeFont)
            )
        );
    }
    test_field_nativeFont();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Font>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Font),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?GetLogFontA@Font@Gdiplus@@QEBA?AW4Status@2@PEBVGraphics@2@PEAUtagLOGFONTA@@@Z"]
    pub fn Font_GetLogFontA(
        this: *const Font,
        g: *const Graphics,
        logfontA: *mut LOGFONTA,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetLogFontW@Font@Gdiplus@@QEBA?AW4Status@2@PEBVGraphics@2@PEAUtagLOGFONTW@@@Z"]
    pub fn Font_GetLogFontW(
        this: *const Font,
        g: *const Graphics,
        logfontW: *mut LOGFONTW,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Clone@Font@Gdiplus@@QEBAPEAV12@XZ"]
    pub fn Font_Clone(this: *const Font) -> *mut Font;
}
extern "C" {
    #[link_name = "\u{1}?IsAvailable@Font@Gdiplus@@QEBAHXZ"]
    pub fn Font_IsAvailable(this: *const Font) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?GetStyle@Font@Gdiplus@@QEBAHXZ"]
    pub fn Font_GetStyle(this: *const Font) -> INT;
}
extern "C" {
    #[link_name = "\u{1}?GetSize@Font@Gdiplus@@QEBAMXZ"]
    pub fn Font_GetSize(this: *const Font) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?GetUnit@Font@Gdiplus@@QEBA?AW4Unit@2@XZ"]
    pub fn Font_GetUnit(this: *const Font) -> Unit;
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@Font@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn Font_GetLastStatus(this: *const Font) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetHeight@Font@Gdiplus@@QEBAMPEBVGraphics@2@@Z"]
    pub fn Font_GetHeight(this: *const Font, graphics: *const Graphics) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?GetHeight@Font@Gdiplus@@QEBAMM@Z"]
    pub fn Font_GetHeight1(this: *const Font, dpi: REAL) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?GetFamily@Font@Gdiplus@@QEBA?AW4Status@2@PEAVFontFamily@2@@Z"]
    pub fn Font_GetFamily(this: *const Font, family: *mut FontFamily) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetNativeFont@Font@Gdiplus@@IEAAXPEAVGpFont@2@@Z"]
    pub fn Font_SetNativeFont(this: *mut Font, Font: *mut GpFont);
}
extern "C" {
    #[link_name = "\u{1}?SetStatus@Font@Gdiplus@@IEBA?AW4Status@2@W432@@Z"]
    pub fn Font_SetStatus(this: *const Font, status: Status) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@QEAA@PEAUHDC__@@@Z"]
    pub fn Font_Font(this: *mut Font, hdc: HDC);
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@QEAA@PEAUHDC__@@PEBUtagLOGFONTA@@@Z"]
    pub fn Font_Font1(this: *mut Font, hdc: HDC, logfont: *const LOGFONTA);
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@QEAA@PEAUHDC__@@PEBUtagLOGFONTW@@@Z"]
    pub fn Font_Font2(this: *mut Font, hdc: HDC, logfont: *const LOGFONTW);
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@QEAA@PEAUHDC__@@QEAUHFONT__@@@Z"]
    pub fn Font_Font3(this: *mut Font, hdc: HDC, hfont: HFONT);
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@QEAA@PEBVFontFamily@1@MHW4Unit@1@@Z"]
    pub fn Font_Font4(
        this: *mut Font,
        family: *const FontFamily,
        emSize: REAL,
        style: INT,
        unit: Unit,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@QEAA@PEB_WMHW4Unit@1@PEBVFontCollection@1@@Z"]
    pub fn Font_Font5(
        this: *mut Font,
        familyName: *const WCHAR,
        emSize: REAL,
        style: INT,
        unit: Unit,
        fontCollection: *const FontCollection,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Font@Gdiplus@@IEAA@PEAVGpFont@1@W4Status@1@@Z"]
    pub fn Font_Font6(this: *mut Font, font: *mut GpFont, status: Status);
}
extern "C" {
    #[link_name = "\u{1}??_DFont@Gdiplus@@QEAAXXZ"]
    pub fn Font_Font_destructor(this: *mut Font);
}
impl Font {
    #[inline]
    pub unsafe fn GetLogFontA(&self, g: *const Graphics, logfontA: *mut LOGFONTA) -> Status {
        Font_GetLogFontA(self, g, logfontA)
    }
    #[inline]
    pub unsafe fn GetLogFontW(&self, g: *const Graphics, logfontW: *mut LOGFONTW) -> Status {
        Font_GetLogFontW(self, g, logfontW)
    }
    #[inline]
    pub unsafe fn Clone(&self) -> *mut Font {
        Font_Clone(self)
    }
    #[inline]
    pub unsafe fn IsAvailable(&self) -> BOOL {
        Font_IsAvailable(self)
    }
    #[inline]
    pub unsafe fn GetStyle(&self) -> INT {
        Font_GetStyle(self)
    }
    #[inline]
    pub unsafe fn GetSize(&self) -> REAL {
        Font_GetSize(self)
    }
    #[inline]
    pub unsafe fn GetUnit(&self) -> Unit {
        Font_GetUnit(self)
    }
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        Font_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn GetHeight(&self, graphics: *const Graphics) -> REAL {
        Font_GetHeight(self, graphics)
    }
    #[inline]
    pub unsafe fn GetHeight1(&self, dpi: REAL) -> REAL {
        Font_GetHeight1(self, dpi)
    }
    #[inline]
    pub unsafe fn GetFamily(&self, family: *mut FontFamily) -> Status {
        Font_GetFamily(self, family)
    }
    #[inline]
    pub unsafe fn SetNativeFont(&mut self, Font: *mut GpFont) {
        Font_SetNativeFont(self, Font)
    }
    #[inline]
    pub unsafe fn SetStatus(&self, status: Status) -> Status {
        Font_SetStatus(self, status)
    }
    #[inline]
    pub unsafe fn new(hdc: HDC) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font(__bindgen_tmp.as_mut_ptr(), hdc);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(hdc: HDC, logfont: *const LOGFONTA) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font1(__bindgen_tmp.as_mut_ptr(), hdc, logfont);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(hdc: HDC, logfont: *const LOGFONTW) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font2(__bindgen_tmp.as_mut_ptr(), hdc, logfont);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(hdc: HDC, hfont: HFONT) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font3(__bindgen_tmp.as_mut_ptr(), hdc, hfont);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(family: *const FontFamily, emSize: REAL, style: INT, unit: Unit) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font4(__bindgen_tmp.as_mut_ptr(), family, emSize, style, unit);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(
        familyName: *const WCHAR,
        emSize: REAL,
        style: INT,
        unit: Unit,
        fontCollection: *const FontCollection,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font5(
            __bindgen_tmp.as_mut_ptr(),
            familyName,
            emSize,
            style,
            unit,
            fontCollection,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(font: *mut GpFont, status: Status) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Font_Font6(__bindgen_tmp.as_mut_ptr(), font, status);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        Font_Font_destructor(self)
    }
}
#[repr(C)]
pub struct FontCollection__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct FontCollection {
    pub vtable_: *const FontCollection__bindgen_vtable,
    pub nativeFontCollection: *mut GpFontCollection,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_FontCollection() {
    assert_eq!(
        ::core::mem::size_of::<FontCollection>(),
        24usize,
        concat!("Size of: ", stringify!(FontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<FontCollection>(),
        8usize,
        concat!("Alignment of ", stringify!(FontCollection))
    );
    fn test_field_nativeFontCollection() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontCollection>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFontCollection) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(FontCollection),
                "::",
                stringify!(nativeFontCollection)
            )
        );
    }
    test_field_nativeFontCollection();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontCollection>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(FontCollection),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?GetFamilyCount@FontCollection@Gdiplus@@QEBAHXZ"]
    pub fn FontCollection_GetFamilyCount(this: *const FontCollection) -> INT;
}
extern "C" {
    #[link_name = "\u{1}?GetFamilies@FontCollection@Gdiplus@@QEBA?AW4Status@2@HPEAVFontFamily@2@PEAH@Z"]
    pub fn FontCollection_GetFamilies(
        this: *const FontCollection,
        numSought: INT,
        gpfamilies: *mut FontFamily,
        numFound: *mut INT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@FontCollection@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn FontCollection_GetLastStatus(this: *const FontCollection) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetStatus@FontCollection@Gdiplus@@IEBA?AW4Status@2@W432@@Z"]
    pub fn FontCollection_SetStatus(this: *const FontCollection, status: Status) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0FontCollection@Gdiplus@@QEAA@XZ"]
    pub fn FontCollection_FontCollection(this: *mut FontCollection);
}
impl FontCollection {
    #[inline]
    pub unsafe fn GetFamilyCount(&self) -> INT {
        FontCollection_GetFamilyCount(self)
    }
    #[inline]
    pub unsafe fn GetFamilies(
        &self,
        numSought: INT,
        gpfamilies: *mut FontFamily,
        numFound: *mut INT,
    ) -> Status {
        FontCollection_GetFamilies(self, numSought, gpfamilies, numFound)
    }
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        FontCollection_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn SetStatus(&self, status: Status) -> Status {
        FontCollection_SetStatus(self, status)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        FontCollection_FontCollection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DFontCollection@Gdiplus@@QEAAXXZ"]
    pub fn FontCollection_FontCollection_destructor(this: *mut FontCollection);
}
#[repr(C)]
#[derive(Debug)]
pub struct InstalledFontCollection {
    pub _base: FontCollection,
}
#[test]
fn bindgen_test_layout_InstalledFontCollection() {
    assert_eq!(
        ::core::mem::size_of::<InstalledFontCollection>(),
        24usize,
        concat!("Size of: ", stringify!(InstalledFontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<InstalledFontCollection>(),
        8usize,
        concat!("Alignment of ", stringify!(InstalledFontCollection))
    );
}
extern "C" {
    #[link_name = "\u{1}?SetStatus@InstalledFontCollection@Gdiplus@@IEBA?AW4Status@2@W432@@Z"]
    pub fn InstalledFontCollection_SetStatus(
        this: *const InstalledFontCollection,
        status: Status,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0InstalledFontCollection@Gdiplus@@QEAA@XZ"]
    pub fn InstalledFontCollection_InstalledFontCollection(this: *mut InstalledFontCollection);
}
impl InstalledFontCollection {
    #[inline]
    pub unsafe fn SetStatus(&self, status: Status) -> Status {
        InstalledFontCollection_SetStatus(self, status)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        InstalledFontCollection_InstalledFontCollection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DInstalledFontCollection@Gdiplus@@QEAAXXZ"]
    pub fn InstalledFontCollection_InstalledFontCollection_destructor(
        this: *mut InstalledFontCollection,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct PrivateFontCollection {
    pub _base: FontCollection,
}
#[test]
fn bindgen_test_layout_PrivateFontCollection() {
    assert_eq!(
        ::core::mem::size_of::<PrivateFontCollection>(),
        24usize,
        concat!("Size of: ", stringify!(PrivateFontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<PrivateFontCollection>(),
        8usize,
        concat!("Alignment of ", stringify!(PrivateFontCollection))
    );
}
extern "C" {
    #[link_name = "\u{1}?AddFontFile@PrivateFontCollection@Gdiplus@@QEAA?AW4Status@2@PEB_W@Z"]
    pub fn PrivateFontCollection_AddFontFile(
        this: *mut PrivateFontCollection,
        filename: *const WCHAR,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?AddMemoryFont@PrivateFontCollection@Gdiplus@@QEAA?AW4Status@2@PEBXH@Z"]
    pub fn PrivateFontCollection_AddMemoryFont(
        this: *mut PrivateFontCollection,
        memory: *const ::core::ffi::c_void,
        length: INT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0PrivateFontCollection@Gdiplus@@QEAA@XZ"]
    pub fn PrivateFontCollection_PrivateFontCollection(this: *mut PrivateFontCollection);
}
impl PrivateFontCollection {
    #[inline]
    pub unsafe fn AddFontFile(&mut self, filename: *const WCHAR) -> Status {
        PrivateFontCollection_AddFontFile(self, filename)
    }
    #[inline]
    pub unsafe fn AddMemoryFont(
        &mut self,
        memory: *const ::core::ffi::c_void,
        length: INT,
    ) -> Status {
        PrivateFontCollection_AddMemoryFont(self, memory, length)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        PrivateFontCollection_PrivateFontCollection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DPrivateFontCollection@Gdiplus@@QEAAXXZ"]
    pub fn PrivateFontCollection_PrivateFontCollection_destructor(this: *mut PrivateFontCollection);
}
#[repr(C)]
pub struct Image__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Image {
    pub vtable_: *const Image__bindgen_vtable,
    pub nativeImage: *mut GpImage,
    pub lastResult: Status,
    pub loadStatus: Status,
}
#[test]
fn bindgen_test_layout_Image() {
    assert_eq!(
        ::core::mem::size_of::<Image>(),
        24usize,
        concat!("Size of: ", stringify!(Image))
    );
    assert_eq!(
        ::core::mem::align_of::<Image>(),
        8usize,
        concat!("Alignment of ", stringify!(Image))
    );
    fn test_field_nativeImage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Image>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeImage) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Image),
                "::",
                stringify!(nativeImage)
            )
        );
    }
    test_field_nativeImage();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Image>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(Image),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
    fn test_field_loadStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Image>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).loadStatus) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(Image),
                "::",
                stringify!(loadStatus)
            )
        );
    }
    test_field_loadStatus();
}
extern "C" {
    #[link_name = "\u{1}?FromFile@Image@Gdiplus@@SAPEAV12@PEB_WH@Z"]
    pub fn Image_FromFile(filename: *const WCHAR, useEmbeddedColorManagement: BOOL) -> *mut Image;
}
extern "C" {
    #[link_name = "\u{1}?FromStream@Image@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z"]
    pub fn Image_FromStream(stream: *mut IStream, useEmbeddedColorManagement: BOOL) -> *mut Image;
}
extern "C" {
    #[link_name = "\u{1}?Save@Image@Gdiplus@@QEAA?AW4Status@2@PEB_WPEBU_GUID@@PEBVEncoderParameters@2@@Z"]
    pub fn Image_Save(
        this: *mut Image,
        filename: *const WCHAR,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?Save@Image@Gdiplus@@QEAA?AW4Status@2@PEAUIStream@@PEBU_GUID@@PEBVEncoderParameters@2@@Z"]
    pub fn Image_Save1(
        this: *mut Image,
        stream: *mut IStream,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SaveAdd@Image@Gdiplus@@QEAA?AW4Status@2@PEBVEncoderParameters@2@@Z"]
    pub fn Image_SaveAdd(this: *mut Image, encoderParams: *const EncoderParameters) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SaveAdd@Image@Gdiplus@@QEAA?AW4Status@2@PEAV12@PEBVEncoderParameters@2@@Z"]
    pub fn Image_SaveAdd1(
        this: *mut Image,
        newImage: *mut Image,
        encoderParams: *const EncoderParameters,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetType@Image@Gdiplus@@QEBA?AW4ImageType@2@XZ"]
    pub fn Image_GetType(this: *const Image) -> ImageType;
}
extern "C" {
    #[link_name = "\u{1}?GetPhysicalDimension@Image@Gdiplus@@QEAA?AW4Status@2@PEAVSizeF@2@@Z"]
    pub fn Image_GetPhysicalDimension(this: *mut Image, size: *mut SizeF) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetBounds@Image@Gdiplus@@QEAA?AW4Status@2@PEAVRectF@2@PEAW4Unit@2@@Z"]
    pub fn Image_GetBounds(this: *mut Image, srcRect: *mut RectF, srcUnit: *mut Unit) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetWidth@Image@Gdiplus@@QEAAIXZ"]
    pub fn Image_GetWidth(this: *mut Image) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetHeight@Image@Gdiplus@@QEAAIXZ"]
    pub fn Image_GetHeight(this: *mut Image) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetHorizontalResolution@Image@Gdiplus@@QEAAMXZ"]
    pub fn Image_GetHorizontalResolution(this: *mut Image) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?GetVerticalResolution@Image@Gdiplus@@QEAAMXZ"]
    pub fn Image_GetVerticalResolution(this: *mut Image) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?GetFlags@Image@Gdiplus@@QEAAIXZ"]
    pub fn Image_GetFlags(this: *mut Image) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetRawFormat@Image@Gdiplus@@QEAA?AW4Status@2@PEAU_GUID@@@Z"]
    pub fn Image_GetRawFormat(this: *mut Image, format: *mut GUID) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetPixelFormat@Image@Gdiplus@@QEAAHXZ"]
    pub fn Image_GetPixelFormat(this: *mut Image) -> PixelFormat;
}
extern "C" {
    #[link_name = "\u{1}?GetPaletteSize@Image@Gdiplus@@QEAAHXZ"]
    pub fn Image_GetPaletteSize(this: *mut Image) -> INT;
}
extern "C" {
    #[link_name = "\u{1}?GetPalette@Image@Gdiplus@@QEAA?AW4Status@2@PEAUColorPalette@2@H@Z"]
    pub fn Image_GetPalette(this: *mut Image, palette: *mut ColorPalette, size: INT) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetPalette@Image@Gdiplus@@QEAA?AW4Status@2@PEBUColorPalette@2@@Z"]
    pub fn Image_SetPalette(this: *mut Image, palette: *const ColorPalette) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetThumbnailImage@Image@Gdiplus@@QEAAPEAV12@IIP6AHPEAX@Z0@Z"]
    pub fn Image_GetThumbnailImage(
        this: *mut Image,
        thumbWidth: UINT,
        thumbHeight: UINT,
        callback: GetThumbnailImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> *mut Image;
}
extern "C" {
    #[link_name = "\u{1}?GetFrameDimensionsCount@Image@Gdiplus@@QEAAIXZ"]
    pub fn Image_GetFrameDimensionsCount(this: *mut Image) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetFrameDimensionsList@Image@Gdiplus@@QEAA?AW4Status@2@PEAU_GUID@@I@Z"]
    pub fn Image_GetFrameDimensionsList(
        this: *mut Image,
        dimensionIDs: *mut GUID,
        count: UINT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetFrameCount@Image@Gdiplus@@QEAAIPEBU_GUID@@@Z"]
    pub fn Image_GetFrameCount(this: *mut Image, dimensionID: *const GUID) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?SelectActiveFrame@Image@Gdiplus@@QEAA?AW4Status@2@PEBU_GUID@@I@Z"]
    pub fn Image_SelectActiveFrame(
        this: *mut Image,
        dimensionID: *const GUID,
        frameIndex: UINT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?RotateFlip@Image@Gdiplus@@QEAA?AW4Status@2@W4RotateFlipType@2@@Z"]
    pub fn Image_RotateFlip(this: *mut Image, rotateFlipType: RotateFlipType) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetPropertyCount@Image@Gdiplus@@QEAAIXZ"]
    pub fn Image_GetPropertyCount(this: *mut Image) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetPropertyIdList@Image@Gdiplus@@QEAA?AW4Status@2@IPEAK@Z"]
    pub fn Image_GetPropertyIdList(
        this: *mut Image,
        numOfProperty: UINT,
        list: *mut PROPID,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetPropertyItemSize@Image@Gdiplus@@QEAAIK@Z"]
    pub fn Image_GetPropertyItemSize(this: *mut Image, propId: PROPID) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetPropertyItem@Image@Gdiplus@@QEAA?AW4Status@2@KIPEAVPropertyItem@2@@Z"]
    pub fn Image_GetPropertyItem(
        this: *mut Image,
        propId: PROPID,
        propSize: UINT,
        buffer: *mut PropertyItem,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetPropertySize@Image@Gdiplus@@QEAA?AW4Status@2@PEAI0@Z"]
    pub fn Image_GetPropertySize(
        this: *mut Image,
        totalBufferSize: *mut UINT,
        numProperties: *mut UINT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetAllPropertyItems@Image@Gdiplus@@QEAA?AW4Status@2@IIPEAVPropertyItem@2@@Z"]
    pub fn Image_GetAllPropertyItems(
        this: *mut Image,
        totalBufferSize: UINT,
        numProperties: UINT,
        allItems: *mut PropertyItem,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?RemovePropertyItem@Image@Gdiplus@@QEAA?AW4Status@2@K@Z"]
    pub fn Image_RemovePropertyItem(this: *mut Image, propId: PROPID) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetPropertyItem@Image@Gdiplus@@QEAA?AW4Status@2@PEBVPropertyItem@2@@Z"]
    pub fn Image_SetPropertyItem(this: *mut Image, item: *const PropertyItem) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetEncoderParameterListSize@Image@Gdiplus@@QEAAIPEBU_GUID@@@Z"]
    pub fn Image_GetEncoderParameterListSize(this: *mut Image, clsidEncoder: *const CLSID) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?GetEncoderParameterList@Image@Gdiplus@@QEAA?AW4Status@2@PEBU_GUID@@IPEAVEncoderParameters@2@@Z"]
    pub fn Image_GetEncoderParameterList(
        this: *mut Image,
        clsidEncoder: *const CLSID,
        size: UINT,
        buffer: *mut EncoderParameters,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@Image@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn Image_GetLastStatus(this: *const Image) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetNativeImage@Image@Gdiplus@@IEAAXPEAVGpImage@2@@Z"]
    pub fn Image_SetNativeImage(this: *mut Image, nativeImage: *mut GpImage);
}
extern "C" {
    #[link_name = "\u{1}??0Image@Gdiplus@@QEAA@PEB_WH@Z"]
    pub fn Image_Image(this: *mut Image, filename: *const WCHAR, useEmbeddedColorManagement: BOOL);
}
extern "C" {
    #[link_name = "\u{1}??0Image@Gdiplus@@QEAA@PEAUIStream@@H@Z"]
    pub fn Image_Image1(this: *mut Image, stream: *mut IStream, useEmbeddedColorManagement: BOOL);
}
extern "C" {
    #[link_name = "\u{1}??0Image@Gdiplus@@IEAA@PEAVGpImage@1@W4Status@1@@Z"]
    pub fn Image_Image2(this: *mut Image, nativeImage: *mut GpImage, status: Status);
}
impl Image {
    #[inline]
    pub unsafe fn FromFile(filename: *const WCHAR, useEmbeddedColorManagement: BOOL) -> *mut Image {
        Image_FromFile(filename, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn FromStream(stream: *mut IStream, useEmbeddedColorManagement: BOOL) -> *mut Image {
        Image_FromStream(stream, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn Save(
        &mut self,
        filename: *const WCHAR,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> Status {
        Image_Save(self, filename, clsidEncoder, encoderParams)
    }
    #[inline]
    pub unsafe fn Save1(
        &mut self,
        stream: *mut IStream,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> Status {
        Image_Save1(self, stream, clsidEncoder, encoderParams)
    }
    #[inline]
    pub unsafe fn SaveAdd(&mut self, encoderParams: *const EncoderParameters) -> Status {
        Image_SaveAdd(self, encoderParams)
    }
    #[inline]
    pub unsafe fn SaveAdd1(
        &mut self,
        newImage: *mut Image,
        encoderParams: *const EncoderParameters,
    ) -> Status {
        Image_SaveAdd1(self, newImage, encoderParams)
    }
    #[inline]
    pub unsafe fn GetType(&self) -> ImageType {
        Image_GetType(self)
    }
    #[inline]
    pub unsafe fn GetPhysicalDimension(&mut self, size: *mut SizeF) -> Status {
        Image_GetPhysicalDimension(self, size)
    }
    #[inline]
    pub unsafe fn GetBounds(&mut self, srcRect: *mut RectF, srcUnit: *mut Unit) -> Status {
        Image_GetBounds(self, srcRect, srcUnit)
    }
    #[inline]
    pub unsafe fn GetWidth(&mut self) -> UINT {
        Image_GetWidth(self)
    }
    #[inline]
    pub unsafe fn GetHeight(&mut self) -> UINT {
        Image_GetHeight(self)
    }
    #[inline]
    pub unsafe fn GetHorizontalResolution(&mut self) -> REAL {
        Image_GetHorizontalResolution(self)
    }
    #[inline]
    pub unsafe fn GetVerticalResolution(&mut self) -> REAL {
        Image_GetVerticalResolution(self)
    }
    #[inline]
    pub unsafe fn GetFlags(&mut self) -> UINT {
        Image_GetFlags(self)
    }
    #[inline]
    pub unsafe fn GetRawFormat(&mut self, format: *mut GUID) -> Status {
        Image_GetRawFormat(self, format)
    }
    #[inline]
    pub unsafe fn GetPixelFormat(&mut self) -> PixelFormat {
        Image_GetPixelFormat(self)
    }
    #[inline]
    pub unsafe fn GetPaletteSize(&mut self) -> INT {
        Image_GetPaletteSize(self)
    }
    #[inline]
    pub unsafe fn GetPalette(&mut self, palette: *mut ColorPalette, size: INT) -> Status {
        Image_GetPalette(self, palette, size)
    }
    #[inline]
    pub unsafe fn SetPalette(&mut self, palette: *const ColorPalette) -> Status {
        Image_SetPalette(self, palette)
    }
    #[inline]
    pub unsafe fn GetThumbnailImage(
        &mut self,
        thumbWidth: UINT,
        thumbHeight: UINT,
        callback: GetThumbnailImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> *mut Image {
        Image_GetThumbnailImage(self, thumbWidth, thumbHeight, callback, callbackData)
    }
    #[inline]
    pub unsafe fn GetFrameDimensionsCount(&mut self) -> UINT {
        Image_GetFrameDimensionsCount(self)
    }
    #[inline]
    pub unsafe fn GetFrameDimensionsList(
        &mut self,
        dimensionIDs: *mut GUID,
        count: UINT,
    ) -> Status {
        Image_GetFrameDimensionsList(self, dimensionIDs, count)
    }
    #[inline]
    pub unsafe fn GetFrameCount(&mut self, dimensionID: *const GUID) -> UINT {
        Image_GetFrameCount(self, dimensionID)
    }
    #[inline]
    pub unsafe fn SelectActiveFrame(
        &mut self,
        dimensionID: *const GUID,
        frameIndex: UINT,
    ) -> Status {
        Image_SelectActiveFrame(self, dimensionID, frameIndex)
    }
    #[inline]
    pub unsafe fn RotateFlip(&mut self, rotateFlipType: RotateFlipType) -> Status {
        Image_RotateFlip(self, rotateFlipType)
    }
    #[inline]
    pub unsafe fn GetPropertyCount(&mut self) -> UINT {
        Image_GetPropertyCount(self)
    }
    #[inline]
    pub unsafe fn GetPropertyIdList(&mut self, numOfProperty: UINT, list: *mut PROPID) -> Status {
        Image_GetPropertyIdList(self, numOfProperty, list)
    }
    #[inline]
    pub unsafe fn GetPropertyItemSize(&mut self, propId: PROPID) -> UINT {
        Image_GetPropertyItemSize(self, propId)
    }
    #[inline]
    pub unsafe fn GetPropertyItem(
        &mut self,
        propId: PROPID,
        propSize: UINT,
        buffer: *mut PropertyItem,
    ) -> Status {
        Image_GetPropertyItem(self, propId, propSize, buffer)
    }
    #[inline]
    pub unsafe fn GetPropertySize(
        &mut self,
        totalBufferSize: *mut UINT,
        numProperties: *mut UINT,
    ) -> Status {
        Image_GetPropertySize(self, totalBufferSize, numProperties)
    }
    #[inline]
    pub unsafe fn GetAllPropertyItems(
        &mut self,
        totalBufferSize: UINT,
        numProperties: UINT,
        allItems: *mut PropertyItem,
    ) -> Status {
        Image_GetAllPropertyItems(self, totalBufferSize, numProperties, allItems)
    }
    #[inline]
    pub unsafe fn RemovePropertyItem(&mut self, propId: PROPID) -> Status {
        Image_RemovePropertyItem(self, propId)
    }
    #[inline]
    pub unsafe fn SetPropertyItem(&mut self, item: *const PropertyItem) -> Status {
        Image_SetPropertyItem(self, item)
    }
    #[inline]
    pub unsafe fn GetEncoderParameterListSize(&mut self, clsidEncoder: *const CLSID) -> UINT {
        Image_GetEncoderParameterListSize(self, clsidEncoder)
    }
    #[inline]
    pub unsafe fn GetEncoderParameterList(
        &mut self,
        clsidEncoder: *const CLSID,
        size: UINT,
        buffer: *mut EncoderParameters,
    ) -> Status {
        Image_GetEncoderParameterList(self, clsidEncoder, size, buffer)
    }
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        Image_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn SetNativeImage(&mut self, nativeImage: *mut GpImage) {
        Image_SetNativeImage(self, nativeImage)
    }
    #[inline]
    pub unsafe fn new(filename: *const WCHAR, useEmbeddedColorManagement: BOOL) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Image_Image(
            __bindgen_tmp.as_mut_ptr(),
            filename,
            useEmbeddedColorManagement,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(stream: *mut IStream, useEmbeddedColorManagement: BOOL) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Image_Image1(
            __bindgen_tmp.as_mut_ptr(),
            stream,
            useEmbeddedColorManagement,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(nativeImage: *mut GpImage, status: Status) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Image_Image2(__bindgen_tmp.as_mut_ptr(), nativeImage, status);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DImage@Gdiplus@@QEAAXXZ"]
    pub fn Image_Image_destructor(this: *mut Image);
}
extern "C" {
    #[link_name = "\u{1}?Clone@Image@Gdiplus@@UEAAPEAV12@XZ"]
    pub fn Image_Clone(this: *mut ::core::ffi::c_void) -> *mut Image;
}
#[repr(C)]
#[derive(Debug)]
pub struct Bitmap {
    pub _base: Image,
}
#[test]
fn bindgen_test_layout_Bitmap() {
    assert_eq!(
        ::core::mem::size_of::<Bitmap>(),
        24usize,
        concat!("Size of: ", stringify!(Bitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<Bitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(Bitmap))
    );
}
extern "C" {
    #[link_name = "\u{1}?FromFile@Bitmap@Gdiplus@@SAPEAV12@PEB_WH@Z"]
    pub fn Bitmap_FromFile(filename: *const WCHAR, useEmbeddedColorManagement: BOOL)
        -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromStream@Bitmap@Gdiplus@@SAPEAV12@PEAUIStream@@H@Z"]
    pub fn Bitmap_FromStream(stream: *mut IStream, useEmbeddedColorManagement: BOOL)
        -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRect@2@H@Z"]
    pub fn Bitmap_Clone(this: *mut Bitmap, rect: *const Rect, format: PixelFormat) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?Clone@Bitmap@Gdiplus@@QEAAPEAV12@HHHHH@Z"]
    pub fn Bitmap_Clone1(
        this: *mut Bitmap,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        format: PixelFormat,
    ) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?Clone@Bitmap@Gdiplus@@QEAAPEAV12@AEBVRectF@2@H@Z"]
    pub fn Bitmap_Clone2(this: *mut Bitmap, rect: *const RectF, format: PixelFormat)
        -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?Clone@Bitmap@Gdiplus@@QEAAPEAV12@MMMMH@Z"]
    pub fn Bitmap_Clone3(
        this: *mut Bitmap,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        format: PixelFormat,
    ) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?LockBits@Bitmap@Gdiplus@@QEAA?AW4Status@2@PEBVRect@2@IHPEAVBitmapData@2@@Z"]
    pub fn Bitmap_LockBits(
        this: *mut Bitmap,
        rect: *const Rect,
        flags: UINT,
        format: PixelFormat,
        lockedBitmapData: *mut BitmapData,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?UnlockBits@Bitmap@Gdiplus@@QEAA?AW4Status@2@PEAVBitmapData@2@@Z"]
    pub fn Bitmap_UnlockBits(this: *mut Bitmap, lockedBitmapData: *mut BitmapData) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetPixel@Bitmap@Gdiplus@@QEAA?AW4Status@2@HHPEAVColor@2@@Z"]
    pub fn Bitmap_GetPixel(this: *mut Bitmap, x: INT, y: INT, color: *mut Color) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetPixel@Bitmap@Gdiplus@@QEAA?AW4Status@2@HHAEBVColor@2@@Z"]
    pub fn Bitmap_SetPixel(this: *mut Bitmap, x: INT, y: INT, color: *const Color) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetResolution@Bitmap@Gdiplus@@QEAA?AW4Status@2@MM@Z"]
    pub fn Bitmap_SetResolution(this: *mut Bitmap, xdpi: REAL, ydpi: REAL) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?FromDirectDrawSurface7@Bitmap@Gdiplus@@SAPEAV12@PEAUIDirectDrawSurface7@@@Z"]
    pub fn Bitmap_FromDirectDrawSurface7(surface: *mut IDirectDrawSurface7) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromBITMAPINFO@Bitmap@Gdiplus@@SAPEAV12@PEBUtagBITMAPINFO@@PEAX@Z"]
    pub fn Bitmap_FromBITMAPINFO(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
    ) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromHBITMAP@Bitmap@Gdiplus@@SAPEAV12@PEAUHBITMAP__@@PEAUHPALETTE__@@@Z"]
    pub fn Bitmap_FromHBITMAP(hbm: HBITMAP, hpal: HPALETTE) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromHICON@Bitmap@Gdiplus@@SAPEAV12@PEAUHICON__@@@Z"]
    pub fn Bitmap_FromHICON(hicon: HICON) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromResource@Bitmap@Gdiplus@@SAPEAV12@PEAUHINSTANCE__@@PEB_W@Z"]
    pub fn Bitmap_FromResource(hInstance: HINSTANCE, bitmapName: *const WCHAR) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?GetHBITMAP@Bitmap@Gdiplus@@QEAA?AW4Status@2@AEBVColor@2@PEAPEAUHBITMAP__@@@Z"]
    pub fn Bitmap_GetHBITMAP(
        this: *mut Bitmap,
        colorBackground: *const Color,
        hbmReturn: *mut HBITMAP,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetHICON@Bitmap@Gdiplus@@QEAA?AW4Status@2@PEAPEAUHICON__@@@Z"]
    pub fn Bitmap_GetHICON(this: *mut Bitmap, hicon: *mut HICON) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEB_WH@Z"]
    pub fn Bitmap_Bitmap(
        this: *mut Bitmap,
        filename: *const WCHAR,
        useEmbeddedColorManagement: BOOL,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEAUIStream@@H@Z"]
    pub fn Bitmap_Bitmap1(
        this: *mut Bitmap,
        stream: *mut IStream,
        useEmbeddedColorManagement: BOOL,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@HHHHPEAE@Z"]
    pub fn Bitmap_Bitmap2(
        this: *mut Bitmap,
        width: INT,
        height: INT,
        stride: INT,
        format: PixelFormat,
        scan0: *mut BYTE,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@HHH@Z"]
    pub fn Bitmap_Bitmap3(this: *mut Bitmap, width: INT, height: INT, format: PixelFormat);
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@HHPEAVGraphics@1@@Z"]
    pub fn Bitmap_Bitmap4(this: *mut Bitmap, width: INT, height: INT, target: *mut Graphics);
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEAUIDirectDrawSurface7@@@Z"]
    pub fn Bitmap_Bitmap5(this: *mut Bitmap, surface: *mut IDirectDrawSurface7);
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEBUtagBITMAPINFO@@PEAX@Z"]
    pub fn Bitmap_Bitmap6(
        this: *mut Bitmap,
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEAUHBITMAP__@@PEAUHPALETTE__@@@Z"]
    pub fn Bitmap_Bitmap7(this: *mut Bitmap, hbm: HBITMAP, hpal: HPALETTE);
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEAUHICON__@@@Z"]
    pub fn Bitmap_Bitmap8(this: *mut Bitmap, hicon: HICON);
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@QEAA@PEAUHINSTANCE__@@PEB_W@Z"]
    pub fn Bitmap_Bitmap9(this: *mut Bitmap, hInstance: HINSTANCE, bitmapName: *const WCHAR);
}
extern "C" {
    #[link_name = "\u{1}??0Bitmap@Gdiplus@@IEAA@PEAVGpBitmap@1@@Z"]
    pub fn Bitmap_Bitmap10(this: *mut Bitmap, nativeBitmap: *mut GpBitmap);
}
impl Bitmap {
    #[inline]
    pub unsafe fn FromFile(
        filename: *const WCHAR,
        useEmbeddedColorManagement: BOOL,
    ) -> *mut Bitmap {
        Bitmap_FromFile(filename, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn FromStream(
        stream: *mut IStream,
        useEmbeddedColorManagement: BOOL,
    ) -> *mut Bitmap {
        Bitmap_FromStream(stream, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn Clone(&mut self, rect: *const Rect, format: PixelFormat) -> *mut Bitmap {
        Bitmap_Clone(self, rect, format)
    }
    #[inline]
    pub unsafe fn Clone1(
        &mut self,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        format: PixelFormat,
    ) -> *mut Bitmap {
        Bitmap_Clone1(self, x, y, width, height, format)
    }
    #[inline]
    pub unsafe fn Clone2(&mut self, rect: *const RectF, format: PixelFormat) -> *mut Bitmap {
        Bitmap_Clone2(self, rect, format)
    }
    #[inline]
    pub unsafe fn Clone3(
        &mut self,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        format: PixelFormat,
    ) -> *mut Bitmap {
        Bitmap_Clone3(self, x, y, width, height, format)
    }
    #[inline]
    pub unsafe fn LockBits(
        &mut self,
        rect: *const Rect,
        flags: UINT,
        format: PixelFormat,
        lockedBitmapData: *mut BitmapData,
    ) -> Status {
        Bitmap_LockBits(self, rect, flags, format, lockedBitmapData)
    }
    #[inline]
    pub unsafe fn UnlockBits(&mut self, lockedBitmapData: *mut BitmapData) -> Status {
        Bitmap_UnlockBits(self, lockedBitmapData)
    }
    #[inline]
    pub unsafe fn GetPixel(&mut self, x: INT, y: INT, color: *mut Color) -> Status {
        Bitmap_GetPixel(self, x, y, color)
    }
    #[inline]
    pub unsafe fn SetPixel(&mut self, x: INT, y: INT, color: *const Color) -> Status {
        Bitmap_SetPixel(self, x, y, color)
    }
    #[inline]
    pub unsafe fn SetResolution(&mut self, xdpi: REAL, ydpi: REAL) -> Status {
        Bitmap_SetResolution(self, xdpi, ydpi)
    }
    #[inline]
    pub unsafe fn FromDirectDrawSurface7(surface: *mut IDirectDrawSurface7) -> *mut Bitmap {
        Bitmap_FromDirectDrawSurface7(surface)
    }
    #[inline]
    pub unsafe fn FromBITMAPINFO(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
    ) -> *mut Bitmap {
        Bitmap_FromBITMAPINFO(gdiBitmapInfo, gdiBitmapData)
    }
    #[inline]
    pub unsafe fn FromHBITMAP(hbm: HBITMAP, hpal: HPALETTE) -> *mut Bitmap {
        Bitmap_FromHBITMAP(hbm, hpal)
    }
    #[inline]
    pub unsafe fn FromHICON(hicon: HICON) -> *mut Bitmap {
        Bitmap_FromHICON(hicon)
    }
    #[inline]
    pub unsafe fn FromResource(hInstance: HINSTANCE, bitmapName: *const WCHAR) -> *mut Bitmap {
        Bitmap_FromResource(hInstance, bitmapName)
    }
    #[inline]
    pub unsafe fn GetHBITMAP(
        &mut self,
        colorBackground: *const Color,
        hbmReturn: *mut HBITMAP,
    ) -> Status {
        Bitmap_GetHBITMAP(self, colorBackground, hbmReturn)
    }
    #[inline]
    pub unsafe fn GetHICON(&mut self, hicon: *mut HICON) -> Status {
        Bitmap_GetHICON(self, hicon)
    }
    #[inline]
    pub unsafe fn new(filename: *const WCHAR, useEmbeddedColorManagement: BOOL) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap(
            __bindgen_tmp.as_mut_ptr(),
            filename,
            useEmbeddedColorManagement,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(stream: *mut IStream, useEmbeddedColorManagement: BOOL) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap1(
            __bindgen_tmp.as_mut_ptr(),
            stream,
            useEmbeddedColorManagement,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        width: INT,
        height: INT,
        stride: INT,
        format: PixelFormat,
        scan0: *mut BYTE,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap2(
            __bindgen_tmp.as_mut_ptr(),
            width,
            height,
            stride,
            format,
            scan0,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(width: INT, height: INT, format: PixelFormat) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap3(__bindgen_tmp.as_mut_ptr(), width, height, format);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(width: INT, height: INT, target: *mut Graphics) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap4(__bindgen_tmp.as_mut_ptr(), width, height, target);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(surface: *mut IDirectDrawSurface7) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap5(__bindgen_tmp.as_mut_ptr(), surface);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap6(__bindgen_tmp.as_mut_ptr(), gdiBitmapInfo, gdiBitmapData);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(hbm: HBITMAP, hpal: HPALETTE) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap7(__bindgen_tmp.as_mut_ptr(), hbm, hpal);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new8(hicon: HICON) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap8(__bindgen_tmp.as_mut_ptr(), hicon);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new9(hInstance: HINSTANCE, bitmapName: *const WCHAR) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap9(__bindgen_tmp.as_mut_ptr(), hInstance, bitmapName);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new10(nativeBitmap: *mut GpBitmap) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Bitmap_Bitmap10(__bindgen_tmp.as_mut_ptr(), nativeBitmap);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct CustomLineCap__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct CustomLineCap {
    pub vtable_: *const CustomLineCap__bindgen_vtable,
    pub nativeCap: *mut GpCustomLineCap,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_CustomLineCap() {
    assert_eq!(
        ::core::mem::size_of::<CustomLineCap>(),
        24usize,
        concat!("Size of: ", stringify!(CustomLineCap))
    );
    assert_eq!(
        ::core::mem::align_of::<CustomLineCap>(),
        8usize,
        concat!("Alignment of ", stringify!(CustomLineCap))
    );
    fn test_field_nativeCap() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CustomLineCap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeCap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CustomLineCap),
                "::",
                stringify!(nativeCap)
            )
        );
    }
    test_field_nativeCap();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CustomLineCap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CustomLineCap),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?Clone@CustomLineCap@Gdiplus@@QEBAPEAV12@XZ"]
    pub fn CustomLineCap_Clone(this: *const CustomLineCap) -> *mut CustomLineCap;
}
extern "C" {
    #[link_name = "\u{1}?SetStrokeCaps@CustomLineCap@Gdiplus@@QEAA?AW4Status@2@W4LineCap@2@0@Z"]
    pub fn CustomLineCap_SetStrokeCaps(
        this: *mut CustomLineCap,
        startCap: LineCap,
        endCap: LineCap,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetStrokeCaps@CustomLineCap@Gdiplus@@QEBA?AW4Status@2@PEAW4LineCap@2@0@Z"]
    pub fn CustomLineCap_GetStrokeCaps(
        this: *const CustomLineCap,
        startCap: *mut LineCap,
        endCap: *mut LineCap,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetStrokeJoin@CustomLineCap@Gdiplus@@QEAA?AW4Status@2@W4LineJoin@2@@Z"]
    pub fn CustomLineCap_SetStrokeJoin(this: *mut CustomLineCap, lineJoin: LineJoin) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetStrokeJoin@CustomLineCap@Gdiplus@@QEBA?AW4LineJoin@2@XZ"]
    pub fn CustomLineCap_GetStrokeJoin(this: *const CustomLineCap) -> LineJoin;
}
extern "C" {
    #[link_name = "\u{1}?SetBaseCap@CustomLineCap@Gdiplus@@QEAA?AW4Status@2@W4LineCap@2@@Z"]
    pub fn CustomLineCap_SetBaseCap(this: *mut CustomLineCap, baseCap: LineCap) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetBaseCap@CustomLineCap@Gdiplus@@QEBA?AW4LineCap@2@XZ"]
    pub fn CustomLineCap_GetBaseCap(this: *const CustomLineCap) -> LineCap;
}
extern "C" {
    #[link_name = "\u{1}?SetBaseInset@CustomLineCap@Gdiplus@@QEAA?AW4Status@2@M@Z"]
    pub fn CustomLineCap_SetBaseInset(this: *mut CustomLineCap, inset: REAL) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetBaseInset@CustomLineCap@Gdiplus@@QEBAMXZ"]
    pub fn CustomLineCap_GetBaseInset(this: *const CustomLineCap) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?SetWidthScale@CustomLineCap@Gdiplus@@QEAA?AW4Status@2@M@Z"]
    pub fn CustomLineCap_SetWidthScale(this: *mut CustomLineCap, widthScale: REAL) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetWidthScale@CustomLineCap@Gdiplus@@QEBAMXZ"]
    pub fn CustomLineCap_GetWidthScale(this: *const CustomLineCap) -> REAL;
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@CustomLineCap@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn CustomLineCap_GetLastStatus(this: *const CustomLineCap) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0CustomLineCap@Gdiplus@@QEAA@PEBVGraphicsPath@1@0W4LineCap@1@M@Z"]
    pub fn CustomLineCap_CustomLineCap(
        this: *mut CustomLineCap,
        fillPath: *const GraphicsPath,
        strokePath: *const GraphicsPath,
        baseCap: LineCap,
        baseInset: REAL,
    );
}
extern "C" {
    #[link_name = "\u{1}??0CustomLineCap@Gdiplus@@IEAA@XZ"]
    pub fn CustomLineCap_CustomLineCap1(this: *mut CustomLineCap);
}
impl CustomLineCap {
    #[inline]
    pub unsafe fn Clone(&self) -> *mut CustomLineCap {
        CustomLineCap_Clone(self)
    }
    #[inline]
    pub unsafe fn SetStrokeCaps(&mut self, startCap: LineCap, endCap: LineCap) -> Status {
        CustomLineCap_SetStrokeCaps(self, startCap, endCap)
    }
    #[inline]
    pub unsafe fn GetStrokeCaps(&self, startCap: *mut LineCap, endCap: *mut LineCap) -> Status {
        CustomLineCap_GetStrokeCaps(self, startCap, endCap)
    }
    #[inline]
    pub unsafe fn SetStrokeJoin(&mut self, lineJoin: LineJoin) -> Status {
        CustomLineCap_SetStrokeJoin(self, lineJoin)
    }
    #[inline]
    pub unsafe fn GetStrokeJoin(&self) -> LineJoin {
        CustomLineCap_GetStrokeJoin(self)
    }
    #[inline]
    pub unsafe fn SetBaseCap(&mut self, baseCap: LineCap) -> Status {
        CustomLineCap_SetBaseCap(self, baseCap)
    }
    #[inline]
    pub unsafe fn GetBaseCap(&self) -> LineCap {
        CustomLineCap_GetBaseCap(self)
    }
    #[inline]
    pub unsafe fn SetBaseInset(&mut self, inset: REAL) -> Status {
        CustomLineCap_SetBaseInset(self, inset)
    }
    #[inline]
    pub unsafe fn GetBaseInset(&self) -> REAL {
        CustomLineCap_GetBaseInset(self)
    }
    #[inline]
    pub unsafe fn SetWidthScale(&mut self, widthScale: REAL) -> Status {
        CustomLineCap_SetWidthScale(self, widthScale)
    }
    #[inline]
    pub unsafe fn GetWidthScale(&self) -> REAL {
        CustomLineCap_GetWidthScale(self)
    }
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        CustomLineCap_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn new(
        fillPath: *const GraphicsPath,
        strokePath: *const GraphicsPath,
        baseCap: LineCap,
        baseInset: REAL,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        CustomLineCap_CustomLineCap(
            __bindgen_tmp.as_mut_ptr(),
            fillPath,
            strokePath,
            baseCap,
            baseInset,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        CustomLineCap_CustomLineCap1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCustomLineCap@Gdiplus@@QEAAXXZ"]
    pub fn CustomLineCap_CustomLineCap_destructor(this: *mut CustomLineCap);
}
#[repr(C)]
pub struct CachedBitmap__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct CachedBitmap {
    pub vtable_: *const CachedBitmap__bindgen_vtable,
    pub nativeCachedBitmap: *mut GpCachedBitmap,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_CachedBitmap() {
    assert_eq!(
        ::core::mem::size_of::<CachedBitmap>(),
        24usize,
        concat!("Size of: ", stringify!(CachedBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<CachedBitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(CachedBitmap))
    );
    fn test_field_nativeCachedBitmap() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CachedBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeCachedBitmap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CachedBitmap),
                "::",
                stringify!(nativeCachedBitmap)
            )
        );
    }
    test_field_nativeCachedBitmap();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CachedBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(CachedBitmap),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?GetLastStatus@CachedBitmap@Gdiplus@@QEBA?AW4Status@2@XZ"]
    pub fn CachedBitmap_GetLastStatus(this: *const CachedBitmap) -> Status;
}
extern "C" {
    #[link_name = "\u{1}??0CachedBitmap@Gdiplus@@QEAA@PEAVBitmap@1@PEAVGraphics@1@@Z"]
    pub fn CachedBitmap_CachedBitmap(
        this: *mut CachedBitmap,
        bitmap: *mut Bitmap,
        graphics: *mut Graphics,
    );
}
impl CachedBitmap {
    #[inline]
    pub unsafe fn GetLastStatus(&self) -> Status {
        CachedBitmap_GetLastStatus(self)
    }
    #[inline]
    pub unsafe fn new(bitmap: *mut Bitmap, graphics: *mut Graphics) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        CachedBitmap_CachedBitmap(__bindgen_tmp.as_mut_ptr(), bitmap, graphics);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}??_DCachedBitmap@Gdiplus@@QEAAXXZ"]
    pub fn CachedBitmap_CachedBitmap_destructor(this: *mut CachedBitmap);
}
#[repr(C)]
#[derive(Debug)]
pub struct Metafile {
    pub _base: Image,
}
#[test]
fn bindgen_test_layout_Metafile() {
    assert_eq!(
        ::core::mem::size_of::<Metafile>(),
        24usize,
        concat!("Size of: ", stringify!(Metafile))
    );
    assert_eq!(
        ::core::mem::align_of::<Metafile>(),
        8usize,
        concat!("Alignment of ", stringify!(Metafile))
    );
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PEAUHMETAFILE__@@PEBUWmfPlaceableFileHeader@2@PEAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        header: *mut MetafileHeader,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PEAUHENHMETAFILE__@@PEAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader1(hEmf: HENHMETAFILE, header: *mut MetafileHeader) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PEB_WPEAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader2(
        filename: *const WCHAR,
        header: *mut MetafileHeader,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PEAUIStream@@PEAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader3(stream: *mut IStream, header: *mut MetafileHeader)
        -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@QEBA?AW4Status@2@PEAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader4(
        this: *const Metafile,
        header: *mut MetafileHeader,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetHENHMETAFILE@Metafile@Gdiplus@@QEAAPEAUHENHMETAFILE__@@XZ"]
    pub fn Metafile_GetHENHMETAFILE(this: *mut Metafile) -> HENHMETAFILE;
}
extern "C" {
    #[link_name = "\u{1}?PlayRecord@Metafile@Gdiplus@@QEBA?AW4Status@2@W4EmfPlusRecordType@2@IIPEBE@Z"]
    pub fn Metafile_PlayRecord(
        this: *const Metafile,
        recordType: EmfPlusRecordType,
        flags: UINT,
        dataSize: UINT,
        data: *const BYTE,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?SetDownLevelRasterizationLimit@Metafile@Gdiplus@@QEAA?AW4Status@2@I@Z"]
    pub fn Metafile_SetDownLevelRasterizationLimit(
        this: *mut Metafile,
        metafileRasterizationLimitDpi: UINT,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetDownLevelRasterizationLimit@Metafile@Gdiplus@@QEBAIXZ"]
    pub fn Metafile_GetDownLevelRasterizationLimit(this: *const Metafile) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}?EmfToWmfBits@Metafile@Gdiplus@@SAIPEAUHENHMETAFILE__@@IPEAEHH@Z"]
    pub fn Metafile_EmfToWmfBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        eFlags: INT,
    ) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUHMETAFILE__@@PEBUWmfPlaceableFileHeader@1@H@Z"]
    pub fn Metafile_Metafile(
        this: *mut Metafile,
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        deleteWmf: BOOL,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUHENHMETAFILE__@@H@Z"]
    pub fn Metafile_Metafile1(this: *mut Metafile, hEmf: HENHMETAFILE, deleteEmf: BOOL);
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEB_W@Z"]
    pub fn Metafile_Metafile2(this: *mut Metafile, filename: *const WCHAR);
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEB_WPEBUWmfPlaceableFileHeader@1@@Z"]
    pub fn Metafile_Metafile3(
        this: *mut Metafile,
        filename: *const WCHAR,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUIStream@@@Z"]
    pub fn Metafile_Metafile4(this: *mut Metafile, stream: *mut IStream);
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUHDC__@@W4EmfType@1@PEB_W@Z"]
    pub fn Metafile_Metafile5(
        this: *mut Metafile,
        referenceHdc: HDC,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUHDC__@@AEBVRectF@1@W4MetafileFrameUnit@1@W4EmfType@1@PEB_W@Z"]
    pub fn Metafile_Metafile6(
        this: *mut Metafile,
        referenceHdc: HDC,
        frameRect: *const RectF,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUHDC__@@AEBVRect@1@W4MetafileFrameUnit@1@W4EmfType@1@PEB_W@Z"]
    pub fn Metafile_Metafile7(
        this: *mut Metafile,
        referenceHdc: HDC,
        frameRect: *const Rect,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEB_WPEAUHDC__@@W4EmfType@1@0@Z"]
    pub fn Metafile_Metafile8(
        this: *mut Metafile,
        fileName: *const WCHAR,
        referenceHdc: HDC,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEB_WPEAUHDC__@@AEBVRectF@1@W4MetafileFrameUnit@1@W4EmfType@1@0@Z"]
    pub fn Metafile_Metafile9(
        this: *mut Metafile,
        fileName: *const WCHAR,
        referenceHdc: HDC,
        frameRect: *const RectF,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEB_WPEAUHDC__@@AEBVRect@1@W4MetafileFrameUnit@1@W4EmfType@1@0@Z"]
    pub fn Metafile_Metafile10(
        this: *mut Metafile,
        fileName: *const WCHAR,
        referenceHdc: HDC,
        frameRect: *const Rect,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUIStream@@PEAUHDC__@@W4EmfType@1@PEB_W@Z"]
    pub fn Metafile_Metafile11(
        this: *mut Metafile,
        stream: *mut IStream,
        referenceHdc: HDC,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUIStream@@PEAUHDC__@@AEBVRectF@1@W4MetafileFrameUnit@1@W4EmfType@1@PEB_W@Z"]
    pub fn Metafile_Metafile12(
        this: *mut Metafile,
        stream: *mut IStream,
        referenceHdc: HDC,
        frameRect: *const RectF,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    );
}
extern "C" {
    #[link_name = "\u{1}??0Metafile@Gdiplus@@QEAA@PEAUIStream@@PEAUHDC__@@AEBVRect@1@W4MetafileFrameUnit@1@W4EmfType@1@PEB_W@Z"]
    pub fn Metafile_Metafile13(
        this: *mut Metafile,
        stream: *mut IStream,
        referenceHdc: HDC,
        frameRect: *const Rect,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    );
}
impl Metafile {
    #[inline]
    pub unsafe fn GetMetafileHeader(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        header: *mut MetafileHeader,
    ) -> Status {
        Metafile_GetMetafileHeader(hWmf, wmfPlaceableFileHeader, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader1(hEmf: HENHMETAFILE, header: *mut MetafileHeader) -> Status {
        Metafile_GetMetafileHeader1(hEmf, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader2(
        filename: *const WCHAR,
        header: *mut MetafileHeader,
    ) -> Status {
        Metafile_GetMetafileHeader2(filename, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader3(stream: *mut IStream, header: *mut MetafileHeader) -> Status {
        Metafile_GetMetafileHeader3(stream, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader4(&self, header: *mut MetafileHeader) -> Status {
        Metafile_GetMetafileHeader4(self, header)
    }
    #[inline]
    pub unsafe fn GetHENHMETAFILE(&mut self) -> HENHMETAFILE {
        Metafile_GetHENHMETAFILE(self)
    }
    #[inline]
    pub unsafe fn PlayRecord(
        &self,
        recordType: EmfPlusRecordType,
        flags: UINT,
        dataSize: UINT,
        data: *const BYTE,
    ) -> Status {
        Metafile_PlayRecord(self, recordType, flags, dataSize, data)
    }
    #[inline]
    pub unsafe fn SetDownLevelRasterizationLimit(
        &mut self,
        metafileRasterizationLimitDpi: UINT,
    ) -> Status {
        Metafile_SetDownLevelRasterizationLimit(self, metafileRasterizationLimitDpi)
    }
    #[inline]
    pub unsafe fn GetDownLevelRasterizationLimit(&self) -> UINT {
        Metafile_GetDownLevelRasterizationLimit(self)
    }
    #[inline]
    pub unsafe fn EmfToWmfBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        eFlags: INT,
    ) -> UINT {
        Metafile_EmfToWmfBits(hemf, cbData16, pData16, iMapMode, eFlags)
    }
    #[inline]
    pub unsafe fn new(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        deleteWmf: BOOL,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile(
            __bindgen_tmp.as_mut_ptr(),
            hWmf,
            wmfPlaceableFileHeader,
            deleteWmf,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(hEmf: HENHMETAFILE, deleteEmf: BOOL) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile1(__bindgen_tmp.as_mut_ptr(), hEmf, deleteEmf);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(filename: *const WCHAR) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile2(__bindgen_tmp.as_mut_ptr(), filename);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        filename: *const WCHAR,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile3(__bindgen_tmp.as_mut_ptr(), filename, wmfPlaceableFileHeader);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(stream: *mut IStream) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile4(__bindgen_tmp.as_mut_ptr(), stream);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(referenceHdc: HDC, type_: EmfType, description: *const WCHAR) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile5(__bindgen_tmp.as_mut_ptr(), referenceHdc, type_, description);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(
        referenceHdc: HDC,
        frameRect: *const RectF,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile6(
            __bindgen_tmp.as_mut_ptr(),
            referenceHdc,
            frameRect,
            frameUnit,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(
        referenceHdc: HDC,
        frameRect: *const Rect,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile7(
            __bindgen_tmp.as_mut_ptr(),
            referenceHdc,
            frameRect,
            frameUnit,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new8(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile8(
            __bindgen_tmp.as_mut_ptr(),
            fileName,
            referenceHdc,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new9(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        frameRect: *const RectF,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile9(
            __bindgen_tmp.as_mut_ptr(),
            fileName,
            referenceHdc,
            frameRect,
            frameUnit,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new10(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        frameRect: *const Rect,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile10(
            __bindgen_tmp.as_mut_ptr(),
            fileName,
            referenceHdc,
            frameRect,
            frameUnit,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new11(
        stream: *mut IStream,
        referenceHdc: HDC,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile11(
            __bindgen_tmp.as_mut_ptr(),
            stream,
            referenceHdc,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new12(
        stream: *mut IStream,
        referenceHdc: HDC,
        frameRect: *const RectF,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile12(
            __bindgen_tmp.as_mut_ptr(),
            stream,
            referenceHdc,
            frameRect,
            frameUnit,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new13(
        stream: *mut IStream,
        referenceHdc: HDC,
        frameRect: *const Rect,
        frameUnit: MetafileFrameUnit,
        type_: EmfType,
        description: *const WCHAR,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        Metafile_Metafile13(
            __bindgen_tmp.as_mut_ptr(),
            stream,
            referenceHdc,
            frameRect,
            frameUnit,
            type_,
            description,
        );
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Matrix {
    pub nativeMatrix: *mut GpMatrix,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Matrix() {
    assert_eq!(
        ::core::mem::size_of::<Matrix>(),
        16usize,
        concat!("Size of: ", stringify!(Matrix))
    );
    assert_eq!(
        ::core::mem::align_of::<Matrix>(),
        8usize,
        concat!("Alignment of ", stringify!(Matrix))
    );
    fn test_field_nativeMatrix() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Matrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeMatrix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Matrix),
                "::",
                stringify!(nativeMatrix)
            )
        );
    }
    test_field_nativeMatrix();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Matrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Matrix),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct Pen {
    pub nativePen: *mut GpPen,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Pen() {
    assert_eq!(
        ::core::mem::size_of::<Pen>(),
        16usize,
        concat!("Size of: ", stringify!(Pen))
    );
    assert_eq!(
        ::core::mem::align_of::<Pen>(),
        8usize,
        concat!("Alignment of ", stringify!(Pen))
    );
    fn test_field_nativePen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Pen>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativePen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Pen),
                "::",
                stringify!(nativePen)
            )
        );
    }
    test_field_nativePen();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Pen>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Pen),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct StringFormat {
    pub nativeFormat: *mut GpStringFormat,
    pub lastError: Status,
}
#[test]
fn bindgen_test_layout_StringFormat() {
    assert_eq!(
        ::core::mem::size_of::<StringFormat>(),
        16usize,
        concat!("Size of: ", stringify!(StringFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<StringFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(StringFormat))
    );
    fn test_field_nativeFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<StringFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StringFormat),
                "::",
                stringify!(nativeFormat)
            )
        );
    }
    test_field_nativeFormat();
    fn test_field_lastError() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<StringFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastError) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(StringFormat),
                "::",
                stringify!(lastError)
            )
        );
    }
    test_field_lastError();
}
extern "C" {
    #[link_name = "\u{1}?GenericDefault@StringFormat@Gdiplus@@SAPEBV12@XZ"]
    pub fn StringFormat_GenericDefault() -> *const StringFormat;
}
extern "C" {
    #[link_name = "\u{1}?GenericTypographic@StringFormat@Gdiplus@@SAPEBV12@XZ"]
    pub fn StringFormat_GenericTypographic() -> *const StringFormat;
}
impl StringFormat {
    #[inline]
    pub unsafe fn GenericDefault() -> *const StringFormat {
        StringFormat_GenericDefault()
    }
    #[inline]
    pub unsafe fn GenericTypographic() -> *const StringFormat {
        StringFormat_GenericTypographic()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GraphicsPath {
    pub nativePath: *mut GpPath,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_GraphicsPath() {
    assert_eq!(
        ::core::mem::size_of::<GraphicsPath>(),
        16usize,
        concat!("Size of: ", stringify!(GraphicsPath))
    );
    assert_eq!(
        ::core::mem::align_of::<GraphicsPath>(),
        8usize,
        concat!("Alignment of ", stringify!(GraphicsPath))
    );
    fn test_field_nativePath() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GraphicsPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativePath) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GraphicsPath),
                "::",
                stringify!(nativePath)
            )
        );
    }
    test_field_nativePath();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GraphicsPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GraphicsPath),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?GetBounds@GraphicsPath@Gdiplus@@QEBA?AW4Status@2@PEAVRectF@2@PEBVMatrix@2@PEBVPen@2@@Z"]
    pub fn GraphicsPath_GetBounds(
        this: *const GraphicsPath,
        bounds: *mut RectF,
        matrix: *const Matrix,
        pen: *const Pen,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetBounds@GraphicsPath@Gdiplus@@QEBA?AW4Status@2@PEAVRect@2@PEBVMatrix@2@PEBVPen@2@@Z"]
    pub fn GraphicsPath_GetBounds1(
        this: *const GraphicsPath,
        bounds: *mut Rect,
        matrix: *const Matrix,
        pen: *const Pen,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?IsVisible@GraphicsPath@Gdiplus@@QEBAHMMPEBVGraphics@2@@Z"]
    pub fn GraphicsPath_IsVisible(
        this: *const GraphicsPath,
        x: REAL,
        y: REAL,
        g: *const Graphics,
    ) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsVisible@GraphicsPath@Gdiplus@@QEBAHHHPEBVGraphics@2@@Z"]
    pub fn GraphicsPath_IsVisible1(
        this: *const GraphicsPath,
        x: INT,
        y: INT,
        g: *const Graphics,
    ) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsOutlineVisible@GraphicsPath@Gdiplus@@QEBAHMMPEBVPen@2@PEBVGraphics@2@@Z"]
    pub fn GraphicsPath_IsOutlineVisible(
        this: *const GraphicsPath,
        x: REAL,
        y: REAL,
        pen: *const Pen,
        g: *const Graphics,
    ) -> BOOL;
}
extern "C" {
    #[link_name = "\u{1}?IsOutlineVisible@GraphicsPath@Gdiplus@@QEBAHHHPEBVPen@2@PEBVGraphics@2@@Z"]
    pub fn GraphicsPath_IsOutlineVisible1(
        this: *const GraphicsPath,
        x: INT,
        y: INT,
        pen: *const Pen,
        g: *const Graphics,
    ) -> BOOL;
}
impl GraphicsPath {
    #[inline]
    pub unsafe fn GetBounds(
        &self,
        bounds: *mut RectF,
        matrix: *const Matrix,
        pen: *const Pen,
    ) -> Status {
        GraphicsPath_GetBounds(self, bounds, matrix, pen)
    }
    #[inline]
    pub unsafe fn GetBounds1(
        &self,
        bounds: *mut Rect,
        matrix: *const Matrix,
        pen: *const Pen,
    ) -> Status {
        GraphicsPath_GetBounds1(self, bounds, matrix, pen)
    }
    #[inline]
    pub unsafe fn IsVisible(&self, x: REAL, y: REAL, g: *const Graphics) -> BOOL {
        GraphicsPath_IsVisible(self, x, y, g)
    }
    #[inline]
    pub unsafe fn IsVisible1(&self, x: INT, y: INT, g: *const Graphics) -> BOOL {
        GraphicsPath_IsVisible1(self, x, y, g)
    }
    #[inline]
    pub unsafe fn IsOutlineVisible(
        &self,
        x: REAL,
        y: REAL,
        pen: *const Pen,
        g: *const Graphics,
    ) -> BOOL {
        GraphicsPath_IsOutlineVisible(self, x, y, pen, g)
    }
    #[inline]
    pub unsafe fn IsOutlineVisible1(
        &self,
        x: INT,
        y: INT,
        pen: *const Pen,
        g: *const Graphics,
    ) -> BOOL {
        GraphicsPath_IsOutlineVisible1(self, x, y, pen, g)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Graphics {
    pub nativeGraphics: *mut GpGraphics,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Graphics() {
    assert_eq!(
        ::core::mem::size_of::<Graphics>(),
        16usize,
        concat!("Size of: ", stringify!(Graphics))
    );
    assert_eq!(
        ::core::mem::align_of::<Graphics>(),
        8usize,
        concat!("Alignment of ", stringify!(Graphics))
    );
    fn test_field_nativeGraphics() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Graphics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeGraphics) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Graphics),
                "::",
                stringify!(nativeGraphics)
            )
        );
    }
    test_field_nativeGraphics();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Graphics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Graphics),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
