use windows_sys::{
    core::*,
    Win32::{Foundation::*, Graphics::Gdi::*, System::Com::IStream, UI::WindowsAndMessaging::*},
};
type CLSID = GUID;
type LPWSTR = PWSTR;

/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type size_t = ::core::ffi::c_uint;
pub type ULONG = ::core::ffi::c_ulong;
pub type DWORD = ::core::ffi::c_ulong;
pub type BOOL = ::core::ffi::c_int;
pub type BYTE = ::core::ffi::c_uchar;
pub type WORD = ::core::ffi::c_ushort;
pub type LPBYTE = *mut BYTE;
pub type INT = ::core::ffi::c_int;
pub type UINT = ::core::ffi::c_uint;
pub type INT16 = ::core::ffi::c_short;
pub type UINT16 = ::core::ffi::c_ushort;
pub type UINT32 = ::core::ffi::c_uint;
pub type UINT_PTR = *mut ::core::ffi::c_uint;
pub type ULONG_PTR = *mut ::core::ffi::c_ulong;
pub type CHAR = ::core::ffi::c_char;
pub type LONG = ::core::ffi::c_long;
pub type WCHAR = u16;
pub type HRESULT = ::core::ffi::c_long;
pub type LANGID = WORD;
pub type LONGLONG = ::core::ffi::c_longlong;
pub type ULONGLONG = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_QuadPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_LARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_LARGE_INTEGER),
                "::",
                stringify!(QuadPart)
            )
        );
    }
    test_field_QuadPart();
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_1),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    fn test_field_LowPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(LowPart)
            )
        );
    }
    test_field_LowPart();
    fn test_field_HighPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER__bindgen_ty_2),
                "::",
                stringify!(HighPart)
            )
        );
    }
    test_field_HighPart();
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
    fn test_field_QuadPart() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<_ULARGE_INTEGER>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ULARGE_INTEGER),
                "::",
                stringify!(QuadPart)
            )
        );
    }
    test_field_QuadPart();
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type IID = GUID;
pub type SIZEL = SIZE;
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type PROPID = ULONG;
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
    pub vtable_: *const IUnknown__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_IUnknown() {
    assert_eq!(
        ::core::mem::size_of::<IUnknown>(),
        4usize,
        concat!("Size of: ", stringify!(IUnknown))
    );
    assert_eq!(
        ::core::mem::align_of::<IUnknown>(),
        4usize,
        concat!("Alignment of ", stringify!(IUnknown))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
    pub _base: IUnknown,
}
#[test]
fn bindgen_test_layout_ISequentialStream() {
    assert_eq!(
        ::core::mem::size_of::<ISequentialStream>(),
        4usize,
        concat!("Size of: ", stringify!(ISequentialStream))
    );
    assert_eq!(
        ::core::mem::align_of::<ISequentialStream>(),
        4usize,
        concat!("Alignment of ", stringify!(ISequentialStream))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDirectDrawSurface7 {
    _unused: [u8; 0],
}
extern "stdcall" {
    pub fn GdipAlloc(size: size_t) -> *mut ::core::ffi::c_void;
}
extern "stdcall" {
    pub fn GdipFree(ptr: *mut ::core::ffi::c_void);
}
extern "stdcall" {
    pub fn GdipCreatePath(brushMode: GpFillMode, path: *mut *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePath2(
        arg1: *const GpPointF,
        arg2: *const BYTE,
        arg3: INT,
        arg4: GpFillMode,
        path: *mut *mut GpPath,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePath2I(
        arg1: *const GpPoint,
        arg2: *const BYTE,
        arg3: INT,
        arg4: GpFillMode,
        path: *mut *mut GpPath,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipClonePath(path: *mut GpPath, clonePath: *mut *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeletePath(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetPath(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPointCount(path: *mut GpPath, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathTypes(path: *mut GpPath, types: *mut BYTE, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathPoints(arg1: *mut GpPath, points: *mut GpPointF, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathPointsI(arg1: *mut GpPath, points: *mut GpPoint, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathFillMode(path: *mut GpPath, fillmode: *mut GpFillMode) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathFillMode(path: *mut GpPath, fillmode: GpFillMode) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathData(path: *mut GpPath, pathData: *mut GpPathData) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipStartPathFigure(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipClosePathFigure(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipClosePathFigures(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathMarker(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipClearPathMarkers(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipReversePath(path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathLastPoint(path: *mut GpPath, lastPoint: *mut GpPointF) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathLine(path: *mut GpPath, x1: REAL, y1: REAL, x2: REAL, y2: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathLine2(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathArc(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathBezier(
        path: *mut GpPath,
        x1: REAL,
        y1: REAL,
        x2: REAL,
        y2: REAL,
        x3: REAL,
        y3: REAL,
        x4: REAL,
        y4: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathBeziers(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathCurve(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathCurve2(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathCurve3(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathClosedCurve(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathClosedCurve2(
        path: *mut GpPath,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathRectangle(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathRectangles(path: *mut GpPath, rects: *const GpRectF, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathEllipse(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathPie(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathPolygon(path: *mut GpPath, points: *const GpPointF, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathPath(path: *mut GpPath, addingPath: *const GpPath, connect: BOOL)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathString(
        path: *mut GpPath,
        string: *const WCHAR,
        length: INT,
        family: *const GpFontFamily,
        style: INT,
        emSize: REAL,
        layoutRect: *const RectF,
        format: *const GpStringFormat,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathStringI(
        path: *mut GpPath,
        string: *const WCHAR,
        length: INT,
        family: *const GpFontFamily,
        style: INT,
        emSize: REAL,
        layoutRect: *const Rect,
        format: *const GpStringFormat,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathLineI(path: *mut GpPath, x1: INT, y1: INT, x2: INT, y2: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathLine2I(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathArcI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathBezierI(
        path: *mut GpPath,
        x1: INT,
        y1: INT,
        x2: INT,
        y2: INT,
        x3: INT,
        y3: INT,
        x4: INT,
        y4: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathBeziersI(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathCurveI(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathCurve2I(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathCurve3I(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathClosedCurveI(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathClosedCurve2I(
        path: *mut GpPath,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathRectangleI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathRectanglesI(path: *mut GpPath, rects: *const GpRect, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathEllipseI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathPieI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipAddPathPolygonI(path: *mut GpPath, points: *const GpPoint, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFlattenPath(path: *mut GpPath, matrix: *mut GpMatrix, flatness: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipWindingModeOutline(
        path: *mut GpPath,
        matrix: *mut GpMatrix,
        flatness: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipWidenPath(
        nativePath: *mut GpPath,
        pen: *mut GpPen,
        matrix: *mut GpMatrix,
        flatness: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipWarpPath(
        path: *mut GpPath,
        matrix: *mut GpMatrix,
        points: *const GpPointF,
        count: INT,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        warpMode: WarpMode,
        flatness: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTransformPath(path: *mut GpPath, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathWorldBounds(
        path: *mut GpPath,
        bounds: *mut GpRectF,
        matrix: *const GpMatrix,
        pen: *const GpPen,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathWorldBoundsI(
        path: *mut GpPath,
        bounds: *mut GpRect,
        matrix: *const GpMatrix,
        pen: *const GpPen,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisiblePathPoint(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisiblePathPointI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsOutlineVisiblePathPoint(
        path: *mut GpPath,
        x: REAL,
        y: REAL,
        pen: *mut GpPen,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsOutlineVisiblePathPointI(
        path: *mut GpPath,
        x: INT,
        y: INT,
        pen: *mut GpPen,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePathIter(iterator: *mut *mut GpPathIterator, path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeletePathIter(iterator: *mut GpPathIterator) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterNextSubpath(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        startIndex: *mut INT,
        endIndex: *mut INT,
        isClosed: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterNextSubpathPath(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        path: *mut GpPath,
        isClosed: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterNextPathType(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        pathType: *mut BYTE,
        startIndex: *mut INT,
        endIndex: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterNextMarker(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        startIndex: *mut INT,
        endIndex: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterNextMarkerPath(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        path: *mut GpPath,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterGetCount(iterator: *mut GpPathIterator, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterGetSubpathCount(iterator: *mut GpPathIterator, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterIsValid(iterator: *mut GpPathIterator, valid: *mut BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterHasCurve(iterator: *mut GpPathIterator, hasCurve: *mut BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterRewind(iterator: *mut GpPathIterator) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterEnumerate(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        points: *mut GpPointF,
        types: *mut BYTE,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPathIterCopyData(
        iterator: *mut GpPathIterator,
        resultCount: *mut INT,
        points: *mut GpPointF,
        types: *mut BYTE,
        startIndex: INT,
        endIndex: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMatrix(matrix: *mut *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMatrix2(
        m11: REAL,
        m12: REAL,
        m21: REAL,
        m22: REAL,
        dx: REAL,
        dy: REAL,
        matrix: *mut *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMatrix3(
        rect: *const GpRectF,
        dstplg: *const GpPointF,
        matrix: *mut *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMatrix3I(
        rect: *const GpRect,
        dstplg: *const GpPoint,
        matrix: *mut *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneMatrix(matrix: *mut GpMatrix, cloneMatrix: *mut *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteMatrix(matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetMatrixElements(
        matrix: *mut GpMatrix,
        m11: REAL,
        m12: REAL,
        m21: REAL,
        m22: REAL,
        dx: REAL,
        dy: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMultiplyMatrix(
        matrix: *mut GpMatrix,
        matrix2: *mut GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateMatrix(
        matrix: *mut GpMatrix,
        offsetX: REAL,
        offsetY: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipScaleMatrix(
        matrix: *mut GpMatrix,
        scaleX: REAL,
        scaleY: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRotateMatrix(matrix: *mut GpMatrix, angle: REAL, order: GpMatrixOrder) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipShearMatrix(
        matrix: *mut GpMatrix,
        shearX: REAL,
        shearY: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipInvertMatrix(matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTransformMatrixPoints(
        matrix: *mut GpMatrix,
        pts: *mut GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTransformMatrixPointsI(
        matrix: *mut GpMatrix,
        pts: *mut GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipVectorTransformMatrixPoints(
        matrix: *mut GpMatrix,
        pts: *mut GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipVectorTransformMatrixPointsI(
        matrix: *mut GpMatrix,
        pts: *mut GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetMatrixElements(matrix: *const GpMatrix, matrixOut: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsMatrixInvertible(matrix: *const GpMatrix, result: *mut BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsMatrixIdentity(matrix: *const GpMatrix, result: *mut BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsMatrixEqual(
        matrix: *const GpMatrix,
        matrix2: *const GpMatrix,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateRegion(region: *mut *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateRegionRect(rect: *const GpRectF, region: *mut *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateRegionRectI(rect: *const GpRect, region: *mut *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateRegionPath(path: *mut GpPath, region: *mut *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateRegionRgnData(
        regionData: *const BYTE,
        size: INT,
        region: *mut *mut GpRegion,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateRegionHrgn(hRgn: HRGN, region: *mut *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneRegion(region: *mut GpRegion, cloneRegion: *mut *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteRegion(region: *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetInfinite(region: *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetEmpty(region: *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCombineRegionRect(
        region: *mut GpRegion,
        rect: *const GpRectF,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCombineRegionRectI(
        region: *mut GpRegion,
        rect: *const GpRect,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCombineRegionPath(
        region: *mut GpRegion,
        path: *mut GpPath,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCombineRegionRegion(
        region: *mut GpRegion,
        region2: *mut GpRegion,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateRegion(region: *mut GpRegion, dx: REAL, dy: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateRegionI(region: *mut GpRegion, dx: INT, dy: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTransformRegion(region: *mut GpRegion, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionBounds(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        rect: *mut GpRectF,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionBoundsI(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        rect: *mut GpRect,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionHRgn(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        hRgn: *mut HRGN,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsEmptyRegion(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsInfiniteRegion(
        region: *mut GpRegion,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsEqualRegion(
        region: *mut GpRegion,
        region2: *mut GpRegion,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionDataSize(region: *mut GpRegion, bufferSize: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionData(
        region: *mut GpRegion,
        buffer: *mut BYTE,
        bufferSize: UINT,
        sizeFilled: *mut UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleRegionPoint(
        region: *mut GpRegion,
        x: REAL,
        y: REAL,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleRegionPointI(
        region: *mut GpRegion,
        x: INT,
        y: INT,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleRegionRect(
        region: *mut GpRegion,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleRegionRectI(
        region: *mut GpRegion,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        graphics: *mut GpGraphics,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionScansCount(
        region: *mut GpRegion,
        count: *mut UINT,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionScans(
        region: *mut GpRegion,
        rects: *mut GpRectF,
        count: *mut INT,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRegionScansI(
        region: *mut GpRegion,
        rects: *mut GpRect,
        count: *mut INT,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneBrush(brush: *mut GpBrush, cloneBrush: *mut *mut GpBrush) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteBrush(brush: *mut GpBrush) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetBrushType(brush: *mut GpBrush, type_: *mut GpBrushType) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateHatchBrush(
        hatchstyle: GpHatchStyle,
        forecol: ARGB,
        backcol: ARGB,
        brush: *mut *mut GpHatch,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetHatchStyle(brush: *mut GpHatch, hatchstyle: *mut GpHatchStyle) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetHatchForegroundColor(brush: *mut GpHatch, forecol: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetHatchBackgroundColor(brush: *mut GpHatch, backcol: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateTexture(
        image: *mut GpImage,
        wrapmode: GpWrapMode,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateTexture2(
        image: *mut GpImage,
        wrapmode: GpWrapMode,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateTextureIA(
        image: *mut GpImage,
        imageAttributes: *const GpImageAttributes,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateTexture2I(
        image: *mut GpImage,
        wrapmode: GpWrapMode,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateTextureIAI(
        image: *mut GpImage,
        imageAttributes: *const GpImageAttributes,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        texture: *mut *mut GpTexture,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetTextureTransform(brush: *mut GpTexture, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetTextureTransform(brush: *mut GpTexture, matrix: *const GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetTextureTransform(brush: *mut GpTexture) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMultiplyTextureTransform(
        brush: *mut GpTexture,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateTextureTransform(
        brush: *mut GpTexture,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipScaleTextureTransform(
        brush: *mut GpTexture,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRotateTextureTransform(
        brush: *mut GpTexture,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetTextureWrapMode(brush: *mut GpTexture, wrapmode: GpWrapMode) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetTextureWrapMode(brush: *mut GpTexture, wrapmode: *mut GpWrapMode) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetTextureImage(brush: *mut GpTexture, image: *mut *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateSolidFill(color: ARGB, brush: *mut *mut GpSolidFill) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetSolidFillColor(brush: *mut GpSolidFill, color: ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetSolidFillColor(brush: *mut GpSolidFill, color: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateLineBrush(
        point1: *const GpPointF,
        point2: *const GpPointF,
        color1: ARGB,
        color2: ARGB,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateLineBrushI(
        point1: *const GpPoint,
        point2: *const GpPoint,
        color1: ARGB,
        color2: ARGB,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateLineBrushFromRect(
        rect: *const GpRectF,
        color1: ARGB,
        color2: ARGB,
        mode: LinearGradientMode,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateLineBrushFromRectI(
        rect: *const GpRect,
        color1: ARGB,
        color2: ARGB,
        mode: LinearGradientMode,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateLineBrushFromRectWithAngle(
        rect: *const GpRectF,
        color1: ARGB,
        color2: ARGB,
        angle: REAL,
        isAngleScalable: BOOL,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateLineBrushFromRectWithAngleI(
        rect: *const GpRect,
        color1: ARGB,
        color2: ARGB,
        angle: REAL,
        isAngleScalable: BOOL,
        wrapMode: GpWrapMode,
        lineGradient: *mut *mut GpLineGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineColors(brush: *mut GpLineGradient, color1: ARGB, color2: ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineColors(brush: *mut GpLineGradient, colors: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineRect(brush: *mut GpLineGradient, rect: *mut GpRectF) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineRectI(brush: *mut GpLineGradient, rect: *mut GpRect) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineGammaCorrection(
        brush: *mut GpLineGradient,
        useGammaCorrection: BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineGammaCorrection(
        brush: *mut GpLineGradient,
        useGammaCorrection: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineBlendCount(brush: *mut GpLineGradient, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineBlend(
        brush: *mut GpLineGradient,
        blend: *mut REAL,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineBlend(
        brush: *mut GpLineGradient,
        blend: *const REAL,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLinePresetBlendCount(brush: *mut GpLineGradient, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLinePresetBlend(
        brush: *mut GpLineGradient,
        blend: *mut ARGB,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLinePresetBlend(
        brush: *mut GpLineGradient,
        blend: *const ARGB,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineSigmaBlend(brush: *mut GpLineGradient, focus: REAL, scale: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineLinearBlend(brush: *mut GpLineGradient, focus: REAL, scale: REAL)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineWrapMode(brush: *mut GpLineGradient, wrapmode: GpWrapMode) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineWrapMode(brush: *mut GpLineGradient, wrapmode: *mut GpWrapMode) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineTransform(brush: *mut GpLineGradient, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetLineTransform(brush: *mut GpLineGradient, matrix: *const GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetLineTransform(brush: *mut GpLineGradient) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMultiplyLineTransform(
        brush: *mut GpLineGradient,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateLineTransform(
        brush: *mut GpLineGradient,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipScaleLineTransform(
        brush: *mut GpLineGradient,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRotateLineTransform(
        brush: *mut GpLineGradient,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePathGradient(
        points: *const GpPointF,
        count: INT,
        wrapMode: GpWrapMode,
        polyGradient: *mut *mut GpPathGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePathGradientI(
        points: *const GpPoint,
        count: INT,
        wrapMode: GpWrapMode,
        polyGradient: *mut *mut GpPathGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePathGradientFromPath(
        path: *const GpPath,
        polyGradient: *mut *mut GpPathGradient,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientCenterColor(
        brush: *mut GpPathGradient,
        colors: *mut ARGB,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientCenterColor(brush: *mut GpPathGradient, colors: ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientSurroundColorsWithCount(
        brush: *mut GpPathGradient,
        color: *mut ARGB,
        count: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientSurroundColorsWithCount(
        brush: *mut GpPathGradient,
        color: *const ARGB,
        count: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientPath(brush: *mut GpPathGradient, path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientPath(brush: *mut GpPathGradient, path: *const GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientCenterPoint(
        brush: *mut GpPathGradient,
        points: *mut GpPointF,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientCenterPointI(
        brush: *mut GpPathGradient,
        points: *mut GpPoint,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientCenterPoint(
        brush: *mut GpPathGradient,
        points: *const GpPointF,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientCenterPointI(
        brush: *mut GpPathGradient,
        points: *const GpPoint,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientRect(brush: *mut GpPathGradient, rect: *mut GpRectF) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientRectI(brush: *mut GpPathGradient, rect: *mut GpRect) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientPointCount(brush: *mut GpPathGradient, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientSurroundColorCount(
        brush: *mut GpPathGradient,
        count: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientGammaCorrection(
        brush: *mut GpPathGradient,
        useGammaCorrection: BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientGammaCorrection(
        brush: *mut GpPathGradient,
        useGammaCorrection: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientBlendCount(brush: *mut GpPathGradient, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientBlend(
        brush: *mut GpPathGradient,
        blend: *mut REAL,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientBlend(
        brush: *mut GpPathGradient,
        blend: *const REAL,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientPresetBlendCount(
        brush: *mut GpPathGradient,
        count: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientPresetBlend(
        brush: *mut GpPathGradient,
        blend: *mut ARGB,
        positions: *mut REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientPresetBlend(
        brush: *mut GpPathGradient,
        blend: *const ARGB,
        positions: *const REAL,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientSigmaBlend(
        brush: *mut GpPathGradient,
        focus: REAL,
        scale: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientLinearBlend(
        brush: *mut GpPathGradient,
        focus: REAL,
        scale: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientWrapMode(
        brush: *mut GpPathGradient,
        wrapmode: *mut GpWrapMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientWrapMode(
        brush: *mut GpPathGradient,
        wrapmode: GpWrapMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientTransform(
        brush: *mut GpPathGradient,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientTransform(
        brush: *mut GpPathGradient,
        matrix: *mut GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetPathGradientTransform(brush: *mut GpPathGradient) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMultiplyPathGradientTransform(
        brush: *mut GpPathGradient,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslatePathGradientTransform(
        brush: *mut GpPathGradient,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipScalePathGradientTransform(
        brush: *mut GpPathGradient,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRotatePathGradientTransform(
        brush: *mut GpPathGradient,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPathGradientFocusScales(
        brush: *mut GpPathGradient,
        xScale: *mut REAL,
        yScale: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPathGradientFocusScales(
        brush: *mut GpPathGradient,
        xScale: REAL,
        yScale: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePen1(color: ARGB, width: REAL, unit: GpUnit, pen: *mut *mut GpPen)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreatePen2(
        brush: *mut GpBrush,
        width: REAL,
        unit: GpUnit,
        pen: *mut *mut GpPen,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipClonePen(pen: *mut GpPen, clonepen: *mut *mut GpPen) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeletePen(pen: *mut GpPen) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenWidth(pen: *mut GpPen, width: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenWidth(pen: *mut GpPen, width: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenUnit(pen: *mut GpPen, unit: GpUnit) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenUnit(pen: *mut GpPen, unit: *mut GpUnit) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenLineCap197819(
        pen: *mut GpPen,
        startCap: GpLineCap,
        endCap: GpLineCap,
        dashCap: GpDashCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenStartCap(pen: *mut GpPen, startCap: GpLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenEndCap(pen: *mut GpPen, endCap: GpLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenDashCap197819(pen: *mut GpPen, dashCap: GpDashCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenStartCap(pen: *mut GpPen, startCap: *mut GpLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenEndCap(pen: *mut GpPen, endCap: *mut GpLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenDashCap197819(pen: *mut GpPen, dashCap: *mut GpDashCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenLineJoin(pen: *mut GpPen, lineJoin: GpLineJoin) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenLineJoin(pen: *mut GpPen, lineJoin: *mut GpLineJoin) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenCustomStartCap(pen: *mut GpPen, customCap: *mut GpCustomLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenCustomStartCap(
        pen: *mut GpPen,
        customCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenCustomEndCap(pen: *mut GpPen, customCap: *mut GpCustomLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenCustomEndCap(
        pen: *mut GpPen,
        customCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenMiterLimit(pen: *mut GpPen, miterLimit: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenMiterLimit(pen: *mut GpPen, miterLimit: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenMode(pen: *mut GpPen, penMode: GpPenAlignment) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenMode(pen: *mut GpPen, penMode: *mut GpPenAlignment) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenTransform(pen: *mut GpPen, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenTransform(pen: *mut GpPen, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetPenTransform(pen: *mut GpPen) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMultiplyPenTransform(
        pen: *mut GpPen,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslatePenTransform(
        pen: *mut GpPen,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipScalePenTransform(
        pen: *mut GpPen,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRotatePenTransform(pen: *mut GpPen, angle: REAL, order: GpMatrixOrder) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenColor(pen: *mut GpPen, argb: ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenColor(pen: *mut GpPen, argb: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenBrushFill(pen: *mut GpPen, brush: *mut GpBrush) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenBrushFill(pen: *mut GpPen, brush: *mut *mut GpBrush) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenFillType(pen: *mut GpPen, type_: *mut GpPenType) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenDashStyle(pen: *mut GpPen, dashstyle: *mut GpDashStyle) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenDashStyle(pen: *mut GpPen, dashstyle: GpDashStyle) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenDashOffset(pen: *mut GpPen, offset: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenDashOffset(pen: *mut GpPen, offset: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenDashCount(pen: *mut GpPen, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenDashArray(pen: *mut GpPen, dash: *const REAL, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenDashArray(pen: *mut GpPen, dash: *mut REAL, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenCompoundCount(pen: *mut GpPen, count: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPenCompoundArray(pen: *mut GpPen, dash: *const REAL, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPenCompoundArray(pen: *mut GpPen, dash: *mut REAL, count: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateCustomLineCap(
        fillPath: *mut GpPath,
        strokePath: *mut GpPath,
        baseCap: GpLineCap,
        baseInset: REAL,
        customCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteCustomLineCap(customCap: *mut GpCustomLineCap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneCustomLineCap(
        customCap: *mut GpCustomLineCap,
        clonedCap: *mut *mut GpCustomLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCustomLineCapType(
        customCap: *mut GpCustomLineCap,
        capType: *mut CustomLineCapType,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCustomLineCapStrokeCaps(
        customCap: *mut GpCustomLineCap,
        startCap: GpLineCap,
        endCap: GpLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCustomLineCapStrokeCaps(
        customCap: *mut GpCustomLineCap,
        startCap: *mut GpLineCap,
        endCap: *mut GpLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCustomLineCapStrokeJoin(
        customCap: *mut GpCustomLineCap,
        lineJoin: GpLineJoin,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCustomLineCapStrokeJoin(
        customCap: *mut GpCustomLineCap,
        lineJoin: *mut GpLineJoin,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCustomLineCapBaseCap(
        customCap: *mut GpCustomLineCap,
        baseCap: GpLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCustomLineCapBaseCap(
        customCap: *mut GpCustomLineCap,
        baseCap: *mut GpLineCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCustomLineCapBaseInset(customCap: *mut GpCustomLineCap, inset: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCustomLineCapBaseInset(
        customCap: *mut GpCustomLineCap,
        inset: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCustomLineCapWidthScale(
        customCap: *mut GpCustomLineCap,
        widthScale: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCustomLineCapWidthScale(
        customCap: *mut GpCustomLineCap,
        widthScale: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateAdjustableArrowCap(
        height: REAL,
        width: REAL,
        isFilled: BOOL,
        cap: *mut *mut GpAdjustableArrowCap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetAdjustableArrowCapHeight(
        cap: *mut GpAdjustableArrowCap,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetAdjustableArrowCapHeight(
        cap: *mut GpAdjustableArrowCap,
        height: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetAdjustableArrowCapWidth(cap: *mut GpAdjustableArrowCap, width: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetAdjustableArrowCapWidth(
        cap: *mut GpAdjustableArrowCap,
        width: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetAdjustableArrowCapMiddleInset(
        cap: *mut GpAdjustableArrowCap,
        middleInset: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetAdjustableArrowCapMiddleInset(
        cap: *mut GpAdjustableArrowCap,
        middleInset: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetAdjustableArrowCapFillState(
        cap: *mut GpAdjustableArrowCap,
        fillState: BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetAdjustableArrowCapFillState(
        cap: *mut GpAdjustableArrowCap,
        fillState: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipLoadImageFromStream(stream: *mut IStream, image: *mut *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipLoadImageFromFile(filename: *const WCHAR, image: *mut *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipLoadImageFromStreamICM(stream: *mut IStream, image: *mut *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipLoadImageFromFileICM(filename: *const WCHAR, image: *mut *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneImage(image: *mut GpImage, cloneImage: *mut *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDisposeImage(image: *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSaveImageToFile(
        image: *mut GpImage,
        filename: *const WCHAR,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSaveImageToStream(
        image: *mut GpImage,
        stream: *mut IStream,
        clsidEncoder: *const CLSID,
        encoderParams: *const EncoderParameters,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSaveAdd(image: *mut GpImage, encoderParams: *const EncoderParameters) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSaveAddImage(
        image: *mut GpImage,
        newImage: *mut GpImage,
        encoderParams: *const EncoderParameters,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageGraphicsContext(
        image: *mut GpImage,
        graphics: *mut *mut GpGraphics,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageBounds(
        image: *mut GpImage,
        srcRect: *mut GpRectF,
        srcUnit: *mut GpUnit,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageDimension(
        image: *mut GpImage,
        width: *mut REAL,
        height: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageType(image: *mut GpImage, type_: *mut ImageType) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageWidth(image: *mut GpImage, width: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageHeight(image: *mut GpImage, height: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageHorizontalResolution(image: *mut GpImage, resolution: *mut REAL)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageVerticalResolution(image: *mut GpImage, resolution: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageFlags(image: *mut GpImage, flags: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageRawFormat(image: *mut GpImage, format: *mut GUID) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImagePixelFormat(image: *mut GpImage, format: *mut PixelFormat) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageThumbnail(
        image: *mut GpImage,
        thumbWidth: UINT,
        thumbHeight: UINT,
        thumbImage: *mut *mut GpImage,
        callback: GetThumbnailImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetEncoderParameterListSize(
        image: *mut GpImage,
        clsidEncoder: *const CLSID,
        size: *mut UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetEncoderParameterList(
        image: *mut GpImage,
        clsidEncoder: *const CLSID,
        size: UINT,
        buffer: *mut EncoderParameters,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipImageGetFrameDimensionsCount(image: *mut GpImage, count: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipImageGetFrameDimensionsList(
        image: *mut GpImage,
        dimensionIDs: *mut GUID,
        count: UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipImageGetFrameCount(
        image: *mut GpImage,
        dimensionID: *const GUID,
        count: *mut UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipImageSelectActiveFrame(
        image: *mut GpImage,
        dimensionID: *const GUID,
        frameIndex: UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipImageRotateFlip(image: *mut GpImage, rfType: RotateFlipType) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImagePalette(
        image: *mut GpImage,
        palette: *mut ColorPalette,
        size: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImagePalette(image: *mut GpImage, palette: *const ColorPalette) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImagePaletteSize(image: *mut GpImage, size: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPropertyCount(image: *mut GpImage, numOfProperty: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPropertyIdList(
        image: *mut GpImage,
        numOfProperty: UINT,
        list: *mut PROPID,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPropertyItemSize(
        image: *mut GpImage,
        propId: PROPID,
        size: *mut UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPropertyItem(
        image: *mut GpImage,
        propId: PROPID,
        propSize: UINT,
        buffer: *mut PropertyItem,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPropertySize(
        image: *mut GpImage,
        totalBufferSize: *mut UINT,
        numProperties: *mut UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetAllPropertyItems(
        image: *mut GpImage,
        totalBufferSize: UINT,
        numProperties: UINT,
        allItems: *mut PropertyItem,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRemovePropertyItem(image: *mut GpImage, propId: PROPID) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPropertyItem(image: *mut GpImage, item: *const PropertyItem) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipImageForceValidation(image: *mut GpImage) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromStream(stream: *mut IStream, bitmap: *mut *mut GpBitmap)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromFile(filename: *const WCHAR, bitmap: *mut *mut GpBitmap)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromStreamICM(
        stream: *mut IStream,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromFileICM(
        filename: *const WCHAR,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromScan0(
        width: INT,
        height: INT,
        stride: INT,
        format: PixelFormat,
        scan0: *mut BYTE,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromGraphics(
        width: INT,
        height: INT,
        target: *mut GpGraphics,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromDirectDrawSurface(
        surface: *mut IDirectDrawSurface7,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromGdiDib(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromHBITMAP(
        hbm: HBITMAP,
        hpal: HPALETTE,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateHBITMAPFromBitmap(
        bitmap: *mut GpBitmap,
        hbmReturn: *mut HBITMAP,
        background: ARGB,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromHICON(hicon: HICON, bitmap: *mut *mut GpBitmap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateHICONFromBitmap(bitmap: *mut GpBitmap, hbmReturn: *mut HICON) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateBitmapFromResource(
        hInstance: HINSTANCE,
        lpBitmapName: *const WCHAR,
        bitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneBitmapArea(
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        format: PixelFormat,
        srcBitmap: *mut GpBitmap,
        dstBitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneBitmapAreaI(
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        format: PixelFormat,
        srcBitmap: *mut GpBitmap,
        dstBitmap: *mut *mut GpBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBitmapLockBits(
        bitmap: *mut GpBitmap,
        rect: *const GpRect,
        flags: UINT,
        format: PixelFormat,
        lockedBitmapData: *mut BitmapData,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBitmapUnlockBits(
        bitmap: *mut GpBitmap,
        lockedBitmapData: *mut BitmapData,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBitmapGetPixel(bitmap: *mut GpBitmap, x: INT, y: INT, color: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBitmapSetPixel(bitmap: *mut GpBitmap, x: INT, y: INT, color: ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBitmapSetResolution(bitmap: *mut GpBitmap, xdpi: REAL, ydpi: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateImageAttributes(imageattr: *mut *mut GpImageAttributes) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneImageAttributes(
        imageattr: *const GpImageAttributes,
        cloneImageattr: *mut *mut GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDisposeImageAttributes(imageattr: *mut GpImageAttributes) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesToIdentity(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetImageAttributes(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesColorMatrix(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        colorMatrix: *const ColorMatrix,
        grayMatrix: *const ColorMatrix,
        flags: ColorMatrixFlags,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesThreshold(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        threshold: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesGamma(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        gamma: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesNoOp(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesColorKeys(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        colorLow: ARGB,
        colorHigh: ARGB,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesOutputChannel(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        channelFlags: ColorChannelFlags,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesOutputChannelColorProfile(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        colorProfileFilename: *const WCHAR,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesRemapTable(
        imageattr: *mut GpImageAttributes,
        type_: ColorAdjustType,
        enableFlag: BOOL,
        mapSize: UINT,
        map: *const ColorMap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesWrapMode(
        imageAttr: *mut GpImageAttributes,
        wrap: WrapMode,
        argb: ARGB,
        clamp: BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesICMMode(imageAttr: *mut GpImageAttributes, on: BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageAttributesAdjustedPalette(
        imageAttr: *mut GpImageAttributes,
        colorPalette: *mut ColorPalette,
        colorAdjustType: ColorAdjustType,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFlush(graphics: *mut GpGraphics, intention: GpFlushIntention) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFromHDC(hdc: HDC, graphics: *mut *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFromHDC2(
        hdc: HDC,
        hDevice: HANDLE,
        graphics: *mut *mut GpGraphics,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFromHWND(hwnd: HWND, graphics: *mut *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFromHWNDICM(hwnd: HWND, graphics: *mut *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteGraphics(graphics: *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetDC(graphics: *mut GpGraphics, hdc: *mut HDC) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipReleaseDC(graphics: *mut GpGraphics, hdc: HDC) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCompositingMode(
        graphics: *mut GpGraphics,
        compositingMode: CompositingMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCompositingMode(
        graphics: *mut GpGraphics,
        compositingMode: *mut CompositingMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetRenderingOrigin(graphics: *mut GpGraphics, x: INT, y: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetRenderingOrigin(graphics: *mut GpGraphics, x: *mut INT, y: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetCompositingQuality(
        graphics: *mut GpGraphics,
        compositingQuality: CompositingQuality,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCompositingQuality(
        graphics: *mut GpGraphics,
        compositingQuality: *mut CompositingQuality,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetSmoothingMode(
        graphics: *mut GpGraphics,
        smoothingMode: SmoothingMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetSmoothingMode(
        graphics: *mut GpGraphics,
        smoothingMode: *mut SmoothingMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPixelOffsetMode(
        graphics: *mut GpGraphics,
        pixelOffsetMode: PixelOffsetMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPixelOffsetMode(
        graphics: *mut GpGraphics,
        pixelOffsetMode: *mut PixelOffsetMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetTextRenderingHint(graphics: *mut GpGraphics, mode: TextRenderingHint)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetTextRenderingHint(
        graphics: *mut GpGraphics,
        mode: *mut TextRenderingHint,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetTextContrast(graphics: *mut GpGraphics, contrast: UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetTextContrast(graphics: *mut GpGraphics, contrast: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetInterpolationMode(
        graphics: *mut GpGraphics,
        interpolationMode: InterpolationMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetInterpolationMode(
        graphics: *mut GpGraphics,
        interpolationMode: *mut InterpolationMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetWorldTransform(graphics: *mut GpGraphics, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetWorldTransform(graphics: *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMultiplyWorldTransform(
        graphics: *mut GpGraphics,
        matrix: *const GpMatrix,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateWorldTransform(
        graphics: *mut GpGraphics,
        dx: REAL,
        dy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipScaleWorldTransform(
        graphics: *mut GpGraphics,
        sx: REAL,
        sy: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRotateWorldTransform(
        graphics: *mut GpGraphics,
        angle: REAL,
        order: GpMatrixOrder,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetWorldTransform(graphics: *mut GpGraphics, matrix: *mut GpMatrix) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetPageTransform(graphics: *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPageUnit(graphics: *mut GpGraphics, unit: *mut GpUnit) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetPageScale(graphics: *mut GpGraphics, scale: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPageUnit(graphics: *mut GpGraphics, unit: GpUnit) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetPageScale(graphics: *mut GpGraphics, scale: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetDpiX(graphics: *mut GpGraphics, dpi: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetDpiY(graphics: *mut GpGraphics, dpi: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTransformPoints(
        graphics: *mut GpGraphics,
        destSpace: GpCoordinateSpace,
        srcSpace: GpCoordinateSpace,
        points: *mut GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTransformPointsI(
        graphics: *mut GpGraphics,
        destSpace: GpCoordinateSpace,
        srcSpace: GpCoordinateSpace,
        points: *mut GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetNearestColor(graphics: *mut GpGraphics, argb: *mut ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateHalftonePalette() -> HPALETTE;
}
extern "stdcall" {
    pub fn GdipDrawLine(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: REAL,
        y1: REAL,
        x2: REAL,
        y2: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawLineI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: INT,
        y1: INT,
        x2: INT,
        y2: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawLines(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawLinesI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawArc(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawArcI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawBezier(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: REAL,
        y1: REAL,
        x2: REAL,
        y2: REAL,
        x3: REAL,
        y3: REAL,
        x4: REAL,
        y4: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawBezierI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x1: INT,
        y1: INT,
        x2: INT,
        y2: INT,
        x3: INT,
        y3: INT,
        x4: INT,
        y4: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawBeziers(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawBeziersI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawRectangle(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawRectangleI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawRectangles(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        rects: *const GpRectF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawRectanglesI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        rects: *const GpRect,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawEllipse(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawEllipseI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawPie(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawPieI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawPolygon(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawPolygonI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawPath(graphics: *mut GpGraphics, pen: *mut GpPen, path: *mut GpPath) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCurve(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCurveI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCurve2(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCurve2I(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCurve3(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCurve3I(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
        offset: INT,
        numberOfSegments: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawClosedCurve(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawClosedCurveI(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawClosedCurve2(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawClosedCurve2I(
        graphics: *mut GpGraphics,
        pen: *mut GpPen,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGraphicsClear(graphics: *mut GpGraphics, color: ARGB) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillRectangle(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillRectangleI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillRectangles(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        rects: *const GpRectF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillRectanglesI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        rects: *const GpRect,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPolygon(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPolygonI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPolygon2(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPolygon2I(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillEllipse(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillEllipseI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPie(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPieI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        startAngle: REAL,
        sweepAngle: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillPath(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        path: *mut GpPath,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillClosedCurve(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillClosedCurveI(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillClosedCurve2(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPointF,
        count: INT,
        tension: REAL,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillClosedCurve2I(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        points: *const GpPoint,
        count: INT,
        tension: REAL,
        fillMode: GpFillMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFillRegion(
        graphics: *mut GpGraphics,
        brush: *mut GpBrush,
        region: *mut GpRegion,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImage(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: REAL,
        y: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImageI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: INT,
        y: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImageRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImageRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImagePoints(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstpoints: *const GpPointF,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImagePointsI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstpoints: *const GpPoint,
        count: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImagePointRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: REAL,
        y: REAL,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        srcUnit: GpUnit,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImagePointRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        x: INT,
        y: INT,
        srcx: INT,
        srcy: INT,
        srcwidth: INT,
        srcheight: INT,
        srcUnit: GpUnit,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImageRectRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstx: REAL,
        dsty: REAL,
        dstwidth: REAL,
        dstheight: REAL,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImageRectRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        dstx: INT,
        dsty: INT,
        dstwidth: INT,
        dstheight: INT,
        srcx: INT,
        srcy: INT,
        srcwidth: INT,
        srcheight: INT,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImagePointsRect(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        points: *const GpPointF,
        count: INT,
        srcx: REAL,
        srcy: REAL,
        srcwidth: REAL,
        srcheight: REAL,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawImagePointsRectI(
        graphics: *mut GpGraphics,
        image: *mut GpImage,
        points: *const GpPoint,
        count: INT,
        srcx: INT,
        srcy: INT,
        srcwidth: INT,
        srcheight: INT,
        srcUnit: GpUnit,
        imageAttributes: *const GpImageAttributes,
        callback: DrawImageAbort,
        callbackData: *mut ::core::ffi::c_void,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileDestPoint(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const PointF,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileDestPointI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const Point,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileDestRect(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const RectF,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileDestRectI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const Rect,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileDestPoints(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const PointF,
        count: INT,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileDestPointsI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const Point,
        count: INT,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileSrcRectDestPoint(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const PointF,
        srcRect: *const RectF,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileSrcRectDestPointI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoint: *const Point,
        srcRect: *const Rect,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileSrcRectDestRect(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const RectF,
        srcRect: *const RectF,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileSrcRectDestRectI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destRect: *const Rect,
        srcRect: *const Rect,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileSrcRectDestPoints(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const PointF,
        count: INT,
        srcRect: *const RectF,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEnumerateMetafileSrcRectDestPointsI(
        graphics: *mut GpGraphics,
        metafile: *const GpMetafile,
        destPoints: *const Point,
        count: INT,
        srcRect: *const Rect,
        srcUnit: Unit,
        callback: EnumerateMetafileProc,
        callbackData: *mut ::core::ffi::c_void,
        imageAttributes: *const GpImageAttributes,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPlayMetafileRecord(
        metafile: *const GpMetafile,
        recordType: EmfPlusRecordType,
        flags: UINT,
        dataSize: UINT,
        data: *const BYTE,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetClipGraphics(
        graphics: *mut GpGraphics,
        srcgraphics: *mut GpGraphics,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetClipRect(
        graphics: *mut GpGraphics,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetClipRectI(
        graphics: *mut GpGraphics,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetClipPath(
        graphics: *mut GpGraphics,
        path: *mut GpPath,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetClipRegion(
        graphics: *mut GpGraphics,
        region: *mut GpRegion,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetClipHrgn(
        graphics: *mut GpGraphics,
        hRgn: HRGN,
        combineMode: CombineMode,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipResetClip(graphics: *mut GpGraphics) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateClip(graphics: *mut GpGraphics, dx: REAL, dy: REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTranslateClipI(graphics: *mut GpGraphics, dx: INT, dy: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetClip(graphics: *mut GpGraphics, region: *mut GpRegion) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetClipBounds(graphics: *mut GpGraphics, rect: *mut GpRectF) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetClipBoundsI(graphics: *mut GpGraphics, rect: *mut GpRect) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsClipEmpty(graphics: *mut GpGraphics, result: *mut BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetVisibleClipBounds(graphics: *mut GpGraphics, rect: *mut GpRectF) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetVisibleClipBoundsI(graphics: *mut GpGraphics, rect: *mut GpRect) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleClipEmpty(graphics: *mut GpGraphics, result: *mut BOOL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisiblePoint(
        graphics: *mut GpGraphics,
        x: REAL,
        y: REAL,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisiblePointI(
        graphics: *mut GpGraphics,
        x: INT,
        y: INT,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleRect(
        graphics: *mut GpGraphics,
        x: REAL,
        y: REAL,
        width: REAL,
        height: REAL,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsVisibleRectI(
        graphics: *mut GpGraphics,
        x: INT,
        y: INT,
        width: INT,
        height: INT,
        result: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSaveGraphics(graphics: *mut GpGraphics, state: *mut GraphicsState) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRestoreGraphics(graphics: *mut GpGraphics, state: GraphicsState) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBeginContainer(
        graphics: *mut GpGraphics,
        dstrect: *const GpRectF,
        srcrect: *const GpRectF,
        unit: GpUnit,
        state: *mut GraphicsContainer,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBeginContainerI(
        graphics: *mut GpGraphics,
        dstrect: *const GpRect,
        srcrect: *const GpRect,
        unit: GpUnit,
        state: *mut GraphicsContainer,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipBeginContainer2(
        graphics: *mut GpGraphics,
        state: *mut GraphicsContainer,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEndContainer(graphics: *mut GpGraphics, state: GraphicsContainer) -> GpStatus;
}
extern "C" {
    pub fn GdipGetMetafileHeaderFromWmf(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetMetafileHeaderFromEmf(
        hEmf: HENHMETAFILE,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetMetafileHeaderFromFile(
        filename: *const WCHAR,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetMetafileHeaderFromStream(
        stream: *mut IStream,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetMetafileHeaderFromMetafile(
        metafile: *mut GpMetafile,
        header: *mut MetafileHeader,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetHemfFromMetafile(metafile: *mut GpMetafile, hEmf: *mut HENHMETAFILE) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateStreamOnFile(
        filename: *const WCHAR,
        access: UINT,
        stream: *mut *mut IStream,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMetafileFromWmf(
        hWmf: HMETAFILE,
        deleteWmf: BOOL,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMetafileFromEmf(
        hEmf: HENHMETAFILE,
        deleteEmf: BOOL,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMetafileFromFile(
        file: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMetafileFromWmfFile(
        file: *const WCHAR,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateMetafileFromStream(
        stream: *mut IStream,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRecordMetafile(
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRectF,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRecordMetafileI(
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRect,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRecordMetafileFileName(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRectF,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRecordMetafileFileNameI(
        fileName: *const WCHAR,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRect,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRecordMetafileStream(
        stream: *mut IStream,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRectF,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipRecordMetafileStreamI(
        stream: *mut IStream,
        referenceHdc: HDC,
        type_: EmfType,
        frameRect: *const GpRect,
        frameUnit: MetafileFrameUnit,
        description: *const WCHAR,
        metafile: *mut *mut GpMetafile,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetMetafileDownLevelRasterizationLimit(
        metafile: *mut GpMetafile,
        metafileRasterizationLimitDpi: UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetMetafileDownLevelRasterizationLimit(
        metafile: *const GpMetafile,
        metafileRasterizationLimitDpi: *mut UINT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageDecodersSize(numDecoders: *mut UINT, size: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageDecoders(
        numDecoders: UINT,
        size: UINT,
        decoders: *mut ImageCodecInfo,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageEncodersSize(numEncoders: *mut UINT, size: *mut UINT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetImageEncoders(
        numEncoders: UINT,
        size: UINT,
        encoders: *mut ImageCodecInfo,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipComment(graphics: *mut GpGraphics, sizeData: UINT, data: *const BYTE) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFontFamilyFromName(
        name: *const WCHAR,
        fontCollection: *mut GpFontCollection,
        fontFamily: *mut *mut GpFontFamily,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteFontFamily(fontFamily: *mut GpFontFamily) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneFontFamily(
        fontFamily: *mut GpFontFamily,
        clonedFontFamily: *mut *mut GpFontFamily,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetGenericFontFamilySansSerif(nativeFamily: *mut *mut GpFontFamily) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetGenericFontFamilySerif(nativeFamily: *mut *mut GpFontFamily) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetGenericFontFamilyMonospace(nativeFamily: *mut *mut GpFontFamily) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFamilyName(
        family: *const GpFontFamily,
        name: LPWSTR,
        language: LANGID,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipIsStyleAvailable(
        family: *const GpFontFamily,
        style: INT,
        IsStyleAvailable: *mut BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFontCollectionEnumerable(
        fontCollection: *mut GpFontCollection,
        graphics: *mut GpGraphics,
        numFound: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipFontCollectionEnumerate(
        fontCollection: *mut GpFontCollection,
        numSought: INT,
        gpfamilies: *mut *mut GpFontFamily,
        numFound: *mut INT,
        graphics: *mut GpGraphics,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetEmHeight(
        family: *const GpFontFamily,
        style: INT,
        EmHeight: *mut UINT16,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCellAscent(
        family: *const GpFontFamily,
        style: INT,
        CellAscent: *mut UINT16,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetCellDescent(
        family: *const GpFontFamily,
        style: INT,
        CellDescent: *mut UINT16,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLineSpacing(
        family: *const GpFontFamily,
        style: INT,
        LineSpacing: *mut UINT16,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFontFromDC(hdc: HDC, font: *mut *mut GpFont) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFontFromLogfontA(
        hdc: HDC,
        logfont: *const LOGFONTA,
        font: *mut *mut GpFont,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFontFromLogfontW(
        hdc: HDC,
        logfont: *const LOGFONTW,
        font: *mut *mut GpFont,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateFont(
        fontFamily: *const GpFontFamily,
        emSize: REAL,
        style: INT,
        unit: Unit,
        font: *mut *mut GpFont,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneFont(font: *mut GpFont, cloneFont: *mut *mut GpFont) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteFont(font: *mut GpFont) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFamily(font: *mut GpFont, family: *mut *mut GpFontFamily) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontStyle(font: *mut GpFont, style: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontSize(font: *mut GpFont, size: *mut REAL) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontUnit(font: *mut GpFont, unit: *mut Unit) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontHeight(
        font: *const GpFont,
        graphics: *const GpGraphics,
        height: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontHeightGivenDPI(font: *const GpFont, dpi: REAL, height: *mut REAL)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLogFontA(
        font: *mut GpFont,
        graphics: *mut GpGraphics,
        logfontA: *mut LOGFONTA,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetLogFontW(
        font: *mut GpFont,
        graphics: *mut GpGraphics,
        logfontW: *mut LOGFONTW,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipNewInstalledFontCollection(fontCollection: *mut *mut GpFontCollection) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipNewPrivateFontCollection(fontCollection: *mut *mut GpFontCollection) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeletePrivateFontCollection(fontCollection: *mut *mut GpFontCollection) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontCollectionFamilyCount(
        fontCollection: *mut GpFontCollection,
        numFound: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetFontCollectionFamilyList(
        fontCollection: *mut GpFontCollection,
        numSought: INT,
        gpfamilies: *mut *mut GpFontFamily,
        numFound: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPrivateAddFontFile(
        fontCollection: *mut GpFontCollection,
        filename: *const WCHAR,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipPrivateAddMemoryFont(
        fontCollection: *mut GpFontCollection,
        memory: *const ::core::ffi::c_void,
        length: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawString(
        graphics: *mut GpGraphics,
        string: *const WCHAR,
        length: INT,
        font: *const GpFont,
        layoutRect: *const RectF,
        stringFormat: *const GpStringFormat,
        brush: *const GpBrush,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMeasureString(
        graphics: *mut GpGraphics,
        string: *const WCHAR,
        length: INT,
        font: *const GpFont,
        layoutRect: *const RectF,
        stringFormat: *const GpStringFormat,
        boundingBox: *mut RectF,
        codepointsFitted: *mut INT,
        linesFilled: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMeasureCharacterRanges(
        graphics: *mut GpGraphics,
        string: *const WCHAR,
        length: INT,
        font: *const GpFont,
        layoutRect: *const RectF,
        stringFormat: *const GpStringFormat,
        regionCount: INT,
        regions: *mut *mut GpRegion,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawDriverString(
        graphics: *mut GpGraphics,
        text: *const UINT16,
        length: INT,
        font: *const GpFont,
        brush: *const GpBrush,
        positions: *const PointF,
        flags: INT,
        matrix: *const GpMatrix,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipMeasureDriverString(
        graphics: *mut GpGraphics,
        text: *const UINT16,
        length: INT,
        font: *const GpFont,
        positions: *const PointF,
        flags: INT,
        matrix: *const GpMatrix,
        boundingBox: *mut RectF,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateStringFormat(
        formatAttributes: INT,
        language: LANGID,
        format: *mut *mut GpStringFormat,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipStringFormatGetGenericDefault(format: *mut *mut GpStringFormat) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipStringFormatGetGenericTypographic(format: *mut *mut GpStringFormat) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteStringFormat(format: *mut GpStringFormat) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCloneStringFormat(
        format: *const GpStringFormat,
        newFormat: *mut *mut GpStringFormat,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatFlags(format: *mut GpStringFormat, flags: INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatFlags(format: *const GpStringFormat, flags: *mut INT) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatAlign(
        format: *mut GpStringFormat,
        align: StringAlignment,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatAlign(
        format: *const GpStringFormat,
        align: *mut StringAlignment,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatLineAlign(
        format: *mut GpStringFormat,
        align: StringAlignment,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatLineAlign(
        format: *const GpStringFormat,
        align: *mut StringAlignment,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatTrimming(
        format: *mut GpStringFormat,
        trimming: StringTrimming,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatTrimming(
        format: *const GpStringFormat,
        trimming: *mut StringTrimming,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatHotkeyPrefix(
        format: *mut GpStringFormat,
        hotkeyPrefix: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatHotkeyPrefix(
        format: *const GpStringFormat,
        hotkeyPrefix: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatTabStops(
        format: *mut GpStringFormat,
        firstTabOffset: REAL,
        count: INT,
        tabStops: *const REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatTabStops(
        format: *const GpStringFormat,
        count: INT,
        firstTabOffset: *mut REAL,
        tabStops: *mut REAL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatTabStopCount(
        format: *const GpStringFormat,
        count: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatDigitSubstitution(
        format: *mut GpStringFormat,
        language: LANGID,
        substitute: StringDigitSubstitute,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatDigitSubstitution(
        format: *const GpStringFormat,
        language: *mut LANGID,
        substitute: *mut StringDigitSubstitute,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipGetStringFormatMeasurableCharacterRangeCount(
        format: *const GpStringFormat,
        count: *mut INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipSetStringFormatMeasurableCharacterRanges(
        format: *mut GpStringFormat,
        rangeCount: INT,
        ranges: *const CharacterRange,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipCreateCachedBitmap(
        bitmap: *mut GpBitmap,
        graphics: *mut GpGraphics,
        cachedBitmap: *mut *mut GpCachedBitmap,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDeleteCachedBitmap(cachedBitmap: *mut GpCachedBitmap) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipDrawCachedBitmap(
        graphics: *mut GpGraphics,
        cachedBitmap: *mut GpCachedBitmap,
        x: INT,
        y: INT,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipEmfToWmfBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        eFlags: INT,
    ) -> UINT;
}
extern "stdcall" {
    pub fn GdipSetImageAttributesCachedBackground(
        imageattr: *mut GpImageAttributes,
        enableFlag: BOOL,
    ) -> GpStatus;
}
extern "stdcall" {
    pub fn GdipTestControl(control: GpTestControlEnum, param: *mut ::core::ffi::c_void)
        -> GpStatus;
}
extern "stdcall" {
    pub fn GdiplusNotificationHook(token: *mut ULONG_PTR) -> GpStatus;
}
extern "stdcall" {
    pub fn GdiplusNotificationUnhook(token: ULONG_PTR);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GdiplusBase {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GdiplusBase() {
    assert_eq!(
        ::core::mem::size_of::<GdiplusBase>(),
        1usize,
        concat!("Size of: ", stringify!(GdiplusBase))
    );
    assert_eq!(
        ::core::mem::align_of::<GdiplusBase>(),
        1usize,
        concat!("Alignment of ", stringify!(GdiplusBase))
    );
}
pub type GraphicsState = UINT;
pub type GraphicsContainer = UINT;
pub const FillMode_FillModeAlternate: FillMode = 0;
pub const FillMode_FillModeWinding: FillMode = 1;
pub type FillMode = ::core::ffi::c_int;
pub const CompositingMode_CompositingModeSourceOver: CompositingMode = 0;
pub const CompositingMode_CompositingModeSourceCopy: CompositingMode = 1;
pub type CompositingMode = ::core::ffi::c_int;
pub const CompositingQuality_CompositingQualityInvalid: CompositingQuality = -1;
pub const CompositingQuality_CompositingQualityDefault: CompositingQuality = 0;
pub const CompositingQuality_CompositingQualityHighSpeed: CompositingQuality = 1;
pub const CompositingQuality_CompositingQualityHighQuality: CompositingQuality = 2;
pub const CompositingQuality_CompositingQualityGammaCorrected: CompositingQuality = 3;
pub const CompositingQuality_CompositingQualityAssumeLinear: CompositingQuality = 4;
pub type CompositingQuality = ::core::ffi::c_int;
pub const Unit_UnitWorld: Unit = 0;
pub const Unit_UnitDisplay: Unit = 1;
pub const Unit_UnitPixel: Unit = 2;
pub const Unit_UnitPoint: Unit = 3;
pub const Unit_UnitInch: Unit = 4;
pub const Unit_UnitDocument: Unit = 5;
pub const Unit_UnitMillimeter: Unit = 6;
pub type Unit = ::core::ffi::c_int;
pub const MetafileFrameUnit_MetafileFrameUnitPixel: MetafileFrameUnit = 2;
pub const MetafileFrameUnit_MetafileFrameUnitPoint: MetafileFrameUnit = 3;
pub const MetafileFrameUnit_MetafileFrameUnitInch: MetafileFrameUnit = 4;
pub const MetafileFrameUnit_MetafileFrameUnitDocument: MetafileFrameUnit = 5;
pub const MetafileFrameUnit_MetafileFrameUnitMillimeter: MetafileFrameUnit = 6;
pub const MetafileFrameUnit_MetafileFrameUnitGdi: MetafileFrameUnit = 7;
pub type MetafileFrameUnit = ::core::ffi::c_int;
pub const CoordinateSpace_CoordinateSpaceWorld: CoordinateSpace = 0;
pub const CoordinateSpace_CoordinateSpacePage: CoordinateSpace = 1;
pub const CoordinateSpace_CoordinateSpaceDevice: CoordinateSpace = 2;
pub type CoordinateSpace = ::core::ffi::c_int;
pub const WrapMode_WrapModeTile: WrapMode = 0;
pub const WrapMode_WrapModeTileFlipX: WrapMode = 1;
pub const WrapMode_WrapModeTileFlipY: WrapMode = 2;
pub const WrapMode_WrapModeTileFlipXY: WrapMode = 3;
pub const WrapMode_WrapModeClamp: WrapMode = 4;
pub type WrapMode = ::core::ffi::c_int;
pub const HatchStyle_HatchStyleHorizontal: HatchStyle = 0;
pub const HatchStyle_HatchStyleVertical: HatchStyle = 1;
pub const HatchStyle_HatchStyleForwardDiagonal: HatchStyle = 2;
pub const HatchStyle_HatchStyleBackwardDiagonal: HatchStyle = 3;
pub const HatchStyle_HatchStyleCross: HatchStyle = 4;
pub const HatchStyle_HatchStyleDiagonalCross: HatchStyle = 5;
pub const HatchStyle_HatchStyle05Percent: HatchStyle = 6;
pub const HatchStyle_HatchStyle10Percent: HatchStyle = 7;
pub const HatchStyle_HatchStyle20Percent: HatchStyle = 8;
pub const HatchStyle_HatchStyle25Percent: HatchStyle = 9;
pub const HatchStyle_HatchStyle30Percent: HatchStyle = 10;
pub const HatchStyle_HatchStyle40Percent: HatchStyle = 11;
pub const HatchStyle_HatchStyle50Percent: HatchStyle = 12;
pub const HatchStyle_HatchStyle60Percent: HatchStyle = 13;
pub const HatchStyle_HatchStyle70Percent: HatchStyle = 14;
pub const HatchStyle_HatchStyle75Percent: HatchStyle = 15;
pub const HatchStyle_HatchStyle80Percent: HatchStyle = 16;
pub const HatchStyle_HatchStyle90Percent: HatchStyle = 17;
pub const HatchStyle_HatchStyleLightDownwardDiagonal: HatchStyle = 18;
pub const HatchStyle_HatchStyleLightUpwardDiagonal: HatchStyle = 19;
pub const HatchStyle_HatchStyleDarkDownwardDiagonal: HatchStyle = 20;
pub const HatchStyle_HatchStyleDarkUpwardDiagonal: HatchStyle = 21;
pub const HatchStyle_HatchStyleWideDownwardDiagonal: HatchStyle = 22;
pub const HatchStyle_HatchStyleWideUpwardDiagonal: HatchStyle = 23;
pub const HatchStyle_HatchStyleLightVertical: HatchStyle = 24;
pub const HatchStyle_HatchStyleLightHorizontal: HatchStyle = 25;
pub const HatchStyle_HatchStyleNarrowVertical: HatchStyle = 26;
pub const HatchStyle_HatchStyleNarrowHorizontal: HatchStyle = 27;
pub const HatchStyle_HatchStyleDarkVertical: HatchStyle = 28;
pub const HatchStyle_HatchStyleDarkHorizontal: HatchStyle = 29;
pub const HatchStyle_HatchStyleDashedDownwardDiagonal: HatchStyle = 30;
pub const HatchStyle_HatchStyleDashedUpwardDiagonal: HatchStyle = 31;
pub const HatchStyle_HatchStyleDashedHorizontal: HatchStyle = 32;
pub const HatchStyle_HatchStyleDashedVertical: HatchStyle = 33;
pub const HatchStyle_HatchStyleSmallConfetti: HatchStyle = 34;
pub const HatchStyle_HatchStyleLargeConfetti: HatchStyle = 35;
pub const HatchStyle_HatchStyleZigZag: HatchStyle = 36;
pub const HatchStyle_HatchStyleWave: HatchStyle = 37;
pub const HatchStyle_HatchStyleDiagonalBrick: HatchStyle = 38;
pub const HatchStyle_HatchStyleHorizontalBrick: HatchStyle = 39;
pub const HatchStyle_HatchStyleWeave: HatchStyle = 40;
pub const HatchStyle_HatchStylePlaid: HatchStyle = 41;
pub const HatchStyle_HatchStyleDivot: HatchStyle = 42;
pub const HatchStyle_HatchStyleDottedGrid: HatchStyle = 43;
pub const HatchStyle_HatchStyleDottedDiamond: HatchStyle = 44;
pub const HatchStyle_HatchStyleShingle: HatchStyle = 45;
pub const HatchStyle_HatchStyleTrellis: HatchStyle = 46;
pub const HatchStyle_HatchStyleSphere: HatchStyle = 47;
pub const HatchStyle_HatchStyleSmallGrid: HatchStyle = 48;
pub const HatchStyle_HatchStyleSmallCheckerBoard: HatchStyle = 49;
pub const HatchStyle_HatchStyleLargeCheckerBoard: HatchStyle = 50;
pub const HatchStyle_HatchStyleOutlinedDiamond: HatchStyle = 51;
pub const HatchStyle_HatchStyleSolidDiamond: HatchStyle = 52;
pub const HatchStyle_HatchStyleTotal: HatchStyle = 53;
pub const HatchStyle_HatchStyleLargeGrid: HatchStyle = 4;
pub const HatchStyle_HatchStyleMin: HatchStyle = 0;
pub const HatchStyle_HatchStyleMax: HatchStyle = 52;
pub type HatchStyle = ::core::ffi::c_int;
pub const DashStyle_DashStyleSolid: DashStyle = 0;
pub const DashStyle_DashStyleDash: DashStyle = 1;
pub const DashStyle_DashStyleDot: DashStyle = 2;
pub const DashStyle_DashStyleDashDot: DashStyle = 3;
pub const DashStyle_DashStyleDashDotDot: DashStyle = 4;
pub const DashStyle_DashStyleCustom: DashStyle = 5;
pub type DashStyle = ::core::ffi::c_int;
pub const DashCap_DashCapFlat: DashCap = 0;
pub const DashCap_DashCapRound: DashCap = 2;
pub const DashCap_DashCapTriangle: DashCap = 3;
pub type DashCap = ::core::ffi::c_int;
pub const LineCap_LineCapFlat: LineCap = 0;
pub const LineCap_LineCapSquare: LineCap = 1;
pub const LineCap_LineCapRound: LineCap = 2;
pub const LineCap_LineCapTriangle: LineCap = 3;
pub const LineCap_LineCapNoAnchor: LineCap = 16;
pub const LineCap_LineCapSquareAnchor: LineCap = 17;
pub const LineCap_LineCapRoundAnchor: LineCap = 18;
pub const LineCap_LineCapDiamondAnchor: LineCap = 19;
pub const LineCap_LineCapArrowAnchor: LineCap = 20;
pub const LineCap_LineCapCustom: LineCap = 255;
pub const LineCap_LineCapAnchorMask: LineCap = 240;
pub type LineCap = ::core::ffi::c_int;
pub const CustomLineCapType_CustomLineCapTypeDefault: CustomLineCapType = 0;
pub const CustomLineCapType_CustomLineCapTypeAdjustableArrow: CustomLineCapType = 1;
pub type CustomLineCapType = ::core::ffi::c_int;
pub const LineJoin_LineJoinMiter: LineJoin = 0;
pub const LineJoin_LineJoinBevel: LineJoin = 1;
pub const LineJoin_LineJoinRound: LineJoin = 2;
pub const LineJoin_LineJoinMiterClipped: LineJoin = 3;
pub type LineJoin = ::core::ffi::c_int;
pub const WarpMode_WarpModePerspective: WarpMode = 0;
pub const WarpMode_WarpModeBilinear: WarpMode = 1;
pub type WarpMode = ::core::ffi::c_int;
pub const LinearGradientMode_LinearGradientModeHorizontal: LinearGradientMode = 0;
pub const LinearGradientMode_LinearGradientModeVertical: LinearGradientMode = 1;
pub const LinearGradientMode_LinearGradientModeForwardDiagonal: LinearGradientMode = 2;
pub const LinearGradientMode_LinearGradientModeBackwardDiagonal: LinearGradientMode = 3;
pub type LinearGradientMode = ::core::ffi::c_int;
pub const CombineMode_CombineModeReplace: CombineMode = 0;
pub const CombineMode_CombineModeIntersect: CombineMode = 1;
pub const CombineMode_CombineModeUnion: CombineMode = 2;
pub const CombineMode_CombineModeXor: CombineMode = 3;
pub const CombineMode_CombineModeExclude: CombineMode = 4;
pub const CombineMode_CombineModeComplement: CombineMode = 5;
pub type CombineMode = ::core::ffi::c_int;
pub const ImageType_ImageTypeUnknown: ImageType = 0;
pub const ImageType_ImageTypeBitmap: ImageType = 1;
pub const ImageType_ImageTypeMetafile: ImageType = 2;
pub type ImageType = ::core::ffi::c_int;
pub const InterpolationMode_InterpolationModeInvalid: InterpolationMode = -1;
pub const InterpolationMode_InterpolationModeDefault: InterpolationMode = 0;
pub const InterpolationMode_InterpolationModeLowQuality: InterpolationMode = 1;
pub const InterpolationMode_InterpolationModeHighQuality: InterpolationMode = 2;
pub const InterpolationMode_InterpolationModeBilinear: InterpolationMode = 3;
pub const InterpolationMode_InterpolationModeBicubic: InterpolationMode = 4;
pub const InterpolationMode_InterpolationModeNearestNeighbor: InterpolationMode = 5;
pub const InterpolationMode_InterpolationModeHighQualityBilinear: InterpolationMode = 6;
pub const InterpolationMode_InterpolationModeHighQualityBicubic: InterpolationMode = 7;
pub type InterpolationMode = ::core::ffi::c_int;
pub const PenAlignment_PenAlignmentCenter: PenAlignment = 0;
pub const PenAlignment_PenAlignmentInset: PenAlignment = 1;
pub type PenAlignment = ::core::ffi::c_int;
pub const BrushType_BrushTypeSolidColor: BrushType = 0;
pub const BrushType_BrushTypeHatchFill: BrushType = 1;
pub const BrushType_BrushTypeTextureFill: BrushType = 2;
pub const BrushType_BrushTypePathGradient: BrushType = 3;
pub const BrushType_BrushTypeLinearGradient: BrushType = 4;
pub type BrushType = ::core::ffi::c_int;
pub const PenType_PenTypeSolidColor: PenType = 0;
pub const PenType_PenTypeHatchFill: PenType = 1;
pub const PenType_PenTypeTextureFill: PenType = 2;
pub const PenType_PenTypePathGradient: PenType = 3;
pub const PenType_PenTypeLinearGradient: PenType = 4;
pub const PenType_PenTypeUnknown: PenType = -1;
pub type PenType = ::core::ffi::c_int;
pub const MatrixOrder_MatrixOrderPrepend: MatrixOrder = 0;
pub const MatrixOrder_MatrixOrderAppend: MatrixOrder = 1;
pub type MatrixOrder = ::core::ffi::c_int;
pub const SmoothingMode_SmoothingModeInvalid: SmoothingMode = -1;
pub const SmoothingMode_SmoothingModeDefault: SmoothingMode = 0;
pub const SmoothingMode_SmoothingModeHighSpeed: SmoothingMode = 1;
pub const SmoothingMode_SmoothingModeHighQuality: SmoothingMode = 2;
pub const SmoothingMode_SmoothingModeNone: SmoothingMode = 3;
pub const SmoothingMode_SmoothingModeAntiAlias: SmoothingMode = 4;
pub type SmoothingMode = ::core::ffi::c_int;
pub const PixelOffsetMode_PixelOffsetModeInvalid: PixelOffsetMode = -1;
pub const PixelOffsetMode_PixelOffsetModeDefault: PixelOffsetMode = 0;
pub const PixelOffsetMode_PixelOffsetModeHighSpeed: PixelOffsetMode = 1;
pub const PixelOffsetMode_PixelOffsetModeHighQuality: PixelOffsetMode = 2;
pub const PixelOffsetMode_PixelOffsetModeNone: PixelOffsetMode = 3;
pub const PixelOffsetMode_PixelOffsetModeHalf: PixelOffsetMode = 4;
pub type PixelOffsetMode = ::core::ffi::c_int;
pub const TextRenderingHint_TextRenderingHintSystemDefault: TextRenderingHint = 0;
pub const TextRenderingHint_TextRenderingHintSingleBitPerPixelGridFit: TextRenderingHint = 1;
pub const TextRenderingHint_TextRenderingHintSingleBitPerPixel: TextRenderingHint = 2;
pub const TextRenderingHint_TextRenderingHintAntiAliasGridFit: TextRenderingHint = 3;
pub const TextRenderingHint_TextRenderingHintAntiAlias: TextRenderingHint = 4;
pub const TextRenderingHint_TextRenderingHintClearTypeGridFit: TextRenderingHint = 5;
pub type TextRenderingHint = ::core::ffi::c_int;
pub const MetafileType_MetafileTypeInvalid: MetafileType = 0;
pub const MetafileType_MetafileTypeWmf: MetafileType = 1;
pub const MetafileType_MetafileTypeWmfPlaceable: MetafileType = 2;
pub const MetafileType_MetafileTypeEmf: MetafileType = 3;
pub const MetafileType_MetafileTypeEmfPlusOnly: MetafileType = 4;
pub const MetafileType_MetafileTypeEmfPlusDual: MetafileType = 5;
pub type MetafileType = ::core::ffi::c_int;
pub const EmfType_EmfTypeEmfOnly: EmfType = 3;
pub const EmfType_EmfTypeEmfPlusOnly: EmfType = 4;
pub const EmfType_EmfTypeEmfPlusDual: EmfType = 5;
pub type EmfType = ::core::ffi::c_int;
pub const EmfPlusRecordType_WmfRecordTypeSetBkColor: EmfPlusRecordType = 66049;
pub const EmfPlusRecordType_WmfRecordTypeSetBkMode: EmfPlusRecordType = 65794;
pub const EmfPlusRecordType_WmfRecordTypeSetMapMode: EmfPlusRecordType = 65795;
pub const EmfPlusRecordType_WmfRecordTypeSetROP2: EmfPlusRecordType = 65796;
pub const EmfPlusRecordType_WmfRecordTypeSetRelAbs: EmfPlusRecordType = 65797;
pub const EmfPlusRecordType_WmfRecordTypeSetPolyFillMode: EmfPlusRecordType = 65798;
pub const EmfPlusRecordType_WmfRecordTypeSetStretchBltMode: EmfPlusRecordType = 65799;
pub const EmfPlusRecordType_WmfRecordTypeSetTextCharExtra: EmfPlusRecordType = 65800;
pub const EmfPlusRecordType_WmfRecordTypeSetTextColor: EmfPlusRecordType = 66057;
pub const EmfPlusRecordType_WmfRecordTypeSetTextJustification: EmfPlusRecordType = 66058;
pub const EmfPlusRecordType_WmfRecordTypeSetWindowOrg: EmfPlusRecordType = 66059;
pub const EmfPlusRecordType_WmfRecordTypeSetWindowExt: EmfPlusRecordType = 66060;
pub const EmfPlusRecordType_WmfRecordTypeSetViewportOrg: EmfPlusRecordType = 66061;
pub const EmfPlusRecordType_WmfRecordTypeSetViewportExt: EmfPlusRecordType = 66062;
pub const EmfPlusRecordType_WmfRecordTypeOffsetWindowOrg: EmfPlusRecordType = 66063;
pub const EmfPlusRecordType_WmfRecordTypeScaleWindowExt: EmfPlusRecordType = 66576;
pub const EmfPlusRecordType_WmfRecordTypeOffsetViewportOrg: EmfPlusRecordType = 66065;
pub const EmfPlusRecordType_WmfRecordTypeScaleViewportExt: EmfPlusRecordType = 66578;
pub const EmfPlusRecordType_WmfRecordTypeLineTo: EmfPlusRecordType = 66067;
pub const EmfPlusRecordType_WmfRecordTypeMoveTo: EmfPlusRecordType = 66068;
pub const EmfPlusRecordType_WmfRecordTypeExcludeClipRect: EmfPlusRecordType = 66581;
pub const EmfPlusRecordType_WmfRecordTypeIntersectClipRect: EmfPlusRecordType = 66582;
pub const EmfPlusRecordType_WmfRecordTypeArc: EmfPlusRecordType = 67607;
pub const EmfPlusRecordType_WmfRecordTypeEllipse: EmfPlusRecordType = 66584;
pub const EmfPlusRecordType_WmfRecordTypeFloodFill: EmfPlusRecordType = 66585;
pub const EmfPlusRecordType_WmfRecordTypePie: EmfPlusRecordType = 67610;
pub const EmfPlusRecordType_WmfRecordTypeRectangle: EmfPlusRecordType = 66587;
pub const EmfPlusRecordType_WmfRecordTypeRoundRect: EmfPlusRecordType = 67100;
pub const EmfPlusRecordType_WmfRecordTypePatBlt: EmfPlusRecordType = 67101;
pub const EmfPlusRecordType_WmfRecordTypeSaveDC: EmfPlusRecordType = 65566;
pub const EmfPlusRecordType_WmfRecordTypeSetPixel: EmfPlusRecordType = 66591;
pub const EmfPlusRecordType_WmfRecordTypeOffsetClipRgn: EmfPlusRecordType = 66080;
pub const EmfPlusRecordType_WmfRecordTypeTextOut: EmfPlusRecordType = 66849;
pub const EmfPlusRecordType_WmfRecordTypeBitBlt: EmfPlusRecordType = 67874;
pub const EmfPlusRecordType_WmfRecordTypeStretchBlt: EmfPlusRecordType = 68387;
pub const EmfPlusRecordType_WmfRecordTypePolygon: EmfPlusRecordType = 66340;
pub const EmfPlusRecordType_WmfRecordTypePolyline: EmfPlusRecordType = 66341;
pub const EmfPlusRecordType_WmfRecordTypeEscape: EmfPlusRecordType = 67110;
pub const EmfPlusRecordType_WmfRecordTypeRestoreDC: EmfPlusRecordType = 65831;
pub const EmfPlusRecordType_WmfRecordTypeFillRegion: EmfPlusRecordType = 66088;
pub const EmfPlusRecordType_WmfRecordTypeFrameRegion: EmfPlusRecordType = 66601;
pub const EmfPlusRecordType_WmfRecordTypeInvertRegion: EmfPlusRecordType = 65834;
pub const EmfPlusRecordType_WmfRecordTypePaintRegion: EmfPlusRecordType = 65835;
pub const EmfPlusRecordType_WmfRecordTypeSelectClipRegion: EmfPlusRecordType = 65836;
pub const EmfPlusRecordType_WmfRecordTypeSelectObject: EmfPlusRecordType = 65837;
pub const EmfPlusRecordType_WmfRecordTypeSetTextAlign: EmfPlusRecordType = 65838;
pub const EmfPlusRecordType_WmfRecordTypeDrawText: EmfPlusRecordType = 67119;
pub const EmfPlusRecordType_WmfRecordTypeChord: EmfPlusRecordType = 67632;
pub const EmfPlusRecordType_WmfRecordTypeSetMapperFlags: EmfPlusRecordType = 66097;
pub const EmfPlusRecordType_WmfRecordTypeExtTextOut: EmfPlusRecordType = 68146;
pub const EmfPlusRecordType_WmfRecordTypeSetDIBToDev: EmfPlusRecordType = 68915;
pub const EmfPlusRecordType_WmfRecordTypeSelectPalette: EmfPlusRecordType = 66100;
pub const EmfPlusRecordType_WmfRecordTypeRealizePalette: EmfPlusRecordType = 65589;
pub const EmfPlusRecordType_WmfRecordTypeAnimatePalette: EmfPlusRecordType = 66614;
pub const EmfPlusRecordType_WmfRecordTypeSetPalEntries: EmfPlusRecordType = 65591;
pub const EmfPlusRecordType_WmfRecordTypePolyPolygon: EmfPlusRecordType = 66872;
pub const EmfPlusRecordType_WmfRecordTypeResizePalette: EmfPlusRecordType = 65849;
pub const EmfPlusRecordType_WmfRecordTypeDIBBitBlt: EmfPlusRecordType = 67904;
pub const EmfPlusRecordType_WmfRecordTypeDIBStretchBlt: EmfPlusRecordType = 68417;
pub const EmfPlusRecordType_WmfRecordTypeDIBCreatePatternBrush: EmfPlusRecordType = 65858;
pub const EmfPlusRecordType_WmfRecordTypeStretchDIB: EmfPlusRecordType = 69443;
pub const EmfPlusRecordType_WmfRecordTypeExtFloodFill: EmfPlusRecordType = 66888;
pub const EmfPlusRecordType_WmfRecordTypeSetLayout: EmfPlusRecordType = 65865;
pub const EmfPlusRecordType_WmfRecordTypeResetDC: EmfPlusRecordType = 65868;
pub const EmfPlusRecordType_WmfRecordTypeStartDoc: EmfPlusRecordType = 65869;
pub const EmfPlusRecordType_WmfRecordTypeStartPage: EmfPlusRecordType = 65615;
pub const EmfPlusRecordType_WmfRecordTypeEndPage: EmfPlusRecordType = 65616;
pub const EmfPlusRecordType_WmfRecordTypeAbortDoc: EmfPlusRecordType = 65618;
pub const EmfPlusRecordType_WmfRecordTypeEndDoc: EmfPlusRecordType = 65630;
pub const EmfPlusRecordType_WmfRecordTypeDeleteObject: EmfPlusRecordType = 66032;
pub const EmfPlusRecordType_WmfRecordTypeCreatePalette: EmfPlusRecordType = 65783;
pub const EmfPlusRecordType_WmfRecordTypeCreateBrush: EmfPlusRecordType = 65784;
pub const EmfPlusRecordType_WmfRecordTypeCreatePatternBrush: EmfPlusRecordType = 66041;
pub const EmfPlusRecordType_WmfRecordTypeCreatePenIndirect: EmfPlusRecordType = 66298;
pub const EmfPlusRecordType_WmfRecordTypeCreateFontIndirect: EmfPlusRecordType = 66299;
pub const EmfPlusRecordType_WmfRecordTypeCreateBrushIndirect: EmfPlusRecordType = 66300;
pub const EmfPlusRecordType_WmfRecordTypeCreateBitmapIndirect: EmfPlusRecordType = 66301;
pub const EmfPlusRecordType_WmfRecordTypeCreateBitmap: EmfPlusRecordType = 67326;
pub const EmfPlusRecordType_WmfRecordTypeCreateRegion: EmfPlusRecordType = 67327;
pub const EmfPlusRecordType_EmfRecordTypeHeader: EmfPlusRecordType = 1;
pub const EmfPlusRecordType_EmfRecordTypePolyBezier: EmfPlusRecordType = 2;
pub const EmfPlusRecordType_EmfRecordTypePolygon: EmfPlusRecordType = 3;
pub const EmfPlusRecordType_EmfRecordTypePolyline: EmfPlusRecordType = 4;
pub const EmfPlusRecordType_EmfRecordTypePolyBezierTo: EmfPlusRecordType = 5;
pub const EmfPlusRecordType_EmfRecordTypePolyLineTo: EmfPlusRecordType = 6;
pub const EmfPlusRecordType_EmfRecordTypePolyPolyline: EmfPlusRecordType = 7;
pub const EmfPlusRecordType_EmfRecordTypePolyPolygon: EmfPlusRecordType = 8;
pub const EmfPlusRecordType_EmfRecordTypeSetWindowExtEx: EmfPlusRecordType = 9;
pub const EmfPlusRecordType_EmfRecordTypeSetWindowOrgEx: EmfPlusRecordType = 10;
pub const EmfPlusRecordType_EmfRecordTypeSetViewportExtEx: EmfPlusRecordType = 11;
pub const EmfPlusRecordType_EmfRecordTypeSetViewportOrgEx: EmfPlusRecordType = 12;
pub const EmfPlusRecordType_EmfRecordTypeSetBrushOrgEx: EmfPlusRecordType = 13;
pub const EmfPlusRecordType_EmfRecordTypeEOF: EmfPlusRecordType = 14;
pub const EmfPlusRecordType_EmfRecordTypeSetPixelV: EmfPlusRecordType = 15;
pub const EmfPlusRecordType_EmfRecordTypeSetMapperFlags: EmfPlusRecordType = 16;
pub const EmfPlusRecordType_EmfRecordTypeSetMapMode: EmfPlusRecordType = 17;
pub const EmfPlusRecordType_EmfRecordTypeSetBkMode: EmfPlusRecordType = 18;
pub const EmfPlusRecordType_EmfRecordTypeSetPolyFillMode: EmfPlusRecordType = 19;
pub const EmfPlusRecordType_EmfRecordTypeSetROP2: EmfPlusRecordType = 20;
pub const EmfPlusRecordType_EmfRecordTypeSetStretchBltMode: EmfPlusRecordType = 21;
pub const EmfPlusRecordType_EmfRecordTypeSetTextAlign: EmfPlusRecordType = 22;
pub const EmfPlusRecordType_EmfRecordTypeSetColorAdjustment: EmfPlusRecordType = 23;
pub const EmfPlusRecordType_EmfRecordTypeSetTextColor: EmfPlusRecordType = 24;
pub const EmfPlusRecordType_EmfRecordTypeSetBkColor: EmfPlusRecordType = 25;
pub const EmfPlusRecordType_EmfRecordTypeOffsetClipRgn: EmfPlusRecordType = 26;
pub const EmfPlusRecordType_EmfRecordTypeMoveToEx: EmfPlusRecordType = 27;
pub const EmfPlusRecordType_EmfRecordTypeSetMetaRgn: EmfPlusRecordType = 28;
pub const EmfPlusRecordType_EmfRecordTypeExcludeClipRect: EmfPlusRecordType = 29;
pub const EmfPlusRecordType_EmfRecordTypeIntersectClipRect: EmfPlusRecordType = 30;
pub const EmfPlusRecordType_EmfRecordTypeScaleViewportExtEx: EmfPlusRecordType = 31;
pub const EmfPlusRecordType_EmfRecordTypeScaleWindowExtEx: EmfPlusRecordType = 32;
pub const EmfPlusRecordType_EmfRecordTypeSaveDC: EmfPlusRecordType = 33;
pub const EmfPlusRecordType_EmfRecordTypeRestoreDC: EmfPlusRecordType = 34;
pub const EmfPlusRecordType_EmfRecordTypeSetWorldTransform: EmfPlusRecordType = 35;
pub const EmfPlusRecordType_EmfRecordTypeModifyWorldTransform: EmfPlusRecordType = 36;
pub const EmfPlusRecordType_EmfRecordTypeSelectObject: EmfPlusRecordType = 37;
pub const EmfPlusRecordType_EmfRecordTypeCreatePen: EmfPlusRecordType = 38;
pub const EmfPlusRecordType_EmfRecordTypeCreateBrushIndirect: EmfPlusRecordType = 39;
pub const EmfPlusRecordType_EmfRecordTypeDeleteObject: EmfPlusRecordType = 40;
pub const EmfPlusRecordType_EmfRecordTypeAngleArc: EmfPlusRecordType = 41;
pub const EmfPlusRecordType_EmfRecordTypeEllipse: EmfPlusRecordType = 42;
pub const EmfPlusRecordType_EmfRecordTypeRectangle: EmfPlusRecordType = 43;
pub const EmfPlusRecordType_EmfRecordTypeRoundRect: EmfPlusRecordType = 44;
pub const EmfPlusRecordType_EmfRecordTypeArc: EmfPlusRecordType = 45;
pub const EmfPlusRecordType_EmfRecordTypeChord: EmfPlusRecordType = 46;
pub const EmfPlusRecordType_EmfRecordTypePie: EmfPlusRecordType = 47;
pub const EmfPlusRecordType_EmfRecordTypeSelectPalette: EmfPlusRecordType = 48;
pub const EmfPlusRecordType_EmfRecordTypeCreatePalette: EmfPlusRecordType = 49;
pub const EmfPlusRecordType_EmfRecordTypeSetPaletteEntries: EmfPlusRecordType = 50;
pub const EmfPlusRecordType_EmfRecordTypeResizePalette: EmfPlusRecordType = 51;
pub const EmfPlusRecordType_EmfRecordTypeRealizePalette: EmfPlusRecordType = 52;
pub const EmfPlusRecordType_EmfRecordTypeExtFloodFill: EmfPlusRecordType = 53;
pub const EmfPlusRecordType_EmfRecordTypeLineTo: EmfPlusRecordType = 54;
pub const EmfPlusRecordType_EmfRecordTypeArcTo: EmfPlusRecordType = 55;
pub const EmfPlusRecordType_EmfRecordTypePolyDraw: EmfPlusRecordType = 56;
pub const EmfPlusRecordType_EmfRecordTypeSetArcDirection: EmfPlusRecordType = 57;
pub const EmfPlusRecordType_EmfRecordTypeSetMiterLimit: EmfPlusRecordType = 58;
pub const EmfPlusRecordType_EmfRecordTypeBeginPath: EmfPlusRecordType = 59;
pub const EmfPlusRecordType_EmfRecordTypeEndPath: EmfPlusRecordType = 60;
pub const EmfPlusRecordType_EmfRecordTypeCloseFigure: EmfPlusRecordType = 61;
pub const EmfPlusRecordType_EmfRecordTypeFillPath: EmfPlusRecordType = 62;
pub const EmfPlusRecordType_EmfRecordTypeStrokeAndFillPath: EmfPlusRecordType = 63;
pub const EmfPlusRecordType_EmfRecordTypeStrokePath: EmfPlusRecordType = 64;
pub const EmfPlusRecordType_EmfRecordTypeFlattenPath: EmfPlusRecordType = 65;
pub const EmfPlusRecordType_EmfRecordTypeWidenPath: EmfPlusRecordType = 66;
pub const EmfPlusRecordType_EmfRecordTypeSelectClipPath: EmfPlusRecordType = 67;
pub const EmfPlusRecordType_EmfRecordTypeAbortPath: EmfPlusRecordType = 68;
pub const EmfPlusRecordType_EmfRecordTypeReserved_069: EmfPlusRecordType = 69;
pub const EmfPlusRecordType_EmfRecordTypeGdiComment: EmfPlusRecordType = 70;
pub const EmfPlusRecordType_EmfRecordTypeFillRgn: EmfPlusRecordType = 71;
pub const EmfPlusRecordType_EmfRecordTypeFrameRgn: EmfPlusRecordType = 72;
pub const EmfPlusRecordType_EmfRecordTypeInvertRgn: EmfPlusRecordType = 73;
pub const EmfPlusRecordType_EmfRecordTypePaintRgn: EmfPlusRecordType = 74;
pub const EmfPlusRecordType_EmfRecordTypeExtSelectClipRgn: EmfPlusRecordType = 75;
pub const EmfPlusRecordType_EmfRecordTypeBitBlt: EmfPlusRecordType = 76;
pub const EmfPlusRecordType_EmfRecordTypeStretchBlt: EmfPlusRecordType = 77;
pub const EmfPlusRecordType_EmfRecordTypeMaskBlt: EmfPlusRecordType = 78;
pub const EmfPlusRecordType_EmfRecordTypePlgBlt: EmfPlusRecordType = 79;
pub const EmfPlusRecordType_EmfRecordTypeSetDIBitsToDevice: EmfPlusRecordType = 80;
pub const EmfPlusRecordType_EmfRecordTypeStretchDIBits: EmfPlusRecordType = 81;
pub const EmfPlusRecordType_EmfRecordTypeExtCreateFontIndirect: EmfPlusRecordType = 82;
pub const EmfPlusRecordType_EmfRecordTypeExtTextOutA: EmfPlusRecordType = 83;
pub const EmfPlusRecordType_EmfRecordTypeExtTextOutW: EmfPlusRecordType = 84;
pub const EmfPlusRecordType_EmfRecordTypePolyBezier16: EmfPlusRecordType = 85;
pub const EmfPlusRecordType_EmfRecordTypePolygon16: EmfPlusRecordType = 86;
pub const EmfPlusRecordType_EmfRecordTypePolyline16: EmfPlusRecordType = 87;
pub const EmfPlusRecordType_EmfRecordTypePolyBezierTo16: EmfPlusRecordType = 88;
pub const EmfPlusRecordType_EmfRecordTypePolylineTo16: EmfPlusRecordType = 89;
pub const EmfPlusRecordType_EmfRecordTypePolyPolyline16: EmfPlusRecordType = 90;
pub const EmfPlusRecordType_EmfRecordTypePolyPolygon16: EmfPlusRecordType = 91;
pub const EmfPlusRecordType_EmfRecordTypePolyDraw16: EmfPlusRecordType = 92;
pub const EmfPlusRecordType_EmfRecordTypeCreateMonoBrush: EmfPlusRecordType = 93;
pub const EmfPlusRecordType_EmfRecordTypeCreateDIBPatternBrushPt: EmfPlusRecordType = 94;
pub const EmfPlusRecordType_EmfRecordTypeExtCreatePen: EmfPlusRecordType = 95;
pub const EmfPlusRecordType_EmfRecordTypePolyTextOutA: EmfPlusRecordType = 96;
pub const EmfPlusRecordType_EmfRecordTypePolyTextOutW: EmfPlusRecordType = 97;
pub const EmfPlusRecordType_EmfRecordTypeSetICMMode: EmfPlusRecordType = 98;
pub const EmfPlusRecordType_EmfRecordTypeCreateColorSpace: EmfPlusRecordType = 99;
pub const EmfPlusRecordType_EmfRecordTypeSetColorSpace: EmfPlusRecordType = 100;
pub const EmfPlusRecordType_EmfRecordTypeDeleteColorSpace: EmfPlusRecordType = 101;
pub const EmfPlusRecordType_EmfRecordTypeGLSRecord: EmfPlusRecordType = 102;
pub const EmfPlusRecordType_EmfRecordTypeGLSBoundedRecord: EmfPlusRecordType = 103;
pub const EmfPlusRecordType_EmfRecordTypePixelFormat: EmfPlusRecordType = 104;
pub const EmfPlusRecordType_EmfRecordTypeDrawEscape: EmfPlusRecordType = 105;
pub const EmfPlusRecordType_EmfRecordTypeExtEscape: EmfPlusRecordType = 106;
pub const EmfPlusRecordType_EmfRecordTypeStartDoc: EmfPlusRecordType = 107;
pub const EmfPlusRecordType_EmfRecordTypeSmallTextOut: EmfPlusRecordType = 108;
pub const EmfPlusRecordType_EmfRecordTypeForceUFIMapping: EmfPlusRecordType = 109;
pub const EmfPlusRecordType_EmfRecordTypeNamedEscape: EmfPlusRecordType = 110;
pub const EmfPlusRecordType_EmfRecordTypeColorCorrectPalette: EmfPlusRecordType = 111;
pub const EmfPlusRecordType_EmfRecordTypeSetICMProfileA: EmfPlusRecordType = 112;
pub const EmfPlusRecordType_EmfRecordTypeSetICMProfileW: EmfPlusRecordType = 113;
pub const EmfPlusRecordType_EmfRecordTypeAlphaBlend: EmfPlusRecordType = 114;
pub const EmfPlusRecordType_EmfRecordTypeSetLayout: EmfPlusRecordType = 115;
pub const EmfPlusRecordType_EmfRecordTypeTransparentBlt: EmfPlusRecordType = 116;
pub const EmfPlusRecordType_EmfRecordTypeReserved_117: EmfPlusRecordType = 117;
pub const EmfPlusRecordType_EmfRecordTypeGradientFill: EmfPlusRecordType = 118;
pub const EmfPlusRecordType_EmfRecordTypeSetLinkedUFIs: EmfPlusRecordType = 119;
pub const EmfPlusRecordType_EmfRecordTypeSetTextJustification: EmfPlusRecordType = 120;
pub const EmfPlusRecordType_EmfRecordTypeColorMatchToTargetW: EmfPlusRecordType = 121;
pub const EmfPlusRecordType_EmfRecordTypeCreateColorSpaceW: EmfPlusRecordType = 122;
pub const EmfPlusRecordType_EmfRecordTypeMax: EmfPlusRecordType = 122;
pub const EmfPlusRecordType_EmfRecordTypeMin: EmfPlusRecordType = 1;
pub const EmfPlusRecordType_EmfPlusRecordTypeInvalid: EmfPlusRecordType = 16384;
pub const EmfPlusRecordType_EmfPlusRecordTypeHeader: EmfPlusRecordType = 16385;
pub const EmfPlusRecordType_EmfPlusRecordTypeEndOfFile: EmfPlusRecordType = 16386;
pub const EmfPlusRecordType_EmfPlusRecordTypeComment: EmfPlusRecordType = 16387;
pub const EmfPlusRecordType_EmfPlusRecordTypeGetDC: EmfPlusRecordType = 16388;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiFormatStart: EmfPlusRecordType = 16389;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiFormatSection: EmfPlusRecordType = 16390;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiFormatEnd: EmfPlusRecordType = 16391;
pub const EmfPlusRecordType_EmfPlusRecordTypeObject: EmfPlusRecordType = 16392;
pub const EmfPlusRecordType_EmfPlusRecordTypeClear: EmfPlusRecordType = 16393;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillRects: EmfPlusRecordType = 16394;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawRects: EmfPlusRecordType = 16395;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillPolygon: EmfPlusRecordType = 16396;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawLines: EmfPlusRecordType = 16397;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillEllipse: EmfPlusRecordType = 16398;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawEllipse: EmfPlusRecordType = 16399;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillPie: EmfPlusRecordType = 16400;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawPie: EmfPlusRecordType = 16401;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawArc: EmfPlusRecordType = 16402;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillRegion: EmfPlusRecordType = 16403;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillPath: EmfPlusRecordType = 16404;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawPath: EmfPlusRecordType = 16405;
pub const EmfPlusRecordType_EmfPlusRecordTypeFillClosedCurve: EmfPlusRecordType = 16406;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawClosedCurve: EmfPlusRecordType = 16407;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawCurve: EmfPlusRecordType = 16408;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawBeziers: EmfPlusRecordType = 16409;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawImage: EmfPlusRecordType = 16410;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawImagePoints: EmfPlusRecordType = 16411;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawString: EmfPlusRecordType = 16412;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetRenderingOrigin: EmfPlusRecordType = 16413;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetAntiAliasMode: EmfPlusRecordType = 16414;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetTextRenderingHint: EmfPlusRecordType = 16415;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetTextContrast: EmfPlusRecordType = 16416;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetInterpolationMode: EmfPlusRecordType = 16417;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetPixelOffsetMode: EmfPlusRecordType = 16418;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetCompositingMode: EmfPlusRecordType = 16419;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetCompositingQuality: EmfPlusRecordType = 16420;
pub const EmfPlusRecordType_EmfPlusRecordTypeSave: EmfPlusRecordType = 16421;
pub const EmfPlusRecordType_EmfPlusRecordTypeRestore: EmfPlusRecordType = 16422;
pub const EmfPlusRecordType_EmfPlusRecordTypeBeginContainer: EmfPlusRecordType = 16423;
pub const EmfPlusRecordType_EmfPlusRecordTypeBeginContainerNoParams: EmfPlusRecordType = 16424;
pub const EmfPlusRecordType_EmfPlusRecordTypeEndContainer: EmfPlusRecordType = 16425;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetWorldTransform: EmfPlusRecordType = 16426;
pub const EmfPlusRecordType_EmfPlusRecordTypeResetWorldTransform: EmfPlusRecordType = 16427;
pub const EmfPlusRecordType_EmfPlusRecordTypeMultiplyWorldTransform: EmfPlusRecordType = 16428;
pub const EmfPlusRecordType_EmfPlusRecordTypeTranslateWorldTransform: EmfPlusRecordType = 16429;
pub const EmfPlusRecordType_EmfPlusRecordTypeScaleWorldTransform: EmfPlusRecordType = 16430;
pub const EmfPlusRecordType_EmfPlusRecordTypeRotateWorldTransform: EmfPlusRecordType = 16431;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetPageTransform: EmfPlusRecordType = 16432;
pub const EmfPlusRecordType_EmfPlusRecordTypeResetClip: EmfPlusRecordType = 16433;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetClipRect: EmfPlusRecordType = 16434;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetClipPath: EmfPlusRecordType = 16435;
pub const EmfPlusRecordType_EmfPlusRecordTypeSetClipRegion: EmfPlusRecordType = 16436;
pub const EmfPlusRecordType_EmfPlusRecordTypeOffsetClip: EmfPlusRecordType = 16437;
pub const EmfPlusRecordType_EmfPlusRecordTypeDrawDriverString: EmfPlusRecordType = 16438;
pub const EmfPlusRecordType_EmfPlusRecordTotal: EmfPlusRecordType = 16439;
pub const EmfPlusRecordType_EmfPlusRecordTypeMax: EmfPlusRecordType = 16438;
pub const EmfPlusRecordType_EmfPlusRecordTypeMin: EmfPlusRecordType = 16385;
pub type EmfPlusRecordType = ::core::ffi::c_int;
pub const StringTrimming_StringTrimmingNone: StringTrimming = 0;
pub const StringTrimming_StringTrimmingCharacter: StringTrimming = 1;
pub const StringTrimming_StringTrimmingWord: StringTrimming = 2;
pub const StringTrimming_StringTrimmingEllipsisCharacter: StringTrimming = 3;
pub const StringTrimming_StringTrimmingEllipsisWord: StringTrimming = 4;
pub const StringTrimming_StringTrimmingEllipsisPath: StringTrimming = 5;
pub type StringTrimming = ::core::ffi::c_int;
pub const StringDigitSubstitute_StringDigitSubstituteUser: StringDigitSubstitute = 0;
pub const StringDigitSubstitute_StringDigitSubstituteNone: StringDigitSubstitute = 1;
pub const StringDigitSubstitute_StringDigitSubstituteNational: StringDigitSubstitute = 2;
pub const StringDigitSubstitute_StringDigitSubstituteTraditional: StringDigitSubstitute = 3;
pub type StringDigitSubstitute = ::core::ffi::c_int;
pub const StringAlignment_StringAlignmentNear: StringAlignment = 0;
pub const StringAlignment_StringAlignmentCenter: StringAlignment = 1;
pub const StringAlignment_StringAlignmentFar: StringAlignment = 2;
pub type StringAlignment = ::core::ffi::c_int;
pub const FlushIntention_FlushIntentionFlush: FlushIntention = 0;
pub const FlushIntention_FlushIntentionSync: FlushIntention = 1;
pub type FlushIntention = ::core::ffi::c_int;
pub const GpTestControlEnum_TestControlForceBilinear: GpTestControlEnum = 0;
pub const GpTestControlEnum_TestControlNoICM: GpTestControlEnum = 1;
pub const GpTestControlEnum_TestControlGetBuildNumber: GpTestControlEnum = 2;
pub type GpTestControlEnum = ::core::ffi::c_int;
pub type ImageAbort =
    ::core::option::Option<unsafe extern "stdcall" fn(arg1: *mut ::core::ffi::c_void) -> BOOL>;
pub type DrawImageAbort = ImageAbort;
pub type GetThumbnailImageAbort = ImageAbort;
pub type EnumerateMetafileProc = ::core::option::Option<
    unsafe extern "stdcall" fn(
        arg1: EmfPlusRecordType,
        arg2: UINT,
        arg3: UINT,
        arg4: *const BYTE,
        arg5: *mut ::core::ffi::c_void,
    ) -> BOOL,
>;
pub type REAL = f32;
pub const Status_Ok: Status = 0;
pub const Status_GenericError: Status = 1;
pub const Status_InvalidParameter: Status = 2;
pub const Status_OutOfMemory: Status = 3;
pub const Status_ObjectBusy: Status = 4;
pub const Status_InsufficientBuffer: Status = 5;
pub const Status_NotImplemented: Status = 6;
pub const Status_Win32Error: Status = 7;
pub const Status_WrongState: Status = 8;
pub const Status_Aborted: Status = 9;
pub const Status_FileNotFound: Status = 10;
pub const Status_ValueOverflow: Status = 11;
pub const Status_AccessDenied: Status = 12;
pub const Status_UnknownImageFormat: Status = 13;
pub const Status_FontFamilyNotFound: Status = 14;
pub const Status_FontStyleNotFound: Status = 15;
pub const Status_NotTrueTypeFont: Status = 16;
pub const Status_UnsupportedGdiplusVersion: Status = 17;
pub const Status_GdiplusNotInitialized: Status = 18;
pub const Status_PropertyNotFound: Status = 19;
pub const Status_PropertyNotSupported: Status = 20;
pub type Status = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SizeF {
    pub Width: REAL,
    pub Height: REAL,
}
#[test]
fn bindgen_test_layout_SizeF() {
    assert_eq!(
        ::core::mem::size_of::<SizeF>(),
        8usize,
        concat!("Size of: ", stringify!(SizeF))
    );
    assert_eq!(
        ::core::mem::align_of::<SizeF>(),
        4usize,
        concat!("Alignment of ", stringify!(SizeF))
    );
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SizeF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SizeF),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<SizeF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SizeF),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PointF {
    pub X: REAL,
    pub Y: REAL,
}
#[test]
fn bindgen_test_layout_PointF() {
    assert_eq!(
        ::core::mem::size_of::<PointF>(),
        8usize,
        concat!("Size of: ", stringify!(PointF))
    );
    assert_eq!(
        ::core::mem::align_of::<PointF>(),
        4usize,
        concat!("Alignment of ", stringify!(PointF))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PointF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(PointF), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PointF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(PointF), "::", stringify!(Y))
        );
    }
    test_field_Y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Point {
    pub X: INT,
    pub Y: INT,
}
#[test]
fn bindgen_test_layout_Point() {
    assert_eq!(
        ::core::mem::size_of::<Point>(),
        8usize,
        concat!("Size of: ", stringify!(Point))
    );
    assert_eq!(
        ::core::mem::align_of::<Point>(),
        4usize,
        concat!("Alignment of ", stringify!(Point))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Point>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(Point), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Point>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(Point), "::", stringify!(Y))
        );
    }
    test_field_Y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RectF {
    pub X: REAL,
    pub Y: REAL,
    pub Width: REAL,
    pub Height: REAL,
}
#[test]
fn bindgen_test_layout_RectF() {
    assert_eq!(
        ::core::mem::size_of::<RectF>(),
        16usize,
        concat!("Size of: ", stringify!(RectF))
    );
    assert_eq!(
        ::core::mem::align_of::<RectF>(),
        4usize,
        concat!("Alignment of ", stringify!(RectF))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(RectF), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(RectF), "::", stringify!(Y))
        );
    }
    test_field_Y();
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RectF),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<RectF>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(RectF),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rect {
    pub X: INT,
    pub Y: INT,
    pub Width: INT,
    pub Height: INT,
}
#[test]
fn bindgen_test_layout_Rect() {
    assert_eq!(
        ::core::mem::size_of::<Rect>(),
        16usize,
        concat!("Size of: ", stringify!(Rect))
    );
    assert_eq!(
        ::core::mem::align_of::<Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(Rect))
    );
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(Rect), "::", stringify!(X))
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(Rect), "::", stringify!(Y))
        );
    }
    test_field_Y();
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Rect),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Rect>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Rect),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
}
#[repr(C)]
#[derive(Debug)]
pub struct PathData {
    pub Count: INT,
    pub Points: *mut PointF,
    pub Types: *mut BYTE,
}
#[test]
fn bindgen_test_layout_PathData() {
    assert_eq!(
        ::core::mem::size_of::<PathData>(),
        12usize,
        concat!("Size of: ", stringify!(PathData))
    );
    assert_eq!(
        ::core::mem::align_of::<PathData>(),
        4usize,
        concat!("Alignment of ", stringify!(PathData))
    );
    fn test_field_Count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PathData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PathData),
                "::",
                stringify!(Count)
            )
        );
    }
    test_field_Count();
    fn test_field_Points() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PathData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Points) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(PathData),
                "::",
                stringify!(Points)
            )
        );
    }
    test_field_Points();
    fn test_field_Types() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PathData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Types) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PathData),
                "::",
                stringify!(Types)
            )
        );
    }
    test_field_Types();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CharacterRange {
    pub First: INT,
    pub Length: INT,
}
#[test]
fn bindgen_test_layout_CharacterRange() {
    assert_eq!(
        ::core::mem::size_of::<CharacterRange>(),
        8usize,
        concat!("Size of: ", stringify!(CharacterRange))
    );
    assert_eq!(
        ::core::mem::align_of::<CharacterRange>(),
        4usize,
        concat!("Alignment of ", stringify!(CharacterRange))
    );
    fn test_field_First() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CharacterRange>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).First) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(CharacterRange),
                "::",
                stringify!(First)
            )
        );
    }
    test_field_First();
    fn test_field_Length() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CharacterRange>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CharacterRange),
                "::",
                stringify!(Length)
            )
        );
    }
    test_field_Length();
}
pub const DebugEventLevel_DebugEventLevelFatal: DebugEventLevel = 0;
pub const DebugEventLevel_DebugEventLevelWarning: DebugEventLevel = 1;
pub type DebugEventLevel = ::core::ffi::c_int;
pub type DebugEventProc =
    ::core::option::Option<unsafe extern "stdcall" fn(level: DebugEventLevel, message: *mut CHAR)>;
pub type NotificationHookProc =
    ::core::option::Option<unsafe extern "stdcall" fn(token: *mut ULONG_PTR) -> Status>;
pub type NotificationUnhookProc =
    ::core::option::Option<unsafe extern "stdcall" fn(token: ULONG_PTR)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GdiplusStartupInput {
    pub GdiplusVersion: UINT32,
    pub DebugEventCallback: DebugEventProc,
    pub SuppressBackgroundThread: BOOL,
    pub SuppressExternalCodecs: BOOL,
}
#[test]
fn bindgen_test_layout_GdiplusStartupInput() {
    assert_eq!(
        ::core::mem::size_of::<GdiplusStartupInput>(),
        16usize,
        concat!("Size of: ", stringify!(GdiplusStartupInput))
    );
    assert_eq!(
        ::core::mem::align_of::<GdiplusStartupInput>(),
        4usize,
        concat!("Alignment of ", stringify!(GdiplusStartupInput))
    );
    fn test_field_GdiplusVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).GdiplusVersion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(GdiplusVersion)
            )
        );
    }
    test_field_GdiplusVersion();
    fn test_field_DebugEventCallback() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DebugEventCallback) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(DebugEventCallback)
            )
        );
    }
    test_field_DebugEventCallback();
    fn test_field_SuppressBackgroundThread() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SuppressBackgroundThread) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(SuppressBackgroundThread)
            )
        );
    }
    test_field_SuppressBackgroundThread();
    fn test_field_SuppressExternalCodecs() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupInput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SuppressExternalCodecs) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupInput),
                "::",
                stringify!(SuppressExternalCodecs)
            )
        );
    }
    test_field_SuppressExternalCodecs();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GdiplusStartupOutput {
    pub NotificationHook: NotificationHookProc,
    pub NotificationUnhook: NotificationUnhookProc,
}
#[test]
fn bindgen_test_layout_GdiplusStartupOutput() {
    assert_eq!(
        ::core::mem::size_of::<GdiplusStartupOutput>(),
        8usize,
        concat!("Size of: ", stringify!(GdiplusStartupOutput))
    );
    assert_eq!(
        ::core::mem::align_of::<GdiplusStartupOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(GdiplusStartupOutput))
    );
    fn test_field_NotificationHook() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupOutput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).NotificationHook) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupOutput),
                "::",
                stringify!(NotificationHook)
            )
        );
    }
    test_field_NotificationHook();
    fn test_field_NotificationUnhook() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GdiplusStartupOutput>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).NotificationUnhook) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GdiplusStartupOutput),
                "::",
                stringify!(NotificationUnhook)
            )
        );
    }
    test_field_NotificationUnhook();
}
extern "stdcall" {
    pub fn GdiplusStartup(
        token: *mut ULONG_PTR,
        input: *const GdiplusStartupInput,
        output: *mut GdiplusStartupOutput,
    ) -> Status;
}
extern "stdcall" {
    pub fn GdiplusShutdown(token: ULONG_PTR);
}
pub type ARGB = DWORD;
pub type PixelFormat = INT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorPalette {
    pub Flags: UINT,
    pub Count: UINT,
    pub Entries: [ARGB; 1usize],
}
#[test]
fn bindgen_test_layout_ColorPalette() {
    assert_eq!(
        ::core::mem::size_of::<ColorPalette>(),
        12usize,
        concat!("Size of: ", stringify!(ColorPalette))
    );
    assert_eq!(
        ::core::mem::align_of::<ColorPalette>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorPalette))
    );
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorPalette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorPalette),
                "::",
                stringify!(Flags)
            )
        );
    }
    test_field_Flags();
    fn test_field_Count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorPalette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorPalette),
                "::",
                stringify!(Count)
            )
        );
    }
    test_field_Count();
    fn test_field_Entries() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorPalette>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Entries) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorPalette),
                "::",
                stringify!(Entries)
            )
        );
    }
    test_field_Entries();
}
pub const ColorChannelFlags_ColorChannelFlagsC: ColorChannelFlags = 0;
pub const ColorChannelFlags_ColorChannelFlagsM: ColorChannelFlags = 1;
pub const ColorChannelFlags_ColorChannelFlagsY: ColorChannelFlags = 2;
pub const ColorChannelFlags_ColorChannelFlagsK: ColorChannelFlags = 3;
pub const ColorChannelFlags_ColorChannelFlagsLast: ColorChannelFlags = 4;
pub type ColorChannelFlags = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Color {
    pub Argb: ARGB,
}
pub const Color_AliceBlue: Color__bindgen_ty_1 = -984833;
pub const Color_AntiqueWhite: Color__bindgen_ty_1 = -332841;
pub const Color_Aqua: Color__bindgen_ty_1 = -16711681;
pub const Color_Aquamarine: Color__bindgen_ty_1 = -8388652;
pub const Color_Azure: Color__bindgen_ty_1 = -983041;
pub const Color_Beige: Color__bindgen_ty_1 = -657956;
pub const Color_Bisque: Color__bindgen_ty_1 = -6972;
pub const Color_Black: Color__bindgen_ty_1 = -16777216;
pub const Color_BlanchedAlmond: Color__bindgen_ty_1 = -5171;
pub const Color_Blue: Color__bindgen_ty_1 = -16776961;
pub const Color_BlueViolet: Color__bindgen_ty_1 = -7722014;
pub const Color_Brown: Color__bindgen_ty_1 = -5952982;
pub const Color_BurlyWood: Color__bindgen_ty_1 = -2180985;
pub const Color_CadetBlue: Color__bindgen_ty_1 = -10510688;
pub const Color_Chartreuse: Color__bindgen_ty_1 = -8388864;
pub const Color_Chocolate: Color__bindgen_ty_1 = -2987746;
pub const Color_Coral: Color__bindgen_ty_1 = -32944;
pub const Color_CornflowerBlue: Color__bindgen_ty_1 = -10185235;
pub const Color_Cornsilk: Color__bindgen_ty_1 = -1828;
pub const Color_Crimson: Color__bindgen_ty_1 = -2354116;
pub const Color_Cyan: Color__bindgen_ty_1 = -16711681;
pub const Color_DarkBlue: Color__bindgen_ty_1 = -16777077;
pub const Color_DarkCyan: Color__bindgen_ty_1 = -16741493;
pub const Color_DarkGoldenrod: Color__bindgen_ty_1 = -4684277;
pub const Color_DarkGray: Color__bindgen_ty_1 = -5658199;
pub const Color_DarkGreen: Color__bindgen_ty_1 = -16751616;
pub const Color_DarkKhaki: Color__bindgen_ty_1 = -4343957;
pub const Color_DarkMagenta: Color__bindgen_ty_1 = -7667573;
pub const Color_DarkOliveGreen: Color__bindgen_ty_1 = -11179217;
pub const Color_DarkOrange: Color__bindgen_ty_1 = -29696;
pub const Color_DarkOrchid: Color__bindgen_ty_1 = -6737204;
pub const Color_DarkRed: Color__bindgen_ty_1 = -7667712;
pub const Color_DarkSalmon: Color__bindgen_ty_1 = -1468806;
pub const Color_DarkSeaGreen: Color__bindgen_ty_1 = -7357301;
pub const Color_DarkSlateBlue: Color__bindgen_ty_1 = -12042869;
pub const Color_DarkSlateGray: Color__bindgen_ty_1 = -13676721;
pub const Color_DarkTurquoise: Color__bindgen_ty_1 = -16724271;
pub const Color_DarkViolet: Color__bindgen_ty_1 = -7077677;
pub const Color_DeepPink: Color__bindgen_ty_1 = -60269;
pub const Color_DeepSkyBlue: Color__bindgen_ty_1 = -16728065;
pub const Color_DimGray: Color__bindgen_ty_1 = -9868951;
pub const Color_DodgerBlue: Color__bindgen_ty_1 = -14774017;
pub const Color_Firebrick: Color__bindgen_ty_1 = -5103070;
pub const Color_FloralWhite: Color__bindgen_ty_1 = -1296;
pub const Color_ForestGreen: Color__bindgen_ty_1 = -14513374;
pub const Color_Fuchsia: Color__bindgen_ty_1 = -65281;
pub const Color_Gainsboro: Color__bindgen_ty_1 = -2302756;
pub const Color_GhostWhite: Color__bindgen_ty_1 = -460545;
pub const Color_Gold: Color__bindgen_ty_1 = -10496;
pub const Color_Goldenrod: Color__bindgen_ty_1 = -2448096;
pub const Color_Gray: Color__bindgen_ty_1 = -8355712;
pub const Color_Green: Color__bindgen_ty_1 = -16744448;
pub const Color_GreenYellow: Color__bindgen_ty_1 = -5374161;
pub const Color_Honeydew: Color__bindgen_ty_1 = -983056;
pub const Color_HotPink: Color__bindgen_ty_1 = -38476;
pub const Color_IndianRed: Color__bindgen_ty_1 = -3318692;
pub const Color_Indigo: Color__bindgen_ty_1 = -11861886;
pub const Color_Ivory: Color__bindgen_ty_1 = -16;
pub const Color_Khaki: Color__bindgen_ty_1 = -989556;
pub const Color_Lavender: Color__bindgen_ty_1 = -1644806;
pub const Color_LavenderBlush: Color__bindgen_ty_1 = -3851;
pub const Color_LawnGreen: Color__bindgen_ty_1 = -8586240;
pub const Color_LemonChiffon: Color__bindgen_ty_1 = -1331;
pub const Color_LightBlue: Color__bindgen_ty_1 = -5383962;
pub const Color_LightCoral: Color__bindgen_ty_1 = -1015680;
pub const Color_LightCyan: Color__bindgen_ty_1 = -2031617;
pub const Color_LightGoldenrodYellow: Color__bindgen_ty_1 = -329006;
pub const Color_LightGray: Color__bindgen_ty_1 = -2894893;
pub const Color_LightGreen: Color__bindgen_ty_1 = -7278960;
pub const Color_LightPink: Color__bindgen_ty_1 = -18751;
pub const Color_LightSalmon: Color__bindgen_ty_1 = -24454;
pub const Color_LightSeaGreen: Color__bindgen_ty_1 = -14634326;
pub const Color_LightSkyBlue: Color__bindgen_ty_1 = -7876870;
pub const Color_LightSlateGray: Color__bindgen_ty_1 = -8943463;
pub const Color_LightSteelBlue: Color__bindgen_ty_1 = -5192482;
pub const Color_LightYellow: Color__bindgen_ty_1 = -32;
pub const Color_Lime: Color__bindgen_ty_1 = -16711936;
pub const Color_LimeGreen: Color__bindgen_ty_1 = -13447886;
pub const Color_Linen: Color__bindgen_ty_1 = -331546;
pub const Color_Magenta: Color__bindgen_ty_1 = -65281;
pub const Color_Maroon: Color__bindgen_ty_1 = -8388608;
pub const Color_MediumAquamarine: Color__bindgen_ty_1 = -10039894;
pub const Color_MediumBlue: Color__bindgen_ty_1 = -16777011;
pub const Color_MediumOrchid: Color__bindgen_ty_1 = -4565549;
pub const Color_MediumPurple: Color__bindgen_ty_1 = -7114533;
pub const Color_MediumSeaGreen: Color__bindgen_ty_1 = -12799119;
pub const Color_MediumSlateBlue: Color__bindgen_ty_1 = -8689426;
pub const Color_MediumSpringGreen: Color__bindgen_ty_1 = -16713062;
pub const Color_MediumTurquoise: Color__bindgen_ty_1 = -12004916;
pub const Color_MediumVioletRed: Color__bindgen_ty_1 = -3730043;
pub const Color_MidnightBlue: Color__bindgen_ty_1 = -15132304;
pub const Color_MintCream: Color__bindgen_ty_1 = -655366;
pub const Color_MistyRose: Color__bindgen_ty_1 = -6943;
pub const Color_Moccasin: Color__bindgen_ty_1 = -6987;
pub const Color_NavajoWhite: Color__bindgen_ty_1 = -8531;
pub const Color_Navy: Color__bindgen_ty_1 = -16777088;
pub const Color_OldLace: Color__bindgen_ty_1 = -133658;
pub const Color_Olive: Color__bindgen_ty_1 = -8355840;
pub const Color_OliveDrab: Color__bindgen_ty_1 = -9728477;
pub const Color_Orange: Color__bindgen_ty_1 = -23296;
pub const Color_OrangeRed: Color__bindgen_ty_1 = -47872;
pub const Color_Orchid: Color__bindgen_ty_1 = -2461482;
pub const Color_PaleGoldenrod: Color__bindgen_ty_1 = -1120086;
pub const Color_PaleGreen: Color__bindgen_ty_1 = -6751336;
pub const Color_PaleTurquoise: Color__bindgen_ty_1 = -5247250;
pub const Color_PaleVioletRed: Color__bindgen_ty_1 = -2396013;
pub const Color_PapayaWhip: Color__bindgen_ty_1 = -4139;
pub const Color_PeachPuff: Color__bindgen_ty_1 = -9543;
pub const Color_Peru: Color__bindgen_ty_1 = -3308225;
pub const Color_Pink: Color__bindgen_ty_1 = -16181;
pub const Color_Plum: Color__bindgen_ty_1 = -2252579;
pub const Color_PowderBlue: Color__bindgen_ty_1 = -5185306;
pub const Color_Purple: Color__bindgen_ty_1 = -8388480;
pub const Color_Red: Color__bindgen_ty_1 = -65536;
pub const Color_RosyBrown: Color__bindgen_ty_1 = -4419697;
pub const Color_RoyalBlue: Color__bindgen_ty_1 = -12490271;
pub const Color_SaddleBrown: Color__bindgen_ty_1 = -7650029;
pub const Color_Salmon: Color__bindgen_ty_1 = -360334;
pub const Color_SandyBrown: Color__bindgen_ty_1 = -744352;
pub const Color_SeaGreen: Color__bindgen_ty_1 = -13726889;
pub const Color_SeaShell: Color__bindgen_ty_1 = -2578;
pub const Color_Sienna: Color__bindgen_ty_1 = -6270419;
pub const Color_Silver: Color__bindgen_ty_1 = -4144960;
pub const Color_SkyBlue: Color__bindgen_ty_1 = -7876885;
pub const Color_SlateBlue: Color__bindgen_ty_1 = -9807155;
pub const Color_SlateGray: Color__bindgen_ty_1 = -9404272;
pub const Color_Snow: Color__bindgen_ty_1 = -1286;
pub const Color_SpringGreen: Color__bindgen_ty_1 = -16711809;
pub const Color_SteelBlue: Color__bindgen_ty_1 = -12156236;
pub const Color_Tan: Color__bindgen_ty_1 = -2968436;
pub const Color_Teal: Color__bindgen_ty_1 = -16744320;
pub const Color_Thistle: Color__bindgen_ty_1 = -2572328;
pub const Color_Tomato: Color__bindgen_ty_1 = -40121;
pub const Color_Transparent: Color__bindgen_ty_1 = 16777215;
pub const Color_Turquoise: Color__bindgen_ty_1 = -12525360;
pub const Color_Violet: Color__bindgen_ty_1 = -1146130;
pub const Color_Wheat: Color__bindgen_ty_1 = -663885;
pub const Color_White: Color__bindgen_ty_1 = -1;
pub const Color_WhiteSmoke: Color__bindgen_ty_1 = -657931;
pub const Color_Yellow: Color__bindgen_ty_1 = -256;
pub const Color_YellowGreen: Color__bindgen_ty_1 = -6632142;
pub type Color__bindgen_ty_1 = ::core::ffi::c_int;
pub const Color_AlphaShift: Color__bindgen_ty_2 = 24;
pub const Color_RedShift: Color__bindgen_ty_2 = 16;
pub const Color_GreenShift: Color__bindgen_ty_2 = 8;
pub const Color_BlueShift: Color__bindgen_ty_2 = 0;
pub type Color__bindgen_ty_2 = ::core::ffi::c_int;
pub const Color_AlphaMask: Color__bindgen_ty_3 = -16777216;
pub const Color_RedMask: Color__bindgen_ty_3 = 16711680;
pub const Color_GreenMask: Color__bindgen_ty_3 = 65280;
pub const Color_BlueMask: Color__bindgen_ty_3 = 255;
pub type Color__bindgen_ty_3 = ::core::ffi::c_int;
#[test]
fn bindgen_test_layout_Color() {
    assert_eq!(
        ::core::mem::size_of::<Color>(),
        4usize,
        concat!("Size of: ", stringify!(Color))
    );
    assert_eq!(
        ::core::mem::align_of::<Color>(),
        4usize,
        concat!("Alignment of ", stringify!(Color))
    );
    fn test_field_Argb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Color>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Argb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Color),
                "::",
                stringify!(Argb)
            )
        );
    }
    test_field_Argb();
}
#[repr(C)]
pub struct ENHMETAHEADER3 {
    pub iType: DWORD,
    pub nSize: DWORD,
    pub rclBounds: RECTL,
    pub rclFrame: RECTL,
    pub dSignature: DWORD,
    pub nVersion: DWORD,
    pub nBytes: DWORD,
    pub nRecords: DWORD,
    pub nHandles: WORD,
    pub sReserved: WORD,
    pub nDescription: DWORD,
    pub offDescription: DWORD,
    pub nPalEntries: DWORD,
    pub szlDevice: SIZEL,
    pub szlMillimeters: SIZEL,
}
#[test]
fn bindgen_test_layout_ENHMETAHEADER3() {
    assert_eq!(
        ::core::mem::size_of::<ENHMETAHEADER3>(),
        88usize,
        concat!("Size of: ", stringify!(ENHMETAHEADER3))
    );
    assert_eq!(
        ::core::mem::align_of::<ENHMETAHEADER3>(),
        4usize,
        concat!("Alignment of ", stringify!(ENHMETAHEADER3))
    );
    fn test_field_iType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).iType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(iType)
            )
        );
    }
    test_field_iType();
    fn test_field_nSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nSize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nSize)
            )
        );
    }
    test_field_nSize();
    fn test_field_rclBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rclBounds) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(rclBounds)
            )
        );
    }
    test_field_rclBounds();
    fn test_field_rclFrame() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rclFrame) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(rclFrame)
            )
        );
    }
    test_field_rclFrame();
    fn test_field_dSignature() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).dSignature) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(dSignature)
            )
        );
    }
    test_field_dSignature();
    fn test_field_nVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nVersion) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nVersion)
            )
        );
    }
    test_field_nVersion();
    fn test_field_nBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nBytes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nBytes)
            )
        );
    }
    test_field_nBytes();
    fn test_field_nRecords() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nRecords) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nRecords)
            )
        );
    }
    test_field_nRecords();
    fn test_field_nHandles() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nHandles) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nHandles)
            )
        );
    }
    test_field_nHandles();
    fn test_field_sReserved() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sReserved) as usize - ptr as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(sReserved)
            )
        );
    }
    test_field_sReserved();
    fn test_field_nDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nDescription) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nDescription)
            )
        );
    }
    test_field_nDescription();
    fn test_field_offDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).offDescription) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(offDescription)
            )
        );
    }
    test_field_offDescription();
    fn test_field_nPalEntries() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nPalEntries) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(nPalEntries)
            )
        );
    }
    test_field_nPalEntries();
    fn test_field_szlDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).szlDevice) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(szlDevice)
            )
        );
    }
    test_field_szlDevice();
    fn test_field_szlMillimeters() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ENHMETAHEADER3>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).szlMillimeters) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ENHMETAHEADER3),
                "::",
                stringify!(szlMillimeters)
            )
        );
    }
    test_field_szlMillimeters();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PWMFRect16 {
    pub Left: INT16,
    pub Top: INT16,
    pub Right: INT16,
    pub Bottom: INT16,
}
#[test]
fn bindgen_test_layout_PWMFRect16() {
    assert_eq!(
        ::core::mem::size_of::<PWMFRect16>(),
        8usize,
        concat!("Size of: ", stringify!(PWMFRect16))
    );
    assert_eq!(
        ::core::mem::align_of::<PWMFRect16>(),
        2usize,
        concat!("Alignment of ", stringify!(PWMFRect16))
    );
    fn test_field_Left() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Left)
            )
        );
    }
    test_field_Left();
    fn test_field_Top() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Top) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Top)
            )
        );
    }
    test_field_Top();
    fn test_field_Right() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Right) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Right)
            )
        );
    }
    test_field_Right();
    fn test_field_Bottom() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PWMFRect16>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Bottom) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(PWMFRect16),
                "::",
                stringify!(Bottom)
            )
        );
    }
    test_field_Bottom();
}
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct WmfPlaceableFileHeader {
    pub Key: UINT32,
    pub Hmf: INT16,
    pub BoundingBox: PWMFRect16,
    pub Inch: INT16,
    pub Reserved: UINT32,
    pub Checksum: INT16,
}
#[test]
fn bindgen_test_layout_WmfPlaceableFileHeader() {
    assert_eq!(
        ::core::mem::size_of::<WmfPlaceableFileHeader>(),
        22usize,
        concat!("Size of: ", stringify!(WmfPlaceableFileHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<WmfPlaceableFileHeader>(),
        2usize,
        concat!("Alignment of ", stringify!(WmfPlaceableFileHeader))
    );
    fn test_field_Key() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Key)
            )
        );
    }
    test_field_Key();
    fn test_field_Hmf() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Hmf) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Hmf)
            )
        );
    }
    test_field_Hmf();
    fn test_field_BoundingBox() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).BoundingBox) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(BoundingBox)
            )
        );
    }
    test_field_BoundingBox();
    fn test_field_Inch() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Inch) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Inch)
            )
        );
    }
    test_field_Inch();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
    fn test_field_Checksum() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<WmfPlaceableFileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Checksum) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(WmfPlaceableFileHeader),
                "::",
                stringify!(Checksum)
            )
        );
    }
    test_field_Checksum();
}
#[repr(C)]
pub struct MetafileHeader {
    pub Type: MetafileType,
    pub Size: UINT,
    pub Version: UINT,
    pub EmfPlusFlags: UINT,
    pub DpiX: REAL,
    pub DpiY: REAL,
    pub X: INT,
    pub Y: INT,
    pub Width: INT,
    pub Height: INT,
    pub __bindgen_anon_1: MetafileHeader__bindgen_ty_1,
    pub EmfPlusHeaderSize: INT,
    pub LogicalDpiX: INT,
    pub LogicalDpiY: INT,
}
#[repr(C)]
pub struct MetafileHeader__bindgen_ty_1 {
    pub WmfHeader: __BindgenUnionField<METAHEADER>,
    pub EmfHeader: __BindgenUnionField<ENHMETAHEADER3>,
    pub bindgen_union_field: [u32; 22usize],
}
#[test]
fn bindgen_test_layout_MetafileHeader__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MetafileHeader__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(MetafileHeader__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MetafileHeader__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MetafileHeader__bindgen_ty_1))
    );
    fn test_field_WmfHeader() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).WmfHeader) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader__bindgen_ty_1),
                "::",
                stringify!(WmfHeader)
            )
        );
    }
    test_field_WmfHeader();
    fn test_field_EmfHeader() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).EmfHeader) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader__bindgen_ty_1),
                "::",
                stringify!(EmfHeader)
            )
        );
    }
    test_field_EmfHeader();
}
#[test]
fn bindgen_test_layout_MetafileHeader() {
    assert_eq!(
        ::core::mem::size_of::<MetafileHeader>(),
        140usize,
        concat!("Size of: ", stringify!(MetafileHeader))
    );
    assert_eq!(
        ::core::mem::align_of::<MetafileHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(MetafileHeader))
    );
    fn test_field_Type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Type)
            )
        );
    }
    test_field_Type();
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_EmfPlusFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).EmfPlusFlags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(EmfPlusFlags)
            )
        );
    }
    test_field_EmfPlusFlags();
    fn test_field_DpiX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DpiX) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(DpiX)
            )
        );
    }
    test_field_DpiX();
    fn test_field_DpiY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DpiY) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(DpiY)
            )
        );
    }
    test_field_DpiY();
    fn test_field_X() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).X) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(X)
            )
        );
    }
    test_field_X();
    fn test_field_Y() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Y) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Y)
            )
        );
    }
    test_field_Y();
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_EmfPlusHeaderSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).EmfPlusHeaderSize) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(EmfPlusHeaderSize)
            )
        );
    }
    test_field_EmfPlusHeaderSize();
    fn test_field_LogicalDpiX() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LogicalDpiX) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(LogicalDpiX)
            )
        );
    }
    test_field_LogicalDpiX();
    fn test_field_LogicalDpiY() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<MetafileHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).LogicalDpiY) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(MetafileHeader),
                "::",
                stringify!(LogicalDpiY)
            )
        );
    }
    test_field_LogicalDpiY();
}
#[repr(C)]
pub struct ImageCodecInfo {
    pub Clsid: CLSID,
    pub FormatID: GUID,
    pub CodecName: *const WCHAR,
    pub DllName: *const WCHAR,
    pub FormatDescription: *const WCHAR,
    pub FilenameExtension: *const WCHAR,
    pub MimeType: *const WCHAR,
    pub Flags: DWORD,
    pub Version: DWORD,
    pub SigCount: DWORD,
    pub SigSize: DWORD,
    pub SigPattern: *const BYTE,
    pub SigMask: *const BYTE,
}
#[test]
fn bindgen_test_layout_ImageCodecInfo() {
    assert_eq!(
        ::core::mem::size_of::<ImageCodecInfo>(),
        76usize,
        concat!("Size of: ", stringify!(ImageCodecInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ImageCodecInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ImageCodecInfo))
    );
    fn test_field_Clsid() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Clsid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(Clsid)
            )
        );
    }
    test_field_Clsid();
    fn test_field_FormatID() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).FormatID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(FormatID)
            )
        );
    }
    test_field_FormatID();
    fn test_field_CodecName() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).CodecName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(CodecName)
            )
        );
    }
    test_field_CodecName();
    fn test_field_DllName() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).DllName) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(DllName)
            )
        );
    }
    test_field_DllName();
    fn test_field_FormatDescription() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).FormatDescription) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(FormatDescription)
            )
        );
    }
    test_field_FormatDescription();
    fn test_field_FilenameExtension() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).FilenameExtension) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(FilenameExtension)
            )
        );
    }
    test_field_FilenameExtension();
    fn test_field_MimeType() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).MimeType) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(MimeType)
            )
        );
    }
    test_field_MimeType();
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(Flags)
            )
        );
    }
    test_field_Flags();
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_SigCount() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigCount) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigCount)
            )
        );
    }
    test_field_SigCount();
    fn test_field_SigSize() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigSize) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigSize)
            )
        );
    }
    test_field_SigSize();
    fn test_field_SigPattern() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigPattern) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigPattern)
            )
        );
    }
    test_field_SigPattern();
    fn test_field_SigMask() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ImageCodecInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).SigMask) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(ImageCodecInfo),
                "::",
                stringify!(SigMask)
            )
        );
    }
    test_field_SigMask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapData {
    pub Width: UINT,
    pub Height: UINT,
    pub Stride: INT,
    pub PixelFormat: PixelFormat,
    pub Scan0: *mut ::core::ffi::c_void,
    pub Reserved: UINT_PTR,
}
#[test]
fn bindgen_test_layout_BitmapData() {
    assert_eq!(
        ::core::mem::size_of::<BitmapData>(),
        24usize,
        concat!("Size of: ", stringify!(BitmapData))
    );
    assert_eq!(
        ::core::mem::align_of::<BitmapData>(),
        4usize,
        concat!("Alignment of ", stringify!(BitmapData))
    );
    fn test_field_Width() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Width)
            )
        );
    }
    test_field_Width();
    fn test_field_Height() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Height)
            )
        );
    }
    test_field_Height();
    fn test_field_Stride() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Stride) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Stride)
            )
        );
    }
    test_field_Stride();
    fn test_field_PixelFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).PixelFormat) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(PixelFormat)
            )
        );
    }
    test_field_PixelFormat();
    fn test_field_Scan0() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Scan0) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Scan0)
            )
        );
    }
    test_field_Scan0();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<BitmapData>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(BitmapData),
                "::",
                stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
}
pub const RotateFlipType_RotateNoneFlipNone: RotateFlipType = 0;
pub const RotateFlipType_Rotate90FlipNone: RotateFlipType = 1;
pub const RotateFlipType_Rotate180FlipNone: RotateFlipType = 2;
pub const RotateFlipType_Rotate270FlipNone: RotateFlipType = 3;
pub const RotateFlipType_RotateNoneFlipX: RotateFlipType = 4;
pub const RotateFlipType_Rotate90FlipX: RotateFlipType = 5;
pub const RotateFlipType_Rotate180FlipX: RotateFlipType = 6;
pub const RotateFlipType_Rotate270FlipX: RotateFlipType = 7;
pub const RotateFlipType_RotateNoneFlipY: RotateFlipType = 6;
pub const RotateFlipType_Rotate90FlipY: RotateFlipType = 7;
pub const RotateFlipType_Rotate180FlipY: RotateFlipType = 4;
pub const RotateFlipType_Rotate270FlipY: RotateFlipType = 5;
pub const RotateFlipType_RotateNoneFlipXY: RotateFlipType = 2;
pub const RotateFlipType_Rotate90FlipXY: RotateFlipType = 3;
pub const RotateFlipType_Rotate180FlipXY: RotateFlipType = 0;
pub const RotateFlipType_Rotate270FlipXY: RotateFlipType = 1;
pub type RotateFlipType = ::core::ffi::c_int;
#[repr(C)]
pub struct EncoderParameter {
    pub Guid: GUID,
    pub NumberOfValues: ULONG,
    pub Type: ULONG,
    pub Value: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_EncoderParameter() {
    assert_eq!(
        ::core::mem::size_of::<EncoderParameter>(),
        28usize,
        concat!("Size of: ", stringify!(EncoderParameter))
    );
    assert_eq!(
        ::core::mem::align_of::<EncoderParameter>(),
        4usize,
        concat!("Alignment of ", stringify!(EncoderParameter))
    );
    fn test_field_Guid() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Guid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(Guid)
            )
        );
    }
    test_field_Guid();
    fn test_field_NumberOfValues() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).NumberOfValues) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(NumberOfValues)
            )
        );
    }
    test_field_NumberOfValues();
    fn test_field_Type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(Type)
            )
        );
    }
    test_field_Type();
    fn test_field_Value() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameter>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameter),
                "::",
                stringify!(Value)
            )
        );
    }
    test_field_Value();
}
#[repr(C)]
pub struct EncoderParameters {
    pub Count: UINT,
    pub Parameter: [EncoderParameter; 1usize],
}
#[test]
fn bindgen_test_layout_EncoderParameters() {
    assert_eq!(
        ::core::mem::size_of::<EncoderParameters>(),
        32usize,
        concat!("Size of: ", stringify!(EncoderParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<EncoderParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(EncoderParameters))
    );
    fn test_field_Count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameters),
                "::",
                stringify!(Count)
            )
        );
    }
    test_field_Count();
    fn test_field_Parameter() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<EncoderParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).Parameter) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(EncoderParameters),
                "::",
                stringify!(Parameter)
            )
        );
    }
    test_field_Parameter();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyItem {
    pub id: PROPID,
    pub length: ULONG,
    pub type_: WORD,
    pub value: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_PropertyItem() {
    assert_eq!(
        ::core::mem::size_of::<PropertyItem>(),
        16usize,
        concat!("Size of: ", stringify!(PropertyItem))
    );
    assert_eq!(
        ::core::mem::align_of::<PropertyItem>(),
        4usize,
        concat!("Alignment of ", stringify!(PropertyItem))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<PropertyItem>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(PropertyItem),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorMatrix {
    pub m: [[REAL; 5usize]; 5usize],
}
#[test]
fn bindgen_test_layout_ColorMatrix() {
    assert_eq!(
        ::core::mem::size_of::<ColorMatrix>(),
        100usize,
        concat!("Size of: ", stringify!(ColorMatrix))
    );
    assert_eq!(
        ::core::mem::align_of::<ColorMatrix>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorMatrix))
    );
    fn test_field_m() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorMatrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorMatrix),
                "::",
                stringify!(m)
            )
        );
    }
    test_field_m();
}
pub const ColorMatrixFlags_ColorMatrixFlagsDefault: ColorMatrixFlags = 0;
pub const ColorMatrixFlags_ColorMatrixFlagsSkipGrays: ColorMatrixFlags = 1;
pub const ColorMatrixFlags_ColorMatrixFlagsAltGray: ColorMatrixFlags = 2;
pub type ColorMatrixFlags = ::core::ffi::c_int;
pub const ColorAdjustType_ColorAdjustTypeDefault: ColorAdjustType = 0;
pub const ColorAdjustType_ColorAdjustTypeBitmap: ColorAdjustType = 1;
pub const ColorAdjustType_ColorAdjustTypeBrush: ColorAdjustType = 2;
pub const ColorAdjustType_ColorAdjustTypePen: ColorAdjustType = 3;
pub const ColorAdjustType_ColorAdjustTypeText: ColorAdjustType = 4;
pub const ColorAdjustType_ColorAdjustTypeCount: ColorAdjustType = 5;
pub const ColorAdjustType_ColorAdjustTypeAny: ColorAdjustType = 6;
pub type ColorAdjustType = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColorMap {
    pub oldColor: Color,
    pub newColor: Color,
}
#[test]
fn bindgen_test_layout_ColorMap() {
    assert_eq!(
        ::core::mem::size_of::<ColorMap>(),
        8usize,
        concat!("Size of: ", stringify!(ColorMap))
    );
    assert_eq!(
        ::core::mem::align_of::<ColorMap>(),
        4usize,
        concat!("Alignment of ", stringify!(ColorMap))
    );
    fn test_field_oldColor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorMap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).oldColor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorMap),
                "::",
                stringify!(oldColor)
            )
        );
    }
    test_field_oldColor();
    fn test_field_newColor() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ColorMap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).newColor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ColorMap),
                "::",
                stringify!(newColor)
            )
        );
    }
    test_field_newColor();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpGraphics {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpGraphics() {
    assert_eq!(
        ::core::mem::size_of::<GpGraphics>(),
        1usize,
        concat!("Size of: ", stringify!(GpGraphics))
    );
    assert_eq!(
        ::core::mem::align_of::<GpGraphics>(),
        1usize,
        concat!("Alignment of ", stringify!(GpGraphics))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpBrush {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpBrush() {
    assert_eq!(
        ::core::mem::size_of::<GpBrush>(),
        1usize,
        concat!("Size of: ", stringify!(GpBrush))
    );
    assert_eq!(
        ::core::mem::align_of::<GpBrush>(),
        1usize,
        concat!("Alignment of ", stringify!(GpBrush))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpTexture {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpTexture() {
    assert_eq!(
        ::core::mem::size_of::<GpTexture>(),
        1usize,
        concat!("Size of: ", stringify!(GpTexture))
    );
    assert_eq!(
        ::core::mem::align_of::<GpTexture>(),
        1usize,
        concat!("Alignment of ", stringify!(GpTexture))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpSolidFill {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpSolidFill() {
    assert_eq!(
        ::core::mem::size_of::<GpSolidFill>(),
        1usize,
        concat!("Size of: ", stringify!(GpSolidFill))
    );
    assert_eq!(
        ::core::mem::align_of::<GpSolidFill>(),
        1usize,
        concat!("Alignment of ", stringify!(GpSolidFill))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpLineGradient {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpLineGradient() {
    assert_eq!(
        ::core::mem::size_of::<GpLineGradient>(),
        1usize,
        concat!("Size of: ", stringify!(GpLineGradient))
    );
    assert_eq!(
        ::core::mem::align_of::<GpLineGradient>(),
        1usize,
        concat!("Alignment of ", stringify!(GpLineGradient))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPathGradient {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPathGradient() {
    assert_eq!(
        ::core::mem::size_of::<GpPathGradient>(),
        1usize,
        concat!("Size of: ", stringify!(GpPathGradient))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPathGradient>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPathGradient))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpHatch {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpHatch() {
    assert_eq!(
        ::core::mem::size_of::<GpHatch>(),
        1usize,
        concat!("Size of: ", stringify!(GpHatch))
    );
    assert_eq!(
        ::core::mem::align_of::<GpHatch>(),
        1usize,
        concat!("Alignment of ", stringify!(GpHatch))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPen {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPen() {
    assert_eq!(
        ::core::mem::size_of::<GpPen>(),
        1usize,
        concat!("Size of: ", stringify!(GpPen))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPen>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPen))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpCustomLineCap {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpCustomLineCap() {
    assert_eq!(
        ::core::mem::size_of::<GpCustomLineCap>(),
        1usize,
        concat!("Size of: ", stringify!(GpCustomLineCap))
    );
    assert_eq!(
        ::core::mem::align_of::<GpCustomLineCap>(),
        1usize,
        concat!("Alignment of ", stringify!(GpCustomLineCap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpAdjustableArrowCap {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpAdjustableArrowCap() {
    assert_eq!(
        ::core::mem::size_of::<GpAdjustableArrowCap>(),
        1usize,
        concat!("Size of: ", stringify!(GpAdjustableArrowCap))
    );
    assert_eq!(
        ::core::mem::align_of::<GpAdjustableArrowCap>(),
        1usize,
        concat!("Alignment of ", stringify!(GpAdjustableArrowCap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpImage {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpImage() {
    assert_eq!(
        ::core::mem::size_of::<GpImage>(),
        1usize,
        concat!("Size of: ", stringify!(GpImage))
    );
    assert_eq!(
        ::core::mem::align_of::<GpImage>(),
        1usize,
        concat!("Alignment of ", stringify!(GpImage))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpBitmap {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpBitmap() {
    assert_eq!(
        ::core::mem::size_of::<GpBitmap>(),
        1usize,
        concat!("Size of: ", stringify!(GpBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<GpBitmap>(),
        1usize,
        concat!("Alignment of ", stringify!(GpBitmap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpMetafile {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpMetafile() {
    assert_eq!(
        ::core::mem::size_of::<GpMetafile>(),
        1usize,
        concat!("Size of: ", stringify!(GpMetafile))
    );
    assert_eq!(
        ::core::mem::align_of::<GpMetafile>(),
        1usize,
        concat!("Alignment of ", stringify!(GpMetafile))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpImageAttributes {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpImageAttributes() {
    assert_eq!(
        ::core::mem::size_of::<GpImageAttributes>(),
        1usize,
        concat!("Size of: ", stringify!(GpImageAttributes))
    );
    assert_eq!(
        ::core::mem::align_of::<GpImageAttributes>(),
        1usize,
        concat!("Alignment of ", stringify!(GpImageAttributes))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPath {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPath() {
    assert_eq!(
        ::core::mem::size_of::<GpPath>(),
        1usize,
        concat!("Size of: ", stringify!(GpPath))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPath>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPath))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpRegion {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpRegion() {
    assert_eq!(
        ::core::mem::size_of::<GpRegion>(),
        1usize,
        concat!("Size of: ", stringify!(GpRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<GpRegion>(),
        1usize,
        concat!("Alignment of ", stringify!(GpRegion))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpPathIterator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpPathIterator() {
    assert_eq!(
        ::core::mem::size_of::<GpPathIterator>(),
        1usize,
        concat!("Size of: ", stringify!(GpPathIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<GpPathIterator>(),
        1usize,
        concat!("Alignment of ", stringify!(GpPathIterator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpFontFamily {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpFontFamily() {
    assert_eq!(
        ::core::mem::size_of::<GpFontFamily>(),
        1usize,
        concat!("Size of: ", stringify!(GpFontFamily))
    );
    assert_eq!(
        ::core::mem::align_of::<GpFontFamily>(),
        1usize,
        concat!("Alignment of ", stringify!(GpFontFamily))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpFont {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpFont() {
    assert_eq!(
        ::core::mem::size_of::<GpFont>(),
        1usize,
        concat!("Size of: ", stringify!(GpFont))
    );
    assert_eq!(
        ::core::mem::align_of::<GpFont>(),
        1usize,
        concat!("Alignment of ", stringify!(GpFont))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpStringFormat {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpStringFormat() {
    assert_eq!(
        ::core::mem::size_of::<GpStringFormat>(),
        1usize,
        concat!("Size of: ", stringify!(GpStringFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<GpStringFormat>(),
        1usize,
        concat!("Alignment of ", stringify!(GpStringFormat))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpFontCollection {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_GpFontCollection() {
    assert_eq!(
        ::core::mem::size_of::<GpFontCollection>(),
        1usize,
        concat!("Size of: ", stringify!(GpFontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<GpFontCollection>(),
        1usize,
        concat!("Alignment of ", stringify!(GpFontCollection))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpCachedBitmap {
    _unused: [u8; 0],
}
pub use self::CoordinateSpace as GpCoordinateSpace;
pub use self::FillMode as GpFillMode;
pub use self::Status as GpStatus;
pub use self::Unit as GpUnit;
pub use self::WrapMode as GpWrapMode;
pub type GpPointF = PointF;
pub type GpPoint = Point;
pub type GpRectF = RectF;
pub type GpRect = Rect;
pub use self::DashCap as GpDashCap;
pub use self::DashStyle as GpDashStyle;
pub use self::HatchStyle as GpHatchStyle;
pub use self::LineCap as GpLineCap;
pub use self::LineJoin as GpLineJoin;
pub use self::PenAlignment as GpPenAlignment;
pub use self::PenType as GpPenType;
pub type GpMatrix = Matrix;
pub use self::BrushType as GpBrushType;
pub use self::FlushIntention as GpFlushIntention;
pub use self::MatrixOrder as GpMatrixOrder;
pub type GpPathData = PathData;
#[repr(C)]
#[derive(Debug)]
pub struct Region {
    pub nativeRegion: *mut GpRegion,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Region() {
    assert_eq!(
        ::core::mem::size_of::<Region>(),
        8usize,
        concat!("Size of: ", stringify!(Region))
    );
    assert_eq!(
        ::core::mem::align_of::<Region>(),
        4usize,
        concat!("Alignment of ", stringify!(Region))
    );
    fn test_field_nativeRegion() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Region>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeRegion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Region),
                "::",
                stringify!(nativeRegion)
            )
        );
    }
    test_field_nativeRegion();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Region>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Region),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?FromHRGN@Region@Gdiplus@@SAPAV12@PAUHRGN__@@@Z"]
    pub fn Region_FromHRGN(hRgn: HRGN) -> *mut Region;
}
impl Region {
    #[inline]
    pub unsafe fn FromHRGN(hRgn: HRGN) -> *mut Region {
        Region_FromHRGN(hRgn)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FontFamily {
    pub nativeFamily: *mut GpFontFamily,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_FontFamily() {
    assert_eq!(
        ::core::mem::size_of::<FontFamily>(),
        8usize,
        concat!("Size of: ", stringify!(FontFamily))
    );
    assert_eq!(
        ::core::mem::align_of::<FontFamily>(),
        4usize,
        concat!("Alignment of ", stringify!(FontFamily))
    );
    fn test_field_nativeFamily() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontFamily>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFamily) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(FontFamily),
                "::",
                stringify!(nativeFamily)
            )
        );
    }
    test_field_nativeFamily();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontFamily>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(FontFamily),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
extern "C" {
    #[link_name = "\u{1}?GenericSansSerif@FontFamily@Gdiplus@@SAPBV12@XZ"]
    pub fn FontFamily_GenericSansSerif() -> *const FontFamily;
}
extern "C" {
    #[link_name = "\u{1}?GenericSerif@FontFamily@Gdiplus@@SAPBV12@XZ"]
    pub fn FontFamily_GenericSerif() -> *const FontFamily;
}
extern "C" {
    #[link_name = "\u{1}?GenericMonospace@FontFamily@Gdiplus@@SAPBV12@XZ"]
    pub fn FontFamily_GenericMonospace() -> *const FontFamily;
}
impl FontFamily {
    #[inline]
    pub unsafe fn GenericSansSerif() -> *const FontFamily {
        FontFamily_GenericSansSerif()
    }
    #[inline]
    pub unsafe fn GenericSerif() -> *const FontFamily {
        FontFamily_GenericSerif()
    }
    #[inline]
    pub unsafe fn GenericMonospace() -> *const FontFamily {
        FontFamily_GenericMonospace()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Font {
    pub nativeFont: *mut GpFont,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Font() {
    assert_eq!(
        ::core::mem::size_of::<Font>(),
        8usize,
        concat!("Size of: ", stringify!(Font))
    );
    assert_eq!(
        ::core::mem::align_of::<Font>(),
        4usize,
        concat!("Alignment of ", stringify!(Font))
    );
    fn test_field_nativeFont() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Font>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFont) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Font),
                "::",
                stringify!(nativeFont)
            )
        );
    }
    test_field_nativeFont();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Font>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Font),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
pub struct FontCollection__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct FontCollection {
    pub vtable_: *const FontCollection__bindgen_vtable,
    pub nativeFontCollection: *mut GpFontCollection,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_FontCollection() {
    assert_eq!(
        ::core::mem::size_of::<FontCollection>(),
        12usize,
        concat!("Size of: ", stringify!(FontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<FontCollection>(),
        4usize,
        concat!("Alignment of ", stringify!(FontCollection))
    );
    fn test_field_nativeFontCollection() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontCollection>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFontCollection) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(FontCollection),
                "::",
                stringify!(nativeFontCollection)
            )
        );
    }
    test_field_nativeFontCollection();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<FontCollection>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(FontCollection),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct InstalledFontCollection {
    pub _base: FontCollection,
}
#[test]
fn bindgen_test_layout_InstalledFontCollection() {
    assert_eq!(
        ::core::mem::size_of::<InstalledFontCollection>(),
        12usize,
        concat!("Size of: ", stringify!(InstalledFontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<InstalledFontCollection>(),
        4usize,
        concat!("Alignment of ", stringify!(InstalledFontCollection))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct PrivateFontCollection {
    pub _base: FontCollection,
}
#[test]
fn bindgen_test_layout_PrivateFontCollection() {
    assert_eq!(
        ::core::mem::size_of::<PrivateFontCollection>(),
        12usize,
        concat!("Size of: ", stringify!(PrivateFontCollection))
    );
    assert_eq!(
        ::core::mem::align_of::<PrivateFontCollection>(),
        4usize,
        concat!("Alignment of ", stringify!(PrivateFontCollection))
    );
}
#[repr(C)]
pub struct Image__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Image {
    pub vtable_: *const Image__bindgen_vtable,
    pub nativeImage: *mut GpImage,
    pub lastResult: Status,
    pub loadStatus: Status,
}
#[test]
fn bindgen_test_layout_Image() {
    assert_eq!(
        ::core::mem::size_of::<Image>(),
        16usize,
        concat!("Size of: ", stringify!(Image))
    );
    assert_eq!(
        ::core::mem::align_of::<Image>(),
        4usize,
        concat!("Alignment of ", stringify!(Image))
    );
    fn test_field_nativeImage() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Image>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeImage) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Image),
                "::",
                stringify!(nativeImage)
            )
        );
    }
    test_field_nativeImage();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Image>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(Image),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
    fn test_field_loadStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Image>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).loadStatus) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(Image),
                "::",
                stringify!(loadStatus)
            )
        );
    }
    test_field_loadStatus();
}
extern "C" {
    #[link_name = "\u{1}?FromFile@Image@Gdiplus@@SAPAV12@PB_WH@Z"]
    pub fn Image_FromFile(filename: *const WCHAR, useEmbeddedColorManagement: BOOL) -> *mut Image;
}
extern "C" {
    #[link_name = "\u{1}?FromStream@Image@Gdiplus@@SAPAV12@PAUIStream@@H@Z"]
    pub fn Image_FromStream(stream: *mut IStream, useEmbeddedColorManagement: BOOL) -> *mut Image;
}
impl Image {
    #[inline]
    pub unsafe fn FromFile(filename: *const WCHAR, useEmbeddedColorManagement: BOOL) -> *mut Image {
        Image_FromFile(filename, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn FromStream(stream: *mut IStream, useEmbeddedColorManagement: BOOL) -> *mut Image {
        Image_FromStream(stream, useEmbeddedColorManagement)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Bitmap {
    pub _base: Image,
}
#[test]
fn bindgen_test_layout_Bitmap() {
    assert_eq!(
        ::core::mem::size_of::<Bitmap>(),
        16usize,
        concat!("Size of: ", stringify!(Bitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<Bitmap>(),
        4usize,
        concat!("Alignment of ", stringify!(Bitmap))
    );
}
extern "C" {
    #[link_name = "\u{1}?FromFile@Bitmap@Gdiplus@@SAPAV12@PB_WH@Z"]
    pub fn Bitmap_FromFile(filename: *const WCHAR, useEmbeddedColorManagement: BOOL)
        -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromStream@Bitmap@Gdiplus@@SAPAV12@PAUIStream@@H@Z"]
    pub fn Bitmap_FromStream(stream: *mut IStream, useEmbeddedColorManagement: BOOL)
        -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromDirectDrawSurface7@Bitmap@Gdiplus@@SAPAV12@PAUIDirectDrawSurface7@@@Z"]
    pub fn Bitmap_FromDirectDrawSurface7(surface: *mut IDirectDrawSurface7) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromBITMAPINFO@Bitmap@Gdiplus@@SAPAV12@PBUtagBITMAPINFO@@PAX@Z"]
    pub fn Bitmap_FromBITMAPINFO(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
    ) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromHBITMAP@Bitmap@Gdiplus@@SAPAV12@PAUHBITMAP__@@PAUHPALETTE__@@@Z"]
    pub fn Bitmap_FromHBITMAP(hbm: HBITMAP, hpal: HPALETTE) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromHICON@Bitmap@Gdiplus@@SAPAV12@PAUHICON__@@@Z"]
    pub fn Bitmap_FromHICON(hicon: HICON) -> *mut Bitmap;
}
extern "C" {
    #[link_name = "\u{1}?FromResource@Bitmap@Gdiplus@@SAPAV12@PAUHINSTANCE__@@PB_W@Z"]
    pub fn Bitmap_FromResource(hInstance: HINSTANCE, bitmapName: *const WCHAR) -> *mut Bitmap;
}
impl Bitmap {
    #[inline]
    pub unsafe fn FromFile(
        filename: *const WCHAR,
        useEmbeddedColorManagement: BOOL,
    ) -> *mut Bitmap {
        Bitmap_FromFile(filename, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn FromStream(
        stream: *mut IStream,
        useEmbeddedColorManagement: BOOL,
    ) -> *mut Bitmap {
        Bitmap_FromStream(stream, useEmbeddedColorManagement)
    }
    #[inline]
    pub unsafe fn FromDirectDrawSurface7(surface: *mut IDirectDrawSurface7) -> *mut Bitmap {
        Bitmap_FromDirectDrawSurface7(surface)
    }
    #[inline]
    pub unsafe fn FromBITMAPINFO(
        gdiBitmapInfo: *const BITMAPINFO,
        gdiBitmapData: *mut ::core::ffi::c_void,
    ) -> *mut Bitmap {
        Bitmap_FromBITMAPINFO(gdiBitmapInfo, gdiBitmapData)
    }
    #[inline]
    pub unsafe fn FromHBITMAP(hbm: HBITMAP, hpal: HPALETTE) -> *mut Bitmap {
        Bitmap_FromHBITMAP(hbm, hpal)
    }
    #[inline]
    pub unsafe fn FromHICON(hicon: HICON) -> *mut Bitmap {
        Bitmap_FromHICON(hicon)
    }
    #[inline]
    pub unsafe fn FromResource(hInstance: HINSTANCE, bitmapName: *const WCHAR) -> *mut Bitmap {
        Bitmap_FromResource(hInstance, bitmapName)
    }
}
#[repr(C)]
pub struct CustomLineCap__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct CustomLineCap {
    pub vtable_: *const CustomLineCap__bindgen_vtable,
    pub nativeCap: *mut GpCustomLineCap,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_CustomLineCap() {
    assert_eq!(
        ::core::mem::size_of::<CustomLineCap>(),
        12usize,
        concat!("Size of: ", stringify!(CustomLineCap))
    );
    assert_eq!(
        ::core::mem::align_of::<CustomLineCap>(),
        4usize,
        concat!("Alignment of ", stringify!(CustomLineCap))
    );
    fn test_field_nativeCap() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CustomLineCap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeCap) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CustomLineCap),
                "::",
                stringify!(nativeCap)
            )
        );
    }
    test_field_nativeCap();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CustomLineCap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CustomLineCap),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
pub struct CachedBitmap__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct CachedBitmap {
    pub vtable_: *const CachedBitmap__bindgen_vtable,
    pub nativeCachedBitmap: *mut GpCachedBitmap,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_CachedBitmap() {
    assert_eq!(
        ::core::mem::size_of::<CachedBitmap>(),
        12usize,
        concat!("Size of: ", stringify!(CachedBitmap))
    );
    assert_eq!(
        ::core::mem::align_of::<CachedBitmap>(),
        4usize,
        concat!("Alignment of ", stringify!(CachedBitmap))
    );
    fn test_field_nativeCachedBitmap() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CachedBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeCachedBitmap) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(CachedBitmap),
                "::",
                stringify!(nativeCachedBitmap)
            )
        );
    }
    test_field_nativeCachedBitmap();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<CachedBitmap>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(CachedBitmap),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct Metafile {
    pub _base: Image,
}
#[test]
fn bindgen_test_layout_Metafile() {
    assert_eq!(
        ::core::mem::size_of::<Metafile>(),
        16usize,
        concat!("Size of: ", stringify!(Metafile))
    );
    assert_eq!(
        ::core::mem::align_of::<Metafile>(),
        4usize,
        concat!("Alignment of ", stringify!(Metafile))
    );
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PAUHMETAFILE__@@PBUWmfPlaceableFileHeader@2@PAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        header: *mut MetafileHeader,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PAUHENHMETAFILE__@@PAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader1(hEmf: HENHMETAFILE, header: *mut MetafileHeader) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PB_WPAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader2(
        filename: *const WCHAR,
        header: *mut MetafileHeader,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}?GetMetafileHeader@Metafile@Gdiplus@@SA?AW4Status@2@PAUIStream@@PAVMetafileHeader@2@@Z"]
    pub fn Metafile_GetMetafileHeader3(stream: *mut IStream, header: *mut MetafileHeader)
        -> Status;
}
extern "C" {
    #[link_name = "\u{1}?EmfToWmfBits@Metafile@Gdiplus@@SAIPAUHENHMETAFILE__@@IPAEHH@Z"]
    pub fn Metafile_EmfToWmfBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        eFlags: INT,
    ) -> UINT;
}
impl Metafile {
    #[inline]
    pub unsafe fn GetMetafileHeader(
        hWmf: HMETAFILE,
        wmfPlaceableFileHeader: *const WmfPlaceableFileHeader,
        header: *mut MetafileHeader,
    ) -> Status {
        Metafile_GetMetafileHeader(hWmf, wmfPlaceableFileHeader, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader1(hEmf: HENHMETAFILE, header: *mut MetafileHeader) -> Status {
        Metafile_GetMetafileHeader1(hEmf, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader2(
        filename: *const WCHAR,
        header: *mut MetafileHeader,
    ) -> Status {
        Metafile_GetMetafileHeader2(filename, header)
    }
    #[inline]
    pub unsafe fn GetMetafileHeader3(stream: *mut IStream, header: *mut MetafileHeader) -> Status {
        Metafile_GetMetafileHeader3(stream, header)
    }
    #[inline]
    pub unsafe fn EmfToWmfBits(
        hemf: HENHMETAFILE,
        cbData16: UINT,
        pData16: LPBYTE,
        iMapMode: INT,
        eFlags: INT,
    ) -> UINT {
        Metafile_EmfToWmfBits(hemf, cbData16, pData16, iMapMode, eFlags)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Matrix {
    pub nativeMatrix: *mut GpMatrix,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Matrix() {
    assert_eq!(
        ::core::mem::size_of::<Matrix>(),
        8usize,
        concat!("Size of: ", stringify!(Matrix))
    );
    assert_eq!(
        ::core::mem::align_of::<Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Matrix))
    );
    fn test_field_nativeMatrix() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Matrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeMatrix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Matrix),
                "::",
                stringify!(nativeMatrix)
            )
        );
    }
    test_field_nativeMatrix();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Matrix>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Matrix),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct Pen {
    pub nativePen: *mut GpPen,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Pen() {
    assert_eq!(
        ::core::mem::size_of::<Pen>(),
        8usize,
        concat!("Size of: ", stringify!(Pen))
    );
    assert_eq!(
        ::core::mem::align_of::<Pen>(),
        4usize,
        concat!("Alignment of ", stringify!(Pen))
    );
    fn test_field_nativePen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Pen>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativePen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Pen),
                "::",
                stringify!(nativePen)
            )
        );
    }
    test_field_nativePen();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Pen>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Pen),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct StringFormat {
    pub nativeFormat: *mut GpStringFormat,
    pub lastError: Status,
}
#[test]
fn bindgen_test_layout_StringFormat() {
    assert_eq!(
        ::core::mem::size_of::<StringFormat>(),
        8usize,
        concat!("Size of: ", stringify!(StringFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<StringFormat>(),
        4usize,
        concat!("Alignment of ", stringify!(StringFormat))
    );
    fn test_field_nativeFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<StringFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeFormat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(StringFormat),
                "::",
                stringify!(nativeFormat)
            )
        );
    }
    test_field_nativeFormat();
    fn test_field_lastError() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<StringFormat>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastError) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(StringFormat),
                "::",
                stringify!(lastError)
            )
        );
    }
    test_field_lastError();
}
extern "C" {
    #[link_name = "\u{1}?GenericDefault@StringFormat@Gdiplus@@SAPBV12@XZ"]
    pub fn StringFormat_GenericDefault() -> *const StringFormat;
}
extern "C" {
    #[link_name = "\u{1}?GenericTypographic@StringFormat@Gdiplus@@SAPBV12@XZ"]
    pub fn StringFormat_GenericTypographic() -> *const StringFormat;
}
impl StringFormat {
    #[inline]
    pub unsafe fn GenericDefault() -> *const StringFormat {
        StringFormat_GenericDefault()
    }
    #[inline]
    pub unsafe fn GenericTypographic() -> *const StringFormat {
        StringFormat_GenericTypographic()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct GraphicsPath {
    pub nativePath: *mut GpPath,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_GraphicsPath() {
    assert_eq!(
        ::core::mem::size_of::<GraphicsPath>(),
        8usize,
        concat!("Size of: ", stringify!(GraphicsPath))
    );
    assert_eq!(
        ::core::mem::align_of::<GraphicsPath>(),
        4usize,
        concat!("Alignment of ", stringify!(GraphicsPath))
    );
    fn test_field_nativePath() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GraphicsPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativePath) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(GraphicsPath),
                "::",
                stringify!(nativePath)
            )
        );
    }
    test_field_nativePath();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<GraphicsPath>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(GraphicsPath),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
#[repr(C)]
#[derive(Debug)]
pub struct Graphics {
    pub nativeGraphics: *mut GpGraphics,
    pub lastResult: Status,
}
#[test]
fn bindgen_test_layout_Graphics() {
    assert_eq!(
        ::core::mem::size_of::<Graphics>(),
        8usize,
        concat!("Size of: ", stringify!(Graphics))
    );
    assert_eq!(
        ::core::mem::align_of::<Graphics>(),
        4usize,
        concat!("Alignment of ", stringify!(Graphics))
    );
    fn test_field_nativeGraphics() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Graphics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).nativeGraphics) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Graphics),
                "::",
                stringify!(nativeGraphics)
            )
        );
    }
    test_field_nativeGraphics();
    fn test_field_lastResult() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<Graphics>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).lastResult) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(Graphics),
                "::",
                stringify!(lastResult)
            )
        );
    }
    test_field_lastResult();
}
